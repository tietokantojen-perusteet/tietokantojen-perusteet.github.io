<!DOCTYPE html>
<html>
  <head>
    <title>Tietokantojen perusteet</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" href="js/libs/syntaxhighlight/css/sh_style.css"/>
    <link rel="stylesheet" href="css/tikape.css"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css"/>
  </head>
  <body ng-app='myApp'>
    
    <!-- BEGIN NAV -->
    <header role="navigation">
      <h1>
        <button type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
	
        <a href="http://www.cs.helsinki.fi"><img src="img/header_tktl.png" alt="CS Dept. Univ. Helsinki"></a>
      </h1>
    </header>
    <!-- // END NAV -->
    <article>
      
      <!-- BEGIN INDEX -->
      <section id="intro" class="no-toc weeklimit" data-week-id="0">
	
        <header>
	  
          <div class="intro-header-img"></div>
	  
          <h1>Tietokantojen perusteet</h1>
	  
          <p><em>"miten tietoa sekä siihen liittyviä yhteyksiä mallinnetaan ja hallinnoidaan?" </em></p>
	  
        </header>
	
        <h1 id="start">Sisältö, aikataulu, arvostelu</h1>
	
        <p><em>"Kurssilla tutustutaan tiedon esitysmuotoihin ja tiedon hakuun suurista tietomääristä. Erityisenä painopisteenä ovat relaatiotietokannat, joiden kohdalla perehdytään toisaalta teoreettiseen perustaan ja toisaalta tietokannan käytännön käsittelyyn SQL-kielen avulla. Kurssilla opitaan myös perustiedot relaatiotietokantojen suunnittelusta."</em></p>
	
	<p><strong>Huom! Sisältö, aikataulu ja arvostelu koskee Helsingin yliopiston kesän 2017 kurssia.</strong></p>
	
        <p>Kurssi sisältää viisi kotitehtäväsarjaa. Tehtävät tulee tehdä ennen viikoittaisia harjoitustilaisuuksia. Harjoitustilaisuuksissa hyödynnetään kotitehtävien tekemisessä kertynyttä osaamista paikan päällä pohdittavissa suunnittelu- ja toteutustehtävissä.</p>


	<h2>Arvostelu</h2>
	
        <p>Kurssin arvostelu perustuu kurssikokeeseen, harjoitustehtäviin, harjoitustyöhön, sekä läsnäoloon harjoitustilaisuuksissa:</p>

	
        <ul>
          <li>Kurssikokeessa on kolme tehtävää, joista yksi on 10 pisteen ja kaksi 12 pisteen arvoisia. Kokeesta voi saada yhteensä 34 pistettä. Käytössä on koeleikkuri, eli kurssin hyväksytty suoritus vaatii vähintään puolia koepisteistä.</li>
	  <li>Tekemällä harjoituksissa läpikäytäviä ennalta tehtäviä harjoitustehtäviä, saa 0-2 pistettä harjoituskertaa kohden, riippuen tehtyjen tehtävien määrästä. Ennalta tehtävien harjoitustehtävien tekemisestä voi saada yhteensä 10 pistettä.</li>
	  <li>Kurssin toisella viikolla muodostetaan 3-5 hengen pienryhmät kurssilla tehtävää tietokannan suunnittelu- ja toteutustehtävää varten. Tehtävä palautetaan kurssin kuluessa kahdessa osassa (ensimmäinen osa 5.6. klo 18:00 mennessä, toinen osa 19.6. klo 18:00 mennessä). Suunnittelu- ja toteutustehtävästä voi enimmillään saada 9 pistettä, myöhästyneistä palautuksista vähennetään aina yksi piste alkavaa päivää kohti. Pienryhmätyön saa halutessaan tehdä myös yksin, mutta se ei ole suositeltavaa.</li>
	  <li>Suunnittelu- ja toteutustehtävä arvioidaan sekä kanssaopiskelijoiden että henkilökunnan toimesta. Vertaisarviointiin osallistumisesta saa enimmillään 2 pistettä.</li>
	  <li>Harjoitustilaisuuksissa paikan päällä tehtävien tehtävien tekemiseen osallistumisesta saa yhden pisteen harjoituskertaa kohden. Läsnäoloista voi saada yhteensä 5 pistettä.</li>
	  <li>Muutamia väliin jääneitä pisteitä voi korvata mittavammalla itsenäisesti tehtävällä harjoitustehtävällä.</li>
	</ul>
	
	<p>Koko kurssista voi saada 60 pistettä. Alustavat arvosanarajat ovat seuraavat:</p>
	
	<ul>
	  <li>31p -> 1</li>
	  <li>36p -> 2</li>
	  <li>41p -> 3</li>
	  <li>46p -> 4</li>
	  <li>51p -> 5</li>
	</ul>
	
	<!--
        <p><a class="jump" href="#viikoittaiset-teemat" role="button">Viikoittaiset teemat &raquo;</a></p>
-->
	
	
	<h2>Lisämateriaali</h2>
	
	<p>Tämän materiaalin lisäksi täydentävänä materiaalina voi käyttää Harri Laineen Tietokantojen perusteet -kurssin oppimateriaalia (<a href="ext/laine-tikape-osa1.pdf" target="_blank">osa 1</a>, <a href="ext/laine-tikape-osa2.pdf" target="_blank">osa 2</a> ja <a href="ext/laine-tikape-osa3.pdf" target="_blank">osa 3</a>), sekä kirjoja "Fundamentals of database systems" (Elmasri &amp; Navathe) ja "Database management systems" (Ramakrishnan &amp; Gehrke). Molemmat löytyvät opiskelijakirjastosta.</p>
	
	<p>Edellä mainittujen kirjojen ostaminen ei ole tätä kurssia varten suositeltavaa.</p>

	
        <h2>Esitietovaatimukset</h2>
	
        <p>Kurssilla on esitietovaatimuksena kurssi Ohjelmoinnin perusteet. Myös kursseista Ohjelmoinnin jatkokurssi ja Ohjelmistotekniikan menetelmät on kurssilla hyötyä.</p>


	
        <h2>Muiden auttaminen ja kunniasääntö</h2>

        <p>Vaikka helpoin vastaus avunpyyntöön on usein valmiiden ratkaisujen jakaminen, on se sekä toisen että oman oppimisen kannalta erittäin huono lähestymistapa. Opit parhaiten tutkimalla apua kysyvän ongelmaa ja tarjoamalla sellaista tukea, minkä avulla toinen ymmärtää ongelman ja pystyy etenemään. <strong>Osallistumalla kurssille sitoudut siihen, että et vie oppimisen iloa muilta esimerkiksi laittamalla tehtävien mallivastauksia verkkoon tai jakamalla niitä muille.</strong> Autat muita kurssilaisia parhaiten tekemällä tehtäviä yhdessä muiden kanssa, tarjoamalla apua harjoitustilaisuuksissa sekä osallistumalla teemaan liittyviin keskusteluihin vaikkapa kurssin IRC-kanavalla.</p>
	
        <div class="two-column">
          <div class="column">
	    
            <h1>Luennot ja harjoitustilaisuudet</h1>
	    
	    <p>Kurssin aloitusluento järjestetään perjantaina 5.5.2017 klo 16-18 Exactumin luentosalissa CK112.</p>
	    
	    <p>Kurssilla on viikoittaiset harjoitusryhmät, jotka järjestetään Exactumin salissa B221. Harjoitusryhmiin ilmoittautuminen tapahtuu kurssi-ilmoittautumisen yhteydessä. Harjoitukset alkavat viikolla 20, eli ensimmäiset harjoitustilaisuudet ovat tiistaina 16.5. ja torstaina 18.5.</p>
	    
          </div>
	  
          <div class="column">
	    
            <h1 id="irc-ohjeet">IRC-ohjeet</h1>
	    
            <p>Kurssilla on käytössä IRC-kanava #tikape -- ohjeita IRC:n käyttöön löytyy muunmuassa <a href="http://fuksiwiki.tko-aly.fi/IRC-ohjeet" target="_blank">Fuksiwikistä</a> sekä <a href="http://mooc.fi/courses/general/ohjelmointi/tukikanavat/irc/ohjeet/" target="_blank">mooc.fi:stä</a> (valitse kanavaksi #tikape).</p>
	    
          </div>
        </div>
	
	<!--

        <h1 id="viikoittaiset-teemat">Teemat</h1>
	
	
	<div id="week-toc" class="nav">
	  <table class="table table-striped">
	    <thead>
	      <tr>
		<th>Viikko</th>
		<th>Yleinen</th>
		<th>Suunnittelu</th>
		<th>SQL</th>
	      </tr>
	    </thead>
	    <tbody>
	      <tr>
		<td>1</td>
		<td>Johdanto, jäsennelty ja jäsentelemätön tieto, tiedon yhdistäminen</td>
		<td>Yhden taulun käsittely, yhdestä moneen yhteydet</td>
		<td>Relaatiot, tiedon hakeminen yhdestä taulusta</td>
	      </tr>
	      <tr>
		<td>2</td>
		<td>Käsitekaaviosta tauluiksi</td>
		<td>Monesta moneen yhteydet</td>
		<td>Tiedon hakeminen, tiedon yhdistäminen useammasta taulusta</td>
	      </tr>
	      <tr>
		<td>3</td>
		<td>Tietokantakyselyiden teko ohjelmallisesti</td>
		<td>Käsitekaavion luominen käsiteanalyysin avulla</td>
		<td>Tiedon yhdistäminen JOIN-komentojen avulla, tiedon lisääminen ja poistaminen</td>
	      </tr>
	      <tr>
		<td>4</td>
		<td>Ohjelmallinen kysely ja koosteoliot</td>
		<td></td>
		<td>Ali- ja yhteenvetokyselyt sekä tilastojen luominen</td>
	      </tr>
	      <tr>
		<td>5</td>
		<td></td>
		<td>Tiedon normalisointi, Taulujen määrittely, rajoitteet, Indeksit ja hakurakenteet</td>
		<td>Tiedon määrittely (DDL) ja tiedon muokkaaminen (DDM)</td>
	      </tr>
	      <tr>
		<td>6</td>
		<td>Tietokannat osana muita sovelluksia, Tietokanta osana web-sovellusta</td>
		<td></td>
		<td></td>
	      </tr>
	      <tr>
		<td>7</td>
		<td>Muita datan esitysmuotoja</td>
		<td>Tietokantatransaktiot ja tiedon eheys</td>
		<td></td>
	      </tr>
	    </tbody>
	  </table>
	</div>

	
	
        <h1 id="kasitteisto">Kurssin käsitteistöä</h1>
	
	
	<div id="week-toc" class="nav">
	  <table class="table table-striped">
	    <thead>
	      <tr>
		<th>Käsite</th>
		<th>Selitys</th>
	      </tr>
	    </thead>
	    <tbody>
	      <tr>
		<td>wip</td>
		<td>work in progress, työn alla</td>
	      </tr>
	    </tbody>
	  </table>
	</div>

        <h1>Sisällysluettelo</h1>
-->
	
        <button type="button" class="btn btn-info" data-toggle="collapse" data-target="#sisallys">Sisällysluettelo >></button>

	<div id="sisallys" class="collapse">

        <ul class="nav" id="material-toc"></ul>

	</div>

	<!--
            <h1>Materiaalin itseopiskelu- ja kertaustehtävät</h1>
	    
            <ul class="nav nav-pills nav-pills-fixed-width" id="tehtavat-toc"></ul>
	    -->

<!--
        <h1 id="tehtavat-list">Kurssin tehtävät</h1>
	
	<p>Kurssilla on viikoittaisia kotitehtäväsarjoja, jotka käydään laskuharjoitustilaisuuksissa läpi. Laskuharjoitustilaisuuksissa myös tehdään paikan päällä tehtäviä tehtäviä. Näiden lisäksi kurssimateriaalissa on erikseen merkittyjä pohdinta- ja SQL-ohjelmointitehtäviä.</p> 
-->
	
	<h2>Pikaohjeita</h2>
	<ul>
	  <li><a href="https://docs.google.com/document/d/15kLH2i82rMs249vEJkFSJHVcLkjxwJiGBxyooyuUA_Q/edit?usp=sharing">Ohje terminaalin käyttöön</a></li>
	  <li><a href="https://docs.google.com/document/d/1MhivYOumGfQ0D6PvxPZl5WStgZCaTM--jDqfIGrbpFM/edit?usp=sharing">Github-ohje ryhmätöille</a></li>
	</ul>

	<h2>Puuttuvia pisteitä korvaava tehtävä</h2>
	<ul>
	  <li><a href="https://docs.google.com/document/d/1SDOXg81z558OgNu6IzN17UbZN7ZzRmuUl4StKJ-V--w/edit?usp=sharing">Korvaava suunnittelutehtävä</a></li>
	</ul>



	<h2>Kotona tehtävät tehtäväsarjat</h2>
	
	<ul>
	  <li><a href="https://docs.google.com/document/d/1O2Q_CKLx6cHdsIpJk7PugYWElbZvolwTdsNn44WE2e8/edit?usp=sharing" target="_blank">Kurssin ensimmäinen viikko</a></li>
	  <li><a href="https://docs.google.com/document/d/1bY6YdSQajycHNDA0Xi5IRnRMWGX5gMD3SEa7ZMk1daY/edit?usp=sharing" target="_blank">Kurssin toinen viikko</a></li>
	  <li><a href="https://docs.google.com/document/d/1ujKP8pcmiHnZyBmHzCzqJln0uhMtxFZft54NtkL6SP8/edit?usp=sharing" target="_blank">Kurssin kolmas viikko</a></li>
	  <li><a href="https://docs.google.com/document/d/1Pjg2OotVk70MSqpigJCT0uRml3nBawtdkVc9oRbWtMA/edit?usp=sharing" target="_blank">Kurssin neljäs viikko</a></li>
	  <li><a href="https://docs.google.com/document/d/1JZuolCk12vaVMf-4VyClv6nc4eK0moDim3T-51ubFCc/edit?usp=sharing" target="_blank">Kurssin viides viikko</a></li>
<!--
-->
	</ul>

	<h2>Paikan päällä tehtävät tehtäväsarjat</h2>


	<ul>
	  <li><a href="https://docs.google.com/document/d/1z2aAqjlPez6XVIeBFOV2zgHAHgD5JI-mRFh1KhcgX6I/edit?usp=sharing" target="_blank">Kurssin ensimmäinen viikko</a></li>
	  <li><a href="https://docs.google.com/document/d/1fmpYuktPiis_4_sH4_x01jozRlu3RaEEL1qG7F-H7iA/edit?usp=sharing" target="_blank">Kurssin toinen viikko</a></li>
	  <li><a href="https://docs.google.com/document/d/1gmI1hOkBq_N-TA367T-A18FTuz44hXZiestFJGp_JM0/edit?usp=sharing" target="_blank">Kurssin kolmas viikko</a></li>
	  <li><a href="https://docs.google.com/document/d/1lwRYf_9G7ba9l5dXwIW0DOYfpansBlOYGnQgF-EaxHg/edit?usp=sharing" target="_blank">Kurssin neljäs viikko</a></li>
	  <li><a href="https://docs.google.com/document/d/1OtE38kOP97TaDYmeIoF-YlcXzf-21uMcEfSk1gE6bAs/edit?usp=sharing" target="_blank">Kurssin viides viikko</a></li>
<!--
	  <li><a href="https://docs.google.com/document/d/1snNa0Tmbzk9WloYjjGLLrFNGL2OMDJuEELWpMplLBM8/edit?usp=sharing" target="_blank">Kurssin ensimmäinen viikko</a></li>
	  <li><a href="https://docs.google.com/document/d/1v4d8mrBy780B84LFB5-8uzagaOsXfXymJYN9Umkx3zM/edit?usp=sharing" target="_blank">Kurssin toinen viikko</a></li>
	  <li><a href="https://docs.google.com/document/d/1BnG6l9Tv2iUa6vVzjB-KXJrRI7IEV0llgh8SkjGq9pw/edit?usp=sharing" target="_blank">Kurssin kolmas viikko</a></li>
	  <li><a href="https://docs.google.com/document/d/1f3gBQ8HOEtIc5niN30NWz13g4jmzIjsRN3AuEuCcm20/edit?usp=sharing" target="_blank">Kurssin neljäs viikko</a></li>
	  <li><a href="https://docs.google.com/document/d/1zeiKV52aa4f921FUp3Qom-gFZQbL_gGbNX9clqLB0FY/edit?usp=sharing" target="_blank">Kurssin viides viikko</a></li>
-->
	</ul>


	

	
	<h2>Ryhmätyö</h2>
	
	<p>Ryhmät muodostetaan toisissa laskuharjoituksissa, ole siis paikalla!</p>

	<ul>
	  <li><a href="https://docs.google.com/document/d/1HY8Q4rdUyjciO39AMPcomvbvcg19vgXwFgm-uoODZ8M/edit?usp=sharing" target="_blank">Ryhmätyötehtävä</a> ja <a href="https://docs.google.com/document/d/10DIVP858Ne1Dr55JwKgkfAYiVPElSJvLEDpWeac3y2I/edit?usp=sharing" target="_blank">ryhmätyöohjeet</a></li>
	  <li><a href="Malliraportti.pdf" target="_blank">Lopullisen palautuksen muotoa kuvaava malliraportti.</a></li>
	</ul>


	<h2>Kurssikoe</h2>

	<p>Kurssin koe järjestetään Avoimen yliopiston käytänteiden mukaisesti. Koetilaisuudet ovat ennen kurssin alkua olevan tiedon mukaan ma 19.6.2017 klo 17-20, la 19.8.2017 klo 9-12 ja ma 11.9.2017 klo 17-20. <a href="https://www.avoin.helsinki.fi/palvelut/tenttipaikat.aspx" target="_blank">Koepaikan</a> ja <a href="https://www.helsinki.fi/fi/avoin-yliopisto/opiskelu/opintojen-aikana/tentit" target="_blank">koekäytännöt</a> saat tietää Avoimen kautta. Tarkista ajat ja paikat tenttipäivän lähestyessä Avoimen sivuilta muutosten varalta! Kokeeseen saa tuoda mukana käsin kirjoitetun kaksipuolisen A4-kokoisen lunttilapun. Lunttilappu tulee palauttaa kokeen yhteydessä.</p>
<!--
	<p>Kurssin koe järjestetään 8.3. klo 16:00 Exactumin saleissa A111 ja B123. Kokeeseen saa tuoda mukana käsin kirjoitetun kaksipuolisen A4-kokoisen lunttilapun. Lunttilappu tulee palauttaa kokeen yhteydessä.</p>
-->
<!--
	<p>Lisätietoa myöhemmin.</p>
-->
<!--
	<p>Kurssin koetilaisuudet ovat ma 27.6.2016 klo 16-19, la 13.8.2016 klo 9-12 ja ma 12.9.2016 klo 17-20. <a href="https://www.avoin.helsinki.fi/palvelut/tenttipaikat.aspx" target="_blank">Koepaikan</a> ja <a href="https://www.helsinki.fi/fi/avoin-yliopisto/opiskelu/opintojen-aikana/tentit" target="_blank">koekäytännöt</a> saat tietää Avoimen kautta. Tarkista ajat ja paikat tenttipäivän lähestyessä Avoimen sivuilta muutosten varalta!</p>
-->	
	<!--
	<p>Kurssin koe järjestetään 9.3. klo 16:00 salissa A111 (huom! kokeet alkavat aina tasalta -- tule ajoissa paikalle).</p>

	    <p>Katso lisää <a href="#chapter12">koeasiaa</a>.</p>
	    -->
	
      </section>
      <!-- END INDEX -->
      
      
      <section class="weeklimit" data-week-id="1">
	
        <header>
          <h1 id="viikko1">Viikko 1</h1>
        </header>
	
        <h1>Johdanto</h1>
	
	
	<p>Kävellessäsi Helsingin keskustassa näet ihmisvilinän, kuulet puheensorinan, huomaat uutisotsikoita, mainostauluja ja erilaisia laitteita, jotka tarjoavat monipuolista tietoa sinua ympäröivästä maailmasta. Vaikka tämä toiminta voi tuntua satunnaiselta, voit havaita siitä erilaisia sääntöjä ja hahmoja. Ihmiset kulkevat paikasta toiseen tietoisten tai tiedostamattomien tavoitteiden ohjaamina. Puhe tapahtuu tietyllä kielellä, jolla on oma kielioppi. Uutisotsikoilla on tietynlainen tekstityyli. Mainostaulut hakevat näytettävän mainoksen verkon yli, ja laitteet -- esimerkiksi kännykkäsi -- seuraavat niihin ohjelmoituja sääntöjä, osittain antamiesi komentojen ohjaamana.</p>

	<p>Nämä säännöt ja hahmot kuvaavat tiedon rakennetta. Osa tiedosta on jäsentelemätöntä, eli sille ei ole tarkasti määriteltyä muotoa. Esimerkiksi puheensorina voi poukkoilla teemasta toiseen, ja vastaavasti tietoisten ja tiedostamattomien tavoitteiden tarkka kirjaaminen olisi, ainakin, hyvin haastavaa.</p>

	<p>Toisaalta, voit lukea saman uutisen lähes sanasta sanaan lehdestä, kännykästäsi tai netistä, olettaen että uutispalvelun tarjoaja on sama. Uutinen on jäsennelty otsikkoon, johdantoon, ja tekstikappaleisiin sekä niihin liittyviin väliotsikkoihin. Eri järjestelmät näyttävät tämän tiedon eri tavalla, ja samalla tarjoavat uutistietoon erilaisen pääsyn. Toimittaja muokkaa ja katsoo uutista sen kirjoittamiseen tarkoitetun sisällönhallintajärjestelmän kautta, kännykällä uutista lukeva saattaa nähdä uutisen kännykän ominaisuuksiin mukautuvan web-sivuston kautta, ja uutisia listaava uutissivusto saattaa listata uutisesta vain sen otsikon.</p>

	<p>Puhekielessä termillä tietokanta tarkoitetaan yleisesti ottaen tiedon tallentamiseen tarkoitettua paikkaa, josta tietoa voi myös hakea. Esimerkiksi kirkonkirjat voidaan nähdä eräänlaisena sukujen historiaa dokumentoivana tietokantana, jonka kautta sukututkija pääsee käsiksi sukunsa historiaan. Vaikka tietokannat ovat digitalisaation myötä siirtymässä paperisesta muodosta sähköiseen muotoon, on niiden tavoite pysynyt pitkälti samana: <em>haluamme säilöä tietoa, ja haluamme päästä tähän tietoon käsiksi</em>. Tällä kurssilla käsittelemme elektronisia tietokantoja, joiden kehittyminen on johtanut tilanteeseen, missä tietoa tallennetaan yhä enemmän ja sitä halutaan hyödyntää yhä monipuolisemmin.</p>
	
	<aside class="info">
	  <br/>
	  <h1>Tutustu tietokantaan!</h1>
	  
	  <p>Tässä kohtaa on erittäin hyvä hetki käydä tutustumassa muutamaan tietokantapalveluun. Osoitteessa <a href="http://hiski.genealogia.fi/hiski/" target="_blank">http://hiski.genealogia.fi/hiski/</a> on Suomen Sukututkimusseuran ylläpitämä Historiakirjojen hakupalvelu. Käy sivulle, valitse kieli, etsi "Kaikista", ja valitse "Kastetut".</p>
	  
	  <p>Minkälaisia tuloksia löydät omalla etunimelläsi? Entä, minkälaisia tuloksia löydät nimillä Matti ja Maija? Palvelu pyrkii muunmuassa sisällyttämään läheiset nimien muunnokset hakutuloksiin, sillä nimet muuttuvat ajan myötä. </p>
	</aside>
	
	<p>Nykyään tietokantoja on kaikkialla. Tämä kurssimateriaali sijaitsee tietokannassa, kurssitehtäviin liittyvät pisteet kirjataan tietokantaan, ja tehdessäsi kurssilla tarpeeksi töitä kurssiin liittyvien oppimistavoitteiden saavuttamiseksi kurssista kirjataan suoritusmerkintä tietokantaan. Jo pelkästään nykyaikaisessa kännykässäsi on kymmeniä erilaisia tietokantoja; yhteystiedot, kalenteri, herätyskello, aikavyöhykkeet, karttapalvelut, suosikkiverkkosivut, jonka lisäksi moni kännykkäsovellus hyödyntää yhtä tai useampaa tietokantaa. Tietokannat voivat olla paikallisia, eli ne voivat sijaita samalla koneella tietokantaa käyttävän ohjelmiston kautta, esimerkiksi kännykässä, tai ne voivat sijaita erillisellä palvelimella, johon otetaan tarvittaessa yhteyttä. Loppukäyttäjän näkökulmastasi tällä ei kuitenkaan ole juurikaan merkitystä. Näet tietokannasta haetun tiedon käyttämäsi sovelluksen tarjoaman näkymän kautta.</p>
	
	
	<aside class="info">
	  <br/>
	  <h1>Tieto toistuu, monistuu, ja yhdistyy</h1>
	  
	  <p>Moni tietokantaa käyttävä palvelu käyttää henkilöihin liittyviä tietoja, kuten osoitetta, puhelinnumeroa tai sähköpostiosoitetta. Kun rekisteröidyt verkossa oleviin palveluihin, on tyypillistä, että ne pyytävät vähintään sähköpostiosoitteen. Nämä tiedot tallentuvat kuitenkin palvelu- tai yrityskohtaisiin tietokantoihin, josta niitä mahdollisesti yhdistellään.</p>
	  
	  <p>Pohdi, kuinka moneen palveluun olet syöttänyt sähköpostiosoitteesi? Entä nimesi tai syntymäpäiväsi? Tyypillisesti moni näistä palveluista on erillinen, mutta, tulevaisuudessa tätä tietoa tullaan yhdistämään yhä enemmän ja enemmän paremman yleiskuvan saamiseksi, sekä tilastoihin perustuvien päätösten tekemiseksi.</p>

	  <p>Esimerkiksi sekä sähkö- että peliyhtiöt kummatkin hyötyvät merkittävästi saadessaan tietoa palvelun käyttöasteesta. Sähköyhtiöt voivat käyttää tätä tietoa sähkön tarpeen ennustamiseen, jonka avulla sähkön tuotantoa voidaan säännöstellä -- peliyhtiöt taas voivat muunmuassa hyödyntää käyttötilastoja pelin toimivien ja ei-toimivien osa-alueiden kehittämiseen.</p>

	</aside>
	
	<p>Käytämme tällä kurssilla yhtenä esimerkkinä opiskelun ja oppimisen seuraamiseen tarkoitettua järjestelmää, joka kehittyy materiaalin edetessä. Järjestelmä pitää kirjaa kursseista, opiskelijoista, kurssiharjoituksista, arvosanoista, kurssipalautteista, sekä muista oleellisista asioista, joita kurssin edetessä tulee esille. Jotta tämä onnistuisi, tarvitsemme jonkinlaisen jäsentelytavan eli rakenteen tallennettavalle tiedolle, tapoja tiedon tallentamiseen tässä sovitussa muodossa, sekä tapoja erilaisten raporttien luomiseen. Katsotaan miten käy..</p>

	
	<h2>Tietokanta ja tiedon rakenteen kuvaaminen</h2>
		
	<p>Tietokanta on kokoelma tiettyyn aihepiiriin liittyviä säilytettäviä tietoja. Tietokannan luominen liittyy usein jonkinlaisen organisaation, yrityksen tai muun yhteisön tarpeeseen säilöä ja hakea tietoa. Esimerkiksi yliopisto haluaa pitää kirjaa opiskelijoistaan ja heidän opintomenestystään, hotelli haluaa pitää kirjaa hotellin huoneiden varauksista, ja kauppaketju haluaa pitää kirjaa asiakkaistaan ja asiakkaiden ostoksista.</p>
	
	<p>Tallennettava tieto liittyy tyypillisesti johonkin tavoitteeseen. Yliopisto haluaa seurata opintojen etenemistä esimerkiksi valtionhallinnolle raportointia varten, huoneiden varaustilannetta seuraava hotelli taas haluaa tietää milloin huoneita on paljon tarjolla, ja milloin huoneet ovat lopussa. Kauppaketjun ensisijaisena tavoitteena on asiakkaiden ostosten seuranta myynnin optimoimiseksi.</p>
	
	<p>Tietokantojen rakennetta ja jäsentelyä suunniteltaessa ongelmaa lähestytään tavoitteeseen liittyvien käsitteiden kautta, joiden avulla pyritään ymmärtämään mikä tiedosta on epäoleellista, ja mikä tulee säilöä. Samalla mietitään myös säilöttävien käsitteiden ominaisuuksia sekä käsitteiden suhteita. Esimerkiksi opiskelijan opintomenestyksen seurannassa oleellisia ovat ainakin käsitteet <em>Opiskelija</em> ja <em>Kurssisuoritus</em>, joilla on yhteys: opiskelijalla on kurssisuorituksia.</p>
	
	<p>Tällä kurssilla tiedon mallintamiseen käytetään <a href="http://www.uml.org/" target="_blank">UML</a>-kieltä, johon syvennytään tarkemmin kurssilla <em>Ohjelmistotekniikan menetelmät</em>. Käytämme <a href="https://fi.wikipedia.org/wiki/Luokkakaavio" target="_blank">luokkakaavioista</a> johdettua tapaa käsitteiden ominaisuuksien ja suhteiden mallintamiseen, mutta, emme kuitenkaan seuraa kuvaustapaa pilkuntarkasti. Esimerkiksi navigointisuuntaa sekä kooste- ja kompositiomerkintää ei käytetä lainkaan. </p>
	
	<figure>
	  <img src="img/johdanto/opiskelija-ja-kurssisuoritus-erilliset-kasitteet.png" alt="Teksti 'Opiskelija' suunnikkaan sisään kirjoitettuna, Teksti 'Kurssisuoritus' toisen suunnikkaan sisään kirjoitettuna.">
	  <figcaption>Käsitteet kuvataan laatikkoina, joiden sisällä on käsitteen nimi. Yllä käsitteet Opiskelija ja Kurssisuoritus.</figcaption>
	</figure>
	
	<p>Jos haluamme ilmaista, että käsite liittyy toiseen käsitteeseen, piirrämme käsitteiden välille viivan. Viivan kumpaankin päätyyn merkitään osallistumisrajoitteet, joilla kuvataan sitä, että kuinka monessa samantyyppisessä yhteydessä käsitteen ilmentymä voi olla. Jos ilmentymään voi liittyä tasan yksi toisen tyyppinen ilmentymä, lisäämme viivan toisen tyyppisen ilmentymän päähän numeron yksi. Toisaalta, jos ilmentymien määrä on rajoittamaton, lisäämme viivan päähän tähden. Alla olevassa kaaviossa on käsitteet Opiskelija ja Kurssisuoritus, sekä viiva käsitteiden välillä. Yhteen kurssisuoritukseen liittyy aina tasan yksi opiskelija, mutta yhdellä opiskelijalla voi olla useampia kurssisuorituksia.</p>
	
	<figure>
	  <img src="img/johdanto/opiskelija-ja-kurssisuoritus-ei-attribuutteja.png" alt="Teksti 'Opiskelija' suunnikkaan sisään kirjoitettuna, Teksti 'Kurssisuoritus' toisen suunnikkaan sisään kirjoitettuna. Suunnikkaiden välille on piirretty viiva, jonka Kurssisuoritus-käsitteen päässä on tähti.">
	  <figcaption>Opiskelijaan liittyy useita kurssisuorituksia, mutta jokaiseen kurssisuoritukseen liittyy tasan yksi opiskelija.</figcaption>
	</figure>
	
	<p>Käsitteisiin kuuluu tyypillisesti ominaisuuksia. Ominaisuudet merkitään laatikkoon käsitteen nimen alle. Alla olevassa kuvassa Opiskelija-käsitteeseen liittyy ominaisuudet nimi, syntymävuosi ja pääaine.</p>
	
	<figure>
	  <img src="img/johdanto/opiskelija-ja-ominaisuudet.png" alt="Teksti 'Opiskelija' suunnikkaan sisään kirjoitettuna, suunnikkaan alalaidassa kiinni toinen suunnikas, jossa tekstit 'nimi', 'syntymävuosi' ja 'pääaine' omilla riveillään. ">
	  <figcaption>Käsitteillä voi olla ominaisuuksia. Opiskelija-käsitteeseen liittyy nimi, syntymävuosi, ja pääaine.</figcaption>
	</figure>
	
	<p>Myös kurssisuoritukseen liittyy ominaisuuksia. Alla opiskelijaan liittyy useita kurssisuorituksia, jonka lisäksi käsitteisiin liittyvät ominaisuudet on myös merkitty.</p>
	
	<figure>
	  <img src="img/johdanto/opiskelija-ja-kurssisuoritus.png" alt="Teksti 'Opiskelija' suunnikkaan sisään kirjoitettuna, Teksti 'Kurssisuoritus' toisen suunnikkaan sisään kirjoitettuna. Suunnikkaiden välille on piirretty viiva, jonka Kurssisuoritus-käsitteen päässä on tähti. Käsitteiden alla on myös niiden ominaisuudet kuten edellisessä kuvassa.">
	  <figcaption>Opiskelijaan liittyy useita kurssisuorituksia. Käsitteille on merkitty myös ominaisuudet.</figcaption>
	</figure>
	
	<p>Kun piirrät kaavioita, älä käytä piirtämiseen liikaa aikaa. Oleellisinta on se, että tärkeät asiat ovat paperilla. Jos huomaat, että käytät liikaa aikaa, heitä paperi roskiin, ja aloita alusta.</p>
	
	<aside class="info">
	  <br/>
	  
	  <h1>Pientä pohdintaa!</h1>
	  
	  <p>Hahmottele paperille seuraavaan kuvaukseen liittyvä kaavio yllä esitetyllä tavalla. Mitkä ovat käsitteet, ja miten ne liittyvät toisiinsa?</p>
	  
	  <p><em>Opettajalla on useita kursseja, joita hän opettaa. Jokaiseen kurssiin liittyy ajankohta, jolloin kurssi järjestetään, sekä kurssin käyttämä sali.</em></p>
	  
	  <p>Mitä voimme sanoa opettajan kalenterista kuvauksen perusteella? Entä salien varaustilanteesta?</p>
	  
	</aside>
	
	<p>Käsitteitä ja niiden sisältämää tietoa voidaan ajatella tauluna, jossa jokainen rivi kuvaa yksittäistä käsitteen ilmentymää.</p>
	
	<div class="data-table">
	  <h4>Opiskelija</h4>
	  <table class="table">
	    <thead>
	      <tr>
		<th>nimi</th>
		<th>syntymävuosi</th>
		<th>pääaine</th>
	      </tr>
	    </thead>
	    <tbody>
	      <tr>
		<td>Pihla</td>
		<td>1997</td>
		<td>Tietojenkäsittelytiede</td>
	      </tr>
	      <tr>
		<td>Joni</td>
		<td>1993</td>
		<td>Tietojenkäsittelytiede</td>
	      </tr>
	      <tr>
		<td>Anna</td>
		<td>1991</td>
		<td>Matematiikka</td>
	      </tr>
	      <tr>
		<td>Krista</td>
		<td>1990</td>
		<td>Tietojenkäsittelytiede</td>
	      </tr>
	      <tr>
		<td>Matti</td>
		<td>1970</td>
		<td>Matematiikka</td>
	      </tr>
	      <tr>
		<td>Gandhi</td>
		<td>1869</td>
		<td>Oikeustiede</td>
	      </tr>
	    </tbody>
	  </table>
	</div>
	
	<p>Vastaavasti myös kurssisuorituksia kuvaamaan voisi tehdä oman erillisen taulun.</p>
	
	<aside class="info">
	  
	  <br/>
	  
	  <h1>Ensiaskeleita tiedon yhdistämiseen</h1>
	  
	  <p>Kysymykseksi nousee "<em>Miten yhdistämme Opiskelijaa kuvaavan taulun ja Kurssisuoritusta kuvaavan taulun tietoja?</em>". Olio-ohjelmoinnissa Kurssisuoritusolio sisältäisi viitteen Opiskelijaolioon, tai mahdollisesti, jokainen Opiskelijaolio sisältäisi listan viitteitä Kurssisuoritusolioon.</p>
	  
	  <p>Olio-ohjelmoinnissa viite on oikeastaan osoite muistipaikkaan, missä olion tiedot ovat. Voisiko kurssisuoritukseen lisätä jonkinlaisen muistiviitteen opiskelijaan? Palaamme tähän relaatiomallin ja relaatiotietokantojen yhteydessä.</p>
	  
	</aside>
	
	
	<h2>Tietokannanhallintajärjestelmä</h2>
	
	<p>Tietokanta sijaitsee tyypillisesti tietokannanhallintajärjestelmässä, jonka kautta tietokantaan pääsee käsiksi. Tietokannanhallintajärjestelmän vastuulla on tietokantaan kohdistuvien haku-, muokkaus- ja lisäystoimintojen toiminnan lisäksi käyttöoikeuksien valvominen. Yksittäisessä tietokannanhallintajärjestelmässä voi kustannus- ja tehokkuussyistä sijaita useisiin erilaisiin sovelluksiin ja käyttötarkoituksiin liittyviä tietokantoja, joita jokaista käyttää eri käyttäjät tai eri yritys.</p>
	
	<p>Yksittäinen sovellus voi käyttää myös useampaa tietokantaa, jotka sijaitsevat eri tietokannanhallintajärjestelmissä. Tyypillinen esimerkki tällaisesta sovelluksesta on analytiikkapalvelu, joka yhdistää eri palveluiden tallentamaa tietoa yhteenvetoraporttien luomiseksi.</p>
	
	
	<p>Tietokannanhallintajärjestelmän vastuulla on myös tiedon eheyteen liittyvien sääntöjen noudattamisen valvonta. Tietokannassa voi olla esimerkiksi sääntö "Opiskelijan syntymävuoden tulee sisältää neljä numeroa", jolloin uusien opiskelijoiden lisääminen ilman oikein määriteltyä syntymävuotta ei voida lisätä tietokantaan. Vastaavia sääntöjä voidaan lisätä muunmuassa varausjärjestelmiin, esimerkiksi lentokoneiden paikkavarausjärjestelmissä halutaan varmistaa, että jokaisella istuimella on korkeintaan yksi varaus. Vastaavasti, tietokannanhallintajärjestelmän vastuulla on varmistaa, että tietoa ei tuhoudu, vaikka tietokantaa käyttävä järjestelmä hajoaisi -- erilaiset varmuuskopiotoiminnallisuudet ovat tyypillisiä.</p>
	
	<p>Tämän lisäksi, tietokannanhallintajärjestelmät tarjoavat tyypillisesti välineitä tiedon hakemiseen liittyvien toimintojen tehokkuuden tarkastelemiseen. Vaikka opintojen seurantaan liittyvä järjestelmämme sisältäisi tiedot kaikista Helsingin yliopiston opiskelijoista (n. 35000), sekä kaikista kurssisuorituksista (rutkasti), tulisi tietokantaan tehtävien kyselyjen toimia silti mielekkäässä ajassa. Edellämainittukin tietomäärä on esimerkiksi Amazon-verkkokaupan mittakaavassa hyvin pieni.</p>
	
	<p>Vaikka tietokantaa käyttävän sovelluksen tehokkuuteen vaikuttaa tietokone tai palvelin, jolle sovellus on asennettu, emme tällä kurssilla ota juurikaan kantaa ns. rautatason toimintaan.</p>
	
	
	<aside class="extra">
	  
	  <h1>Historian siipien havinaa</h1>
	  
	  
	  <p>Tiedon tallentamiseen käytettiin alunperin tekstitiedostoja, joiden välillä tietoa pyrittiin yhdistämään joko manuaalisesti tai ohjelmallisesti. Ensimmäisten tietokannanhallintajärjestelmien yhteydessä siirryttiin tiedon todellisen tallennusmuodon abstrahointiin käyttäjältä, ja tietoa käsiteltiin erillisen ohjelmointirajapinnan kautta. Tiedon linkittäminen tapahtui käytännössä muistiviitteiden avulla, jolloin tiedon hakemiseen liittyi näiden muistiviitteiden kautta navigoiminen, johon tarvittiin asiaan erikoistunut ohjelmoija.</p>
	  
	  
	  <p>Navigointiin perustuvissa järjestelmissä yhtenä ongelmana oli kuitenkin se, että ohjelmoijan tuli korjata järjestelmän navigointirakenne kun rakenne muuttui. Jos tietokannasta poistettiin yksittäinen tietue, saattoi huonoimmassa tapauksessa tietueen kautta löydettävät asiat kadota poiston yhteydessä.</p>
	  
	  <p>Koska tiedon hakeminen oli tyypillisesti hidasta, tietoa tallennettiin useampaan paikkaan navigoimisen vähentämiseksi. Kun tietokoneet kehittyivät, toistetun tiedon käyttämistä voitiin vähentää, ja samalla yksittäistä tietokannanhallintajärjestelmää pystyi käyttämään useampi ohjelmoija ja ohjelma. Suurin viimeaikainen kehitysaskel tapahtui kuitenkin relaatiotietomallin esittelyn yhteydessä, missä vastuu navigointiin liittyvien polkujen tekemisestä jätetään täysin ohjelmoijan vastuulle.</p>
	  
	  <p>Lue osoitteessa <a href="http://www.tomandmaria.com/Tom/Writing/HowThe%20DataGotItsBase.pdf" target="_blank">http://www.tomandmaria.com/Tom/Writing/HowThe%20DataGotItsBase.pdf</a> oleva Thomas Haighin kirjoittama katsaus tietokantojen historiaan.</p>
	  
	</aside>
	
	
	
	<h1>Johdanto relaatiomalliin ja relaatiotietokantoihin</h1>
	
	
	<p>Relaatiomallin perusajatus on tallennettavan tiedon jakaminen käsitteisiin sekä käsitteiden välisiin yhteyksiin. Jokaista käsitettä vastaa relaatiotietokannassa taulu, ja jokaiselle käsitteen ominaisuudelle eli attribuutille on taulussa oma sarake. Jokainen taulun rivi vastaa yhtä käsitteen ilmentymää, ja tietokantatauluja määriteltäessä taululle määritellään tyypillisesti myös <em>avain</em>, jonka perusteella kukin rivi -- eli käsitteen ilmentymä -- voidaan yksilöidä.</p>
	  
	<p>Kun pohdimme Opiskelija-käsitettä, jolla on nimi, syntymävuosi, ja pääaine, huomaamme, että opiskelijan yksilöinti olemassaolevien tietojen perusteella on lähes mahdotonta. Esimerkiksi vuonna 1991 syntyneitä matematiikkaa opiskelevia Anna-nimisiä opiskelijoita löytyy useampia.</p>
	
	<p>Luodaan Opiskelija-käsitteestä tietokantataulu. Tietokantataulussa opiskelija-käsitteelle määritellään opiskelijan yksilöivä avain, jonka lisäksi muut käsitteeseen liittyvät attribuutit lisätään tietokantataulun sarakkeiksi. Tietokantataulun voi piirtää kaaviona kuten alla -- yksilöivän avaimen voi merkitä joko alleviivaamalla käsitteen, tai merkitsemällä käsitteen eteen merkki <em>(pk)</em>, eli <em>primary key</em>.</p>
	
	<figure>
	  <img src="img/johdanto/opiskelija-ja-opiskelijanumero.png" alt="[Opiskelija|(pk) opiskelijanumero;nimi;syntymävuosi;pääaine]">
	  <figcaption>Opiskelija-taulua luodessa opiskelijaan on lisätty jokaisen opiskelijan yksilöivä avain, tässä tapauksessa opiskelijanumero. Avain on merkitty tekstillä (pk) sen selkeyttämiseksi.</figcaption>
	</figure>
	
	
	<p>Tietokantataulussa oleva data voi näyttää esimerkiksi seuraavalta:</p>
	
	<div class="data-table">
	  <h4>Opiskelija</h4>
	  <table class="table">
	    <thead>
	      <tr>
		<th>opiskelijanumero</th>
		<th>nimi</th>
		<th>syntymävuosi</th>
		<th>pääaine</th>
	      </tr>
	    </thead>
	    <tbody>
	      <tr>
		<td>9999999</td>
		<td>Pihla</td>
		<td>1997</td>
		<td>Tietojenkäsittelytiede</td>
	      </tr>
	      <tr>
 		<td>9999998</td>
		<td>Joni</td>
		<td>1993</td>
		<td>Tietojenkäsittelytiede</td>
	      </tr>
	      <tr>
		<td>...</td>
		<td></td>
		<td></td>
		<td></td>
	      </tr>
	    </tbody>
	  </table>
	</div>
	
	<p>Opiskelija-käsitteeseen liittyy useampi Kurssisuoritus, mikä näyttää käsitekaaviona seuraavalta -- allaolevassa käsitekaaviossa Opiskelijaan on lisätty opiskelijanumero:</p>
	
	<figure>
	  <img src="img/johdanto/opiskelija-opiskelijanumerolla-ja-kurssisuoritus.png" alt="Teksti 'Opiskelija' suunnikkaan sisään kirjoitettuna, Teksti 'Kurssisuoritus' toisen suunnikkaan sisään kirjoitettuna. Suunnikkaiden välille on piirretty viiva, jonka Kurssisuoritus-käsitteen päässä on tähti. Käsitteillä myös ominaisuudet. ">
	  <figcaption>Opiskelijaan liittyy yksi tai useampi kurssisuoritus.</figcaption>
	</figure>
	
	
	<p>Relaatiotietokannoissa käsitteiden yhdistäminen tapahtuu avainten avulla. Tietokantatauluun Opiskelija on määritelty jokaisen opiskelijan yksilöivä avain <em>opiskelijanumero</em>. Koska jokaiseen opiskelijaan voi liittyä useampi kurssisuoritus, mutta jokaiseen kurssisuoritukseen vain yksi opiskelija, voimme lisätä kurssisuoritustaulua luodessa siihen <em>viiteavaimen</em> (foreign key), joka viittaa opiskelijaan. Kurssisuoritus-tauluun lisätään siis sarake nimeltä opiskelija, joka sisältää aina kurssisuoritukseen liittyvän opiskelijan opiskelijanumeron. Viiteavain merkitään tekstillä <em>(fk)</em>, eli <em>foreign key</em>, ja viiteavaimen nimen jälkeen tulee Taulun nimi, johon viiteavain viittaa.</p>
	
	<figure>
	  <img src="img/johdanto/opiskelija-opiskelijanumerolla-ja-kurssisuoritus-taulut.png" alt="[Opiskelija|(pk) opiskelijanumero;nimi;syntymävuosi;pääaine]1-*[Kurssisuoritus|(fk) opiskelija: Opiskelija;kurssi;päivämäärä;arvosana]">
	  <figcaption>Opiskelijaan liittyy yksi tai useampi kurssisuoritus.</figcaption>
	</figure>
	
	
	<p>Tietokantataulussa Kurssisuoritus oleva data näyttää esimerkiksi seuraavalta:</p>
	
	<div class="data-table">
	  <h4>Kurssisuoritus</h4>
	  <table class="table">
	    <thead>
	      <tr>
		<th>opiskelija</th>
		<th>kurssi</th>
		<th>päivämäärä</th>
		<th>arvosana</th>
	      </tr>
	    </thead>
	    <tbody>
	      <tr>
		<td>9999999</td>
		<td>Ohjelmoinnin perusteet</td>
		<td>1.8.2014</td>
		<td>5</td>
	      </tr>
	      <tr>
		<td>9999999</td>
		<td>Ohjelmoinnin jatkokurssi</td>
		<td>1.8.2014</td>
		<td>5</td>
	      </tr>
	      <tr>
		<td>9999999</td>
		<td>Tietokantojen perusteet</td>
		<td>20.10.2014</td>
		<td>3</td>
	      </tr>
	      <tr>
		<td>...</td>
		<td></td>
		<td></td>
		<td></td>
	      </tr>
	      <tr>
 		<td>9999998</td>
		<td>Ohjelmoinnin perusteet</td>
		<td>1.8.2013</td>
		<td>4</td>
	      </tr>
	      <tr>
		<td>...</td>
		<td></td>
		<td></td>
		<td></td>
	      </tr>
	    </tbody>
	  </table>
	</div>
	
	<p>Ylläolevat taulut voidaan määritellä myös tekstimuodossa seuraavasti: </p>
	
	<ul>
	  <li>Opiskelija((pk) opiskelijanumero, nimi, syntymävuosi, pääaine)</li>
	  <li>Kurssisuoritus((fk) opiskelija -> Opiskelija, kurssi, päivämäärä, arvosana)</li>
	</ul>
	
	<p>Opiskelijan opiskelijanumeroon on lisätty määre (pk), sillä se on Opiskelija-taulun avain. Kurssisuoritustaulun merkintä <code>(fk) opiskelija -> Opiskelija</code> taas tarkoittaa, että opiskelija on viiteavain, joka viittaa Opiskelija-taulun avaimeen.</p>
	
	
	<p>Pohditaan seuraavaksi kyselyiden tekemistä näihin tauluihin.</p>
	
	
	<h2>SQL-kyselykieli</h2>
	
	<p>SQL on jo 80-luvulla standardoitu kyselykieli relaatiotietokantojen käsittelyyn. Sen avulla voidaan hakea tietoa tietokannasta, päivittää tietokannassa olevaa tietoa, sekä muokata ja luoda tietokannan rakennetta. Käytännössä kaikki relaatiotietokantoja tukevat tietokannanhallintajärjestelmät käyttävät myös SQL-kieltä. Vuosien mittaan standardista on kuitenkin julkaistu useita versioita, joista tätä kirjoittaessa viimeisin on vuodelta 2011. Eri tietokannanhallintajärjestelmät ja niiden eri versiot noudattelevatkin standardia vaihtelevissa määrin, eivätkä ole täysin yhteensopivia. On siis syytä huomioida että tietokannanhallintajärjestelmästä toiseen vaihdettaessa usein joudutaan tekemään SQL-kyselyihin muutoksia.</p>

	<p>Tässä kurssimateriaalissa keskitymme pääasiassa SQLiten SQL-murteeseen.</p>
	
	<p>Parhaiten kyselykieltä ymmärtää sitä harjoittelemalla. Sitä teemme tällä kurssilla paljon.</p>
	
	<aside class="info">
	  
	  <br/>
	  <h1>Ohjeita SQL-tehtävien tekemiseen</h1>
	  
	  <p>Kurssimateriaalissa on tästä kohdasta eteenpäin interaktiivisia SQL-tehtäviä, joiden avulla pääset harjoittelemaan SQL-kyselykielen käyttöä. Materiaali sisältää materiaalin edetessä täydentyvän opiskelijoiden kurssisuorituksia kuvaavan tietokannan, jota käytetään ellei toisin mainita. Lähes jokaisen esimerkkikyselyn voi suorittaa, jolloin kysely ajetaan tietokannassa ja kyselyn tulos näytetään ruudulla. Kyselyn suorittaminen tapahtuu <em>Suorita</em>-nappia painamalla.</p>
	  
	  <p>Useimpien suoritettavien esimerkkien jälkeen avautuu muutama tehtävä, jossa pääset harjoittelemaan esimerkkiä vastaavien kyselyjen tuottamista.</p>
	  
	</aside>
	
	<div ng-controller="weekOneSqlController">
	  
	  
	  <h4>SELECT * FROM <em>Taulu</em></h4>
	  
	  <p>Avainsanalla <code>SELECT</code> valitaan tietyt sarakkeet kyselyn kohteena olevasta taulusta. Sarakkeet määritellään <code>SELECT</code>-avainsanan jälkeen. Jos ohjelmoija haluaa valita kaikki taulussa olevat sarakkeet, käytetään sarakkeiden valinnassa tähteä (<code>*</code>). Sarakkeiden määrittelyä seuraa avainsana <code>FROM</code>, jonka jälkeen kerrotaan kyselyn kohteena oleva taulu.</p>
	  
	  <p>Alla voit kokeilla kyselyn tekemistä aiemmin määriteltyihin <code>Opiskelija</code> ja <code>Kurssisuoritus</code>-tauluihin.</p>
	  
	  
	  <query
	     db="db"
	     query="SELECT * FROM Opiskelija"
	     editable="false"
	     done="listAllStudentsDone">
	  </query>
	  
	  <div ng-show="listAllStudentsDone">
	    
	    <h4>Tehtävät</h4>
	    
	    <p>Tee nyt kysely, jolla saat listattua kaikki <code>Kurssisuoritus</code>-taulussa olevat rivit.</p>
	    
	    <togglable content="taulut" db="db">
              <table-info></table-info>
	    </togglable>
	    
	    <query db="db"
		   valid="SELECT * FROM Kurssisuoritus"></query>
	  </div>
	  
	  
	  
	  <h4>SELECT <em>sarake, toinen</em> FROM <em>Taulu</em></h4>
	  
	  <p>Avainsanan <code>SELECT</code> jälkeen voidaan määritellä valittavat sarakkeet. Tähteä käyttämällä valitaan kaikki sarakkeet, mutta ohjelmoija voi valita myös yksittäisiä sarakkeita. Jos tähteä ei käytetä, ja halutaan valita useampia sarakkeita, valittavat sarakkeet erotellaan pilkulla.</p>
	  
	  
	  <query
	     db="db"
	     query="SELECT nimi, syntymävuosi FROM Opiskelija"
	     editable="false"
	     done="listAllStudentsWithAttributesDone">
	  </query>
	  
	  <div ng-show="listAllStudentsWithAttributesDone">
	    
	    <h4>Tehtävät</h4>
	    
	    <p>Tee nyt kysely, jolla saat listattua <code>Kurssisuoritus</code>-taulussa olevien kurssien nimet.</p>
	    
	    <togglable content="taulut" db="db">
              <table-info></table-info>
	    </togglable>
	    
	    <query db="db"
		   valid="SELECT kurssi FROM Kurssisuoritus"></query>
	  </div>
	  
	  
	  <h4>SELECT <em>DISTINCT</em> <em>sarake</em> FROM <em>Taulu</em></h4>
	  
	  <p>Kun haimme edellisessä harjoitteluosiossa Kurssisuoritus-taulussa olevien kurssien nimiä, huomasimme, että muutamat kurssien nimet näkyivät useampaan otteeseen. Tämä johtuu siitä, että kysely valitsee taulun rivit, ja taulussa yksinkertaisesti oli useampia rivejä, joilla esiintyi samat kurssit.</p>
	  
	  <p>Avainsanalla <code>DISTINCT</code> voidaan valita vain uniikit vastausrivit. Avainsana <code>DISTINCT</code> tulee avainsanan <code>SELECT</code> jälkeen.</p>
	  
	  
	  <query
	     db="db"
	     query="SELECT DISTINCT pääaine FROM Opiskelija"
	     editable="false"
	     done="listDistinctMajorsDone">
	  </query>
	  
	  <div ng-show="listDistinctMajorsDone">
	    
	    <h4>Tehtävät</h4>
	    
	    <p>Tee nyt kysely, jolla saat listattua <code>Kurssisuoritus</code>-taulussa olevat <em>uniikit</em> kurssit.</p>
	    
	    <togglable content="taulut" db="db">
              <table-info></table-info>
	    </togglable>
	    
	    <query db="db"
		   valid="SELECT DISTINCT kurssi FROM Kurssisuoritus"></query>
	  </div>
	  
	  
	  
	  <h4>SELECT * FROM <em>Taulu</em> <em>WHERE</em>...</h4>
	  
	  <p>Emme tyypillisesti kuitenkaan halua valita kaikkea taulussa olevaa dataa, vaan vain tietyt hakuehdot täyttävän osajoukon. Avainsanan <code>WHERE</code> avulla kyselyille annetaan hakuehtoja. Hakuehtojen perusteella kyselyn tulokseen valitaan vain ne rivit, joissa hakuehdossa määritellyn sarakkeen arvot täyttävät hakuehdon. Hakuehto voi olla esimerkiksi muotoa <code>...WHERE nimi = 'Joni'</code>, jolloin valittaisiin vain ne rivit, joissa sarakkeen <code>nimi</code> arvo on <code>'Joni'</code>.</p>
	  
	  <query
	     db="db"
	     query="SELECT * FROM Opiskelija WHERE nimi = 'Joni'"
	     editable="false"
	     done="selectJoniDone">
	  </query>
	  
	  <div ng-show="selectJoniDone">
	    
	    <h4>Tehtävät</h4>
	    
	    <p>Tee nyt kysely, jolla saat listattua <code>Opiskelija</code>-taulusta kaikki ne opiskelijat, joiden nimi on 'Anna'.</p>
	    
	    <togglable content="taulut" db="db">
              <table-info></table-info>
	    </togglable>
	    
	    <query db="db"
		   valid="SELECT * FROM Opiskelija WHERE nimi = 'Anna'"
		   done="selectAnnaDone"></query>
	    
	    
	    <div ng-show="selectAnnaDone">
	      
	      <p>Tee nyt kysely, jolla saat listattua <code>Kurssisuoritus</code>-taulusta kaikki Pihla-nimisen opiskelijan suoritukset. Voit olettaa, että Opiskelija-taulun sisältö on täsmälleen se, kuin mikä se tähän asti on ollut. Vinkki: millä Pihlan tunnistaa kummassakin taulussa?</p>
	      
	      <togglable content="taulut" db="db">
		<table-info></table-info>
	      </togglable>
	      
	      <query db="db"
		     valid="SELECT * FROM Kurssisuoritus WHERE opiskelija = '999999'"></query>
	      
	    </div>
	  </div>
	  

	  <aside class="info">
	    <br/>
	    <h1>SQL-kyselyiden kirjainkoko</h1>
	    
	    <p>SQL on "case insensitive", eli sillä, että onko kysely kirjoitettu isolla vai pienellä ei ole kyselyn suorituksen kannalta merkitystä. Voimme kirjoittaa komennon <code>SELECT</code> yhtä hyvin muodossa <code>select</code> tai <code>Select</code> -- sama pätee myös taulujen nimille ja attribuuteille.</p>
	    
	    <p>Taulussa olevaa dataa tarkasteltaessa kirjainkoolla on yleensä kuitenkin merkitystä. Kun teemme esimerkiksi vertailuoperaatioita merkkijonoille, on merkkijonon kirjoitusasu tärkeä. Kysely <code>SELECT * FROM Opiskelija WHERE nimi = 'Joni'</code> palauttaa vain ne opiskelijat, joiden nimi-kentän arvo on <em>täsmälleen</em> 'Joni'. Jos rivillä olevan nimi-kentän arvo olisi vaikkapa 'joni', ei edellinen kysely valitsisi kyseistä riviä.</p>
	    
	    <p>Noudatamme tällä kurssilla seuraavaa käytäntöä:</p>
	    
	    <ol>
	      <li>Kaikki SQL-kielen komennot, kuten <code>SELECT</code>, <code>FROM</code> ja <code>WHERE</code>, kirjoitetaan isolla.</li>
	      <li>Taulujen nimet kirjoitetaan isolla alkukirjaimella. Esimerkiksi <code>Opiskelija</code> ja <code>Kurssisuoritus</code>.</li>
	      <li>Taulujen sarakkeet eli attribuutit kirjoitetaan pienellä. Esimerkiksi <code>nimi</code> ja <code>kurssikoodi</code>.</li>
	    </ol>

	    <p>Jos haluat tehdä kyselyitä joissa kirjainten koolla ei ole merkitystä, voit yrittää käyttää LOWER() tai UPPER() -funktioita muuttamaan kaikki kirjaimet saman kokoiseksi. Huomioi kuitenkin että käyttämämme SQLite ei oletuksena tue näitä funktioita ei-ascii -merkistöille.</p>

	  </aside>
	  
	  
	  <p>Kyselyissä toimivat myös suurempi kuin <code>&gt;</code> ja pienempi kuin <code>&lt;</code> -operaatiot.</p>
	  
	  <p>Jos sarakkeen arvot ovat merkkijonoja, kuten kurssin nimi ja opiskelijan nimi, voi hakuehdossa käyttää myös <code>LIKE</code>-operaatiota. Tämän avulla hakutuloksia voi rajata osittaisen merkkijonon avulla. Esimerkiksi kysely <code>SELECT * FROM Opiskelija WHERE nimi LIKE '%a%'</code> hakee kaikki opiskelijat, joiden nimessä esiintyy a-kirjain.</p>
	  
	  
	  <query
	     db="db"
	     query="SELECT * FROM Opiskelija WHERE nimi LIKE '%a%'"
	     editable="false"
	     done="listOpiskelijatWithSmallAInName">
	  </query>
	  
	  <div ng-show="listOpiskelijatWithSmallAInName">
	    
	    <h4>Tehtävät</h4>
	    
	    <p>Tee nyt kysely, jolla saat listattua kaikki Opiskelija-taulussa olevat pääaineet, joissa esiintyy sana "tiede". </p>
	    
	    <p>Huom! Tee kysely siten, että näet vain uniikit vastaukset. Kyselyn vastauksessa pitäisi olla vain 2 riviä. Kun saat kyselyn toimimaan, kokeile mitä tapahtuu jos muutat 'LIKE'-operaation muotoon 'NOT LIKE'.</p>
	    
	    <togglable content="taulut" db="db">
              <table-info></table-info>
	    </togglable>
	    
	    <query db="db"></query>
	  </div>
	  
	</div>
	
	
	<aside class="info">
	  <br/>
	  
	  <h1>Loogiset operaatiot 'ja' ja 'tai'</h1>
	  
	  <p>Rajausehtoihin voi myös lisätä loogisia operaatioita kyselyjen tulosten tajaamiseksi. Operaatio 'ja', eli kahden rajausehdon yhdistäminen, toimii avainsanalla <code>AND</code>. Esimerkiksi kysely <code>SELECT * FROM Kurssisuoritus WHERE kurssi = 'Ohjelmoinnin perusteet' AND arvosana = 5</code> listaisi vain ne Ohjelmoinnnin perusteet -kurssin suoritukset, missä arvosana on 5.</p>
	  
	  <p>Operaation 'tai' lisääminen on myös mahdollista. Esimerkiksi kysely <code>SELECT * FROM Kurssisuoritus WHERE kurssi = 'Ohjelmoinnin perusteet' OR kurssi = 'Ohjelmoinnin jatkokurssi'</code> listaisi kaikki ne kurssisuoritukset, joissa kurssi on joko ohjelmoinnin perusteet tai ohjelmoinnin jatkokurssi.</p>
	  
	  <p>Ehtoja voi myös yhdistää, jonka lisäksi suluilla voi rajata suoritusjärjestystä. Ota selvää mitä kysely <code>SELECT * FROM Kurssisuoritus WHERE (kurssi = 'Ohjelmoinnin perusteet' OR kurssi = 'Ohjelmoinnin jatkokurssi') AND arvosana = 3</code> tekee.</p>
	  
	</aside>
	
	
	<h2>Erilaiset yhteystyypit</h2>
	
	<p>Huomaamme, että käsite Kurssisuoritus oikeastaan liittyy kahteen eri asiaan; kurssiin ja kurssin suoritukseen. Eriytetään nämä kaksi käsitettä toisistaan.</p>
	
	<p>Kurssiin liittyy kurssin yleiset tiedot kuten kurssin nimi, kurssikoodi, sekä kurssin kuvaus. Kurssisuoritus taas liittyy tiettyyn kurssiin, opiskelijaan, päivämäärään, arvosanaan, sekä opintopistemäärään. Opintopistemäärä pidetään osana kurssisuoritusta, sillä joillain kursseilla opintopistemäärä vaihtelee työmäärästä riippuen. Käsite Opiskelija säilyy sellaisenaan.</p>

	<p>Yhteen kurssisuoritukseen liittyy aina yksi kurssi, mutta yhteen kurssiin voi liittyä monta kurssisuoritusta. Käsitekaaviona tämä näyttää seuraavalta:</p>

	<figure>
	  <img src="img/johdanto/opiskelija-kurssisuoritus-kurssi.png" alt="Opiskelija 1-* Kurssisuoritus *-1 Kurssi"/>
	  <figcaption>Jokaisella opiskelijalla voi olla useita kurssisuorituksia, ja jokaiseen kurssisuoritukseen liittyy tasan yksi opiskelija. Jokaiseen kurssisuoritukseen liittyy myös tasan yksi kurssi, ja jokaisella kurssilla voi olla useita kurssisuorituksia.</figcaption>
	</figure>

	<p>Tutkitaan ensin ylläolevan kaavion osaa, missä kurssisuoritukseen liittyy yksi kurssi ja yhteen Kurssiin monta kurssisuoritusta. Emme hetkeen välitä Opiskelija-käsitteen olemassaolosta. Sekä kurssisuoritukselle että kurssille on määritelty niihin liittyvät attribuutit.</p>
	
	
	<figure>
	  <img src="img/johdanto/kurssisuoritus-kurssi-attrs.png" alt="[Kurssisuoritus|päivämäärä;arvosana;opintopistemäärä]*-1[Kurssi|nimi;kuvaus]"/>
	  <figcaption>Jokaiseen kurssisuoritukseen liittyy yksi kurssi, mutta kurssilla voi olla useampia kurssisuorituksia.</figcaption>
	</figure>
	


	
	<aside class="info">
	  <br/>
	  <h1>Yhteystyyppi yhden suhde moneen</h1>
	  
	  <p>Kahden käsitteen välillä on yhden suhde moneen (<code>1-N</code>) -yhteys, jos ensimmäisen käsitteen ilmentymään voi liittyä monta toisen käsitteen ilmentymää, mutta yhteen toisen käsitteen ilmentymään voi liittyä vain yksi ensimmäisen käsitteen ilmentymä.</p>
	  
	  <p>Esimerkiksi <em>Olli Opiskelijaan</em> voi liittyä monta erilaista kurssisuoritusta, mutta tiettyyn kurssisuoritukseen voi liittyä aina vain yksi opiskelija, joka jossain tapauksessa <em>voi</em> olla Olli Opiskelija.</p>
	  
	  <p>Saman yhteystyypin voi ajatella myös tietokantataulujen välillä. Kahden taulun välillä on yhteys yhden suhde moneen, jos yhteen ensimmäisen taulun riviin voi liittyä useita toisen taulun rivejä, mutta yhteen toisen taulun riviin voi liittyä vain yksi ensimmäisen taulun rivi.</p>
	  
	  <p><em>Tietokantataulujen luominen</em></p>
	  
	  <figure>
	    <img src="img/viikko2/yhdesta-moneen-kasitteet.png" alt="[A]1-*[B]"/>
	    <figcaption>Yhden suhde moneen. Yhteen A-käsitteeseen voi liittyä monta B-käsitettä, mutta yhteen B-käsitteeseen liittyy aina tasan yksi A-käsite.</figcaption>
	  </figure>
	  

	  <p>Kun kahden käsitteen välillä on yhden suhde moneen -yhteys, luodaan niiden perusteella tietokantataulut seuraavasti. Luodaan ensin käsitteestä, jonka "viivan päässä" on numero 1, tietokantataulu, ja määritellään sille käsitteen ilmentymät yksilöivä pääavain. Jos käsitteeseen liittyy muita ominaisuuksia tai attribuutteja, asetetaan ne tietokantataulun sarakkeiksi.</p>
	  
	  <figure>
	    <img src="img/viikko2/kasite-a-paaavain.png" alt="[A|(pk) id]"/>
	    <figcaption>Käsitteen A perusteella luotu tietokantataulu, jolle on määritelty pääavain <em>id</em>. </figcaption>
	  </figure>
	  
	  <p>Tämän jälkeen luodaan käsitteestä, jonka "viivan päässä" on tähti, tietokantataulu, ja määritellään sille <em>viiteavain</em>, jonka avulla voimme viitata aiemmin luotuun tauluun.</p>
	  
	  <figure>
	    <img src="img/viikko2/kasite-b-viiteavain.png" alt="[B|(fk) a_id: A]"/>
	    <figcaption>Käsitteen B perusteella luotu tietokantataulu, jolle on määritelty viiteavain <em>a_id</em>, joka viittaa tauluun A. </figcaption>
	  </figure>
	  
	  
	  <p>Tämän jälkeen piirretään viiva tietokantataulujen välille.</p>
	  
	  
	  <figure>
	    <img src="img/viikko2/taulut-a-b.png" alt="[A|(pk) id]1-*[B|(fk) a_id: A]"/>
	    <figcaption>Tietokantataulussa A on pääavain <em>id</em>. Tietokantataulussa B on viiteavain <code>a_id</code>, joka viittaa tietokantatauluun A.</figcaption>
	  </figure>
	  
	  <p>Yllä kuvattiin, miten yhden suhde moneen -yhteystyypin tapauksessa luodaan käsitekaaviosta tietokantataulut.</p>
	  
	</aside>
	
	
	<p>Luodaan seuraavaksi Kurssisuorituksesta ja Kurssista tietokantataulut.</p>
	
	
	<figure>
	  <img src="img/johdanto/kurssisuoritus-kurssi-attrs.png" alt="[Kurssisuoritus|päivämäärä;arvosana;opintopistemäärä]*-1[Kurssi|nimi;kuvaus]"/>
	  <figcaption>Jokaiseen kurssisuoritukseen liittyy yksi kurssi, mutta kurssilla voi olla useampia kurssisuorituksia.</figcaption>
	</figure>
	
	
	<p>Ensimmäinen askel on tietokantataulun Kurssi luominen sekä sen pääavaimen määrittely. Kurssin nimi ei ole hyvä avain, sillä esimerkiksi kurssin nimi "Tietokone työvälineenä" toistuu eri tiedekunnissa ja laitoksissa useiden erilaisten kurssien nimenä. Toisaalta, avaimen on hyvä olla sellainen, että se ei muutu -- (jos avain muuttuisi, kaikki viiteavaimet tulisi myös päivittää) -- kuvauskaan ei ole hyvä avain. Luodaan avainta varten uusi attribuutti, <em>kurssitunnus</em>, ja lisätään se tauluun muiden kurssikäsitteeseen liittyvien attribuuttien kanssa.</p>
	
	
	<figure>
	  <img src="img/viikko2/kurssi-paaavaimella.png" alt="[Kurssi|(pk) kurssitunnus;nimi;kuvaus]"/>
	</figure>
	
	<p>Luodaan tämän jälkeen taulu Kurssisuoritus. Koska jokaiseen kurssisuoritukseen liittyy yksi kurssi, luodaan tauluun viiteavain <em>kurssi</em>, joka viittaa Kurssi-tauluun. Muut attribuutit lisätään tauluun viiteavaimen lisäksi.</p>
	
	
	<figure>
	  <img src="img/viikko2/kurssisuoritus-viiteavaimella.png" alt="[Kurssi|(pk) kurssitunnus;nimi;kuvaus]"/>
	</figure>
	
	<p>Yhdistetään tietokantataulut vielä viivalla.</p>
	
	
	<figure>
	  <img src="img/viikko2/kurssisuoritus-ja-kurssi-tietokantataulut.png" alt="[Kurssisuoritus|(fk) kurssi: Kurssi;päivämäärä;arvosana;opintopistemäärä]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]"/>
	</figure>
	
	<p>&nbsp;</p>
	
	<p><em><strong>Kolmannen tietokantakaulun lisääminen tietokantakaavioon</strong></em></p>
	
	<p>Tarkastellaan seuraavaa käsitekaaviota, ja tehdään siitä seuraavaksi tietokantakaavio.</p>
	
	<figure>
	  <img src="img/viikko2/opiskelija-kurssisuoritus-kurssi-luokkakaavio.png" alt="[Opiskelija|opiskelijanumero;nimi;syntymävuosi;pääaine] 1-* [Kurssisuoritus|päivämäärä;arvosana;opintopistemäärä]
[Kurssisuoritus] *-1 [Kurssi|nimi;kuvaus]"/>
	</figure>
	
	<p>Teimme edellä jo käsitteistä Kurssi ja Kurssisuoritus tietokantakaavion, joten voimme keskittyä nyt käsitteiden Opiskelija ja Kurssisuoritus väliseen suhteeseen.</p>
	
	
	<p>Aloitamme taas käsitteestä, jonka viivan päässä on 1, eli tässä tapauksessa opiskelijasta. Kuten aiemmin, käytämme tietokantataululle Opiskelija avaimena opiskelijanumeroa, sillä se yksilöi jokaisen opiskelijan.</p>
	
	<figure>
	  <img src="img/johdanto/opiskelija-ja-opiskelijanumero.png" alt="[Opiskelija|(pk) opiskelijanumero;nimi;syntymävuosi;pääaine]">
	</figure>
	
	<p>Keskitytään tämän jälkeen viivan toiseen päähän, eli tässä tapauksessa käsitteeseen Kurssisuoritus. Koska yhteen kurssisuoritukseen liittyy tasan yksi opiskelija, lisätään tauluun Kurssisuoritus viiteavain <em>opiskelija</em>, joka viittaa opiskelijaan. Muuten taulu pysyy samana kuten aiemminkin.</p>
	
	<p>Voimme nyt yhdistää kaikki taulut yhteen, jolloin tietokantakaavio on seuraavanlainen:</p>
	
	<figure>
	  <img src="img/viikko2/opiskelija-kurssisuoritus-kurssi-tietokantakaavio.png" alt="[Opiskelija|(pk) opiskelijanumero;nimi;syntymävuosi;pääaine]1-*[Kurssisuoritus|(fk) opiskelija: Opiskelija;(fk) kurssi: Kurssi;päivämäärä;arvosana;opintopistemäärä]
[Kurssisuoritus]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]"/>
	</figure>

	
	
	<aside class="info">
	  <br/>
	  <h1>Yhdistelyharjoittelua SQL:llä</h1>
	  
	  <p>Käytössämme on nyt edellä luodut tietokantataulut sekä muutamia muita tauluja, mitä luomme kohta. Harjoitellaan tässä välissä hieman kyselyiden tekemistä edellä luotuihin kolmeen tauluun.</p>
	  
	  <p>Useamman taulun yhdistäminen tapahtuu <code>WHERE</code>-ehdon avulla esimerkiksi seuraavasti: <code>SELECT * FROM Opiskelija, Kurssisuoritus WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija</code>, eli "Anna kaikki riviyhdistelmät tauluista Opiskelija ja Kurssisuoritus, joissa attribuuttien opiskelijanumero ja opiskelija arvot ovat samat".</p>
	  
	  <p>Edellä ehto <code>WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija</code> luo ehdon, missä kyselyn tulokseen valitaan mukaan vain ne rivit, missä Opiskelija-taulun opiskelijanumero on sama kuin Kurssisuoritus-taulun opiskelija. Käytännössä tämä kysely kytkee Opiskelija-taulun pääavaimen ja Kurssisuoritustaulun Opiskelija-tauluun viittaavan viiteavaimen.</p>
	  
	  <div ng-controller="weekTwoSqlController">
	    <query
	       db="db"
	       query="SELECT * FROM Opiskelija, Kurssisuoritus WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija"
	       editable="false"
	       done="listOpiskelijatAndKurssisuoritukset">
	    </query>
	    
	    <div ng-show="listOpiskelijatAndKurssisuoritukset">
	      
	      <h4>Tehtävät</h4>
	      
	      <p>Tee nyt kysely, jolla saat listattua kaikki Kurssit ja niihin liittyvät kurssisuoritukset. Valitse näytettäviksi sarakkeiksi vain kurssin <code>nimi</code> ja kurssisuorituksen <code>päivämäärä</code> ja <code>arvosana</code>.</p>
	      
	      <p>Kyselyn tuloksessa pitäisi olla 4 riviä ja 3 saraketta.</p>
	      
	      <togglable content="taulut" db="db">
		<table-info></table-info>
	      </togglable>
	      
	      <query db="db"></query>
	    </div>
	  </div>
	  
	</aside>
	
	
	
	
	<p><strong><em>Yhteystyypit jatkuu: kursseihin liittyy tehtäviä</em></strong></p>
	
	
	<p>Haluamme, että järjestelmämme voi pitää kirjaa myös kursseihin liittyvistä tehtävistä, joita opiskelija voi suorittaa. Koska kurssiin liittyvien tehtävien määrä voi vaihdella, määritellään yhteys siten, että yhteen kurssiin voi liittyä useita tehtäviä. Toisaalta, koska sama tehtävä voi esiintyä useammalla kurssilla, määritellään yhteys siten, että yhteen tehtävään liittyä useampi kurssi.</p>
	
	
	<figure>
	  <img src="img/johdanto/tehtava-kurssi.png" alt="[Tehtävä] *-* [Kurssi]"/>
	  <figcaption>Tehtävä voi liittyä useampaan kurssiin, ja kurssi voi liittyä useampaan tehtävään.</figcaption>
	</figure>
	
	<p>Yllä kuvattu yhteystyyppi on <em>monen suhde moneen</em>.</p>
	
	
	<aside class="info">
	  <br/>
	  <h1>Yhteystyyppi monen suhden moneen</h1>
	  
	  <p>Kahden käsitteen välillä on monen suhde moneen (<code>N-N</code>) -yhteys, jos ensimmäisen käsitteen ilmentymään voi liittyä monta toisen käsitteen ilmentymää, ja toisen käsitteen ilmentymään voi liittyä monta ensimmäisen käsitteen ilmentymä.</p>
	  
	  <p>Esimerkiksi yhteen kurssiin voi liittyä monta tehtävää, ja yksi tehtävä voi liittyä useampaan kurssiin.</p>
	  
	  <p>Saman yhteystyypin voi ajatella myös tietokantataulujen välillä. Kahden taulun välillä on yhteys monen suhde moneen, jos yhteen ensimmäisen taulun riviin voi liittyä useita toisen taulun rivejä, ja yhteen toisen taulun riviin voi liittyä useita ensimmäisen taulun rivejä.</p>
	  
	  
	  <p><em>Tietokantataulujen luominen</em></p>
	  
	  <figure>
	    <img src="img/viikko2/monesta-moneen-a-b.png" alt="[A]*-*[B]"/>
	    <figcaption>Monen suhde moneen. Yhteen A-käsitteeseen voi liittyä monta B-käsitettä, ja yhteen B-käsitteeseen voi liittyä monta A-käsitettä.</figcaption>
	  </figure>
	  
	  
	  <p>Jos käsitteiden välillä on monen suhde moneen -yhteys, luodaan niistä tietokantataulut seuraavasti. Määritellään ensin kummallekin käsitteelle <em>pääavain</em>.
	    
	    <figure>
	      <img src="img/viikko2/monesta-moneen-a-b-paaavaimilla.png" alt="[A|(pk) id]
									      [B|(pk) id]"/>
	      <figcaption>Tietokantataulut A ja B. Kummallekin tietokantataululle on määritelty oma taulussa olevan tiedon yksilöivä avain.</figcaption>
	    </figure>
	    
	  <p>Kun tietokantatauluille on määritelty pääavaimet, luodaan uusi tietokantataulu, jonka jokainen rivi yhdistää yhden rivin taulusta A yhden taulun B rivin kanssa. Tällaista taulua kutsutaan nimellä <em>liitostaulu</em>, ja se sisältää kaksi viiteavainta: yhden kumpaankin viitattavaan tauluun.</p>
	  
	  <figure>
	    <img src="img/viikko2/monesta-moneen-liitostaulu.png" alt="[Liitostaulu|(fk) a_id: A;(fk) b_id: B]"/>
	    <figcaption>Liitostaulu sisältää kaksi viiteavainta. Yhden, joka viittaa tauluun A, ja toisen, joka viittaa tauluun B.</figcaption>
	  </figure>
	  
	  <p>Yhdistetään seuraavaksi taulut liitostaululla. Liitostaulun jokainen rivi voi viitata vain yhteen taulun A riviin ja yhteen taulun B riviin, joten liitostaulusta lähtevässä yhteydessä taulujen A ja B päätyihin tulee numerot yksi. Toisaalta, liitostaulussa voi olla monta riviä, missä esiintyy viite tiettyyn taulun A riviin -- samoin myös taulun B riviin, joten liitostaulun päähän tulee tähti.</p>
	  
	  
	  
	  <figure>
	    <img src="img/viikko2/monesta-moneen-liitostaulu-yhteydet.png" alt="[A|(pk) id]1-*[Liitostaulu|(fk) a_id: A;(fk) b_id: B]
										[Liitostaulu]*-1[B|(pk) id]"/>
	    <figcaption>Liitostaulun avulla monesta moneen suhde saadaan muutettua kahdeksi yhdestä moneen suhteeksi.</figcaption>
	  </figure>
	  
	</aside>
	
	<p>Tarkastellaan uudestaan käsitteiden tehtävä ja kurssi yhteyttä, ja muunnetaan käsitekaavio tietokantakaavioksi.</p>
	
	<figure>
	  <img src="img/johdanto/tehtava-kurssi.png" alt="[Tehtävä] *-* [Kurssi]"/>
	</figure>
	
	
	<p>Ensimmäinen askel on taulujen luominen sekä niihin liittyvien avainten määrittely. Olemme aiemmin luoneet taulun käsitteestä kurssi, sekä määritelleet sille pääavaimen, joten keskitymme vain taulun Tehtävä luomiseen.</p>
	
	<p>Määritellään, että tehtävään liittyy <em>nimi</em> ja <em>kuvaus</em>. Kumpikaan niistä ei sovellu tehtävän avaimeksi, joten luodaan tehtävälle avain <em>tunnus</em>, joka yksilöi jokaisen tehtävän. Käsitteestä Tehtävä luotu tietokantataulu on seuraavanlainen:</p>
	
	<figure>
	  <img src="img/viikko2/tehtava-tietokantataulu.png" alt="[Tehtävä|(pk) tunnus;nimi;kuvaus]"/>
	  <figcaption>Tehtävä-taulussa on pääavaimena tunnus, jonka lisäksi sillä on attribuutit nimi ja kuvaus.</figcaption>
	</figure>
	
	
	<p>Luodaan seuraavaksi liitostaulu, jonka tehtävänä on yhdistää taulut Tehtävä ja Kurssi. Kutsutaan liitostaulua nimellä Kurssitehtävä. Kurssitehtävä-taululla on kaksi viiteavainta, joista toinen osoittaa tauluun Tehtävä, ja toinen tauluun Kurssi.</p>
	
	<figure>
	  <img src="img/viikko2/kurssitehtava-liitostaulu.png" alt="[Kurssitehtävä|(fk) tehtävä: Tehtävä; (fk) kurssi: Kurssi]"/>
	  <figcaption>Kurssitehtävä-liitostaulussa on kaksi viiteavainta, jotka osoittavat tauluihin Tehtävä ja Kurssi.</figcaption>
	</figure>
	
	<p>Lisätään seuraavaksi yhteydet käsitteiden välille -- tämä tapahtuu lähinnä visualisoinnin takia, viitteet ovat todellisuudessa olemassa jo viiteavainten muodossa. Yhteen Kurssitehtävä-taulun riviin liittyy tasan yksi Kurssi-taulun rivi ja Tehtävä-taulun rivi, mutta yksi Kurssi-taulun rivi voi liittyä moneen Kurssitehtävä-taulun riviin -- samoin kuin yksi Tehtävä-taulun rivi voi liittyä moneen Kurssitehtävä-taulun riviin.</p>
	
	<p>Tietokantakaavio on lopulta seuraavanlainen:</p>
	
	<figure>
	  <img src="img/viikko2/monesta-moneen-tehtava-kurssitehtava-kurssi.png" alt="[Tehtävä|(pk) tunnus;nimi;kuvaus]1-*[Kurssitehtävä|(fk) tehtävä: Tehtävä; (fk) kurssi: Kurssi]
										      [Kurssitehtävä]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]"/>
	  <figcaption>Nyt jos tehtävä on tietyllä kurssilla, on taulussa kurssitehtävä rivi, missä on tehtävän ja kurssin yksilöivä tunnus.</figcaption>
	</figure>
	
	
	<aside class="info">
	  <br/>
	  <h1>Yhteystyyppi yhden suhde yhteen</h1>
	  
	  <p>Yhteystyyppien yhden suhde moneen ja monen suhde moneen lisäksi on myös yhteystyyppi yhden suhde yhteen. Kahden käsitteen välillä on yhden suhde yhteen (<code>1-1</code>) -yhteys, jos ensimmäisen käsitteen ilmentymään voi liittyä vain yksi toisen käsitteen ilmentymä, ja toisen käsitteen ilmentymään voi liittyä vain yksi ensimmäisen käsitteen ilmentymä.</p>
	  
	  <p>Esimerkiksi yhdellä opiskelijalla voi olla vain yksi laite lainassa ylläpidolta, ja ylläpito voi lainata tietyn laitteen vain yhdelle opiskelijalle.</p>
	  
	  <p>Tämänkin yhteystyypin voi ajatella myös tietokantataulujen välillä. Kahden taulun välillä on yhteys yhden suhde yhteen, jos yhteen ensimmäisen taulun riviin voi liittyä vain yksi toisen taulun rivi, ja yhteen toisen taulun riviin voi liittyä vain yksi ensimmäisen taulun rivi.</p>
	  
	  <p><em>Tietokantataulujen luominen</em></p>
	  
	  <figure>
	    <img src="img/viikko2/yhden-suhde-yhteen-a-b.png" alt="[A]1-1[B]"/>
	    <figcaption>Yhden suhde yhteen. Yhteen A-käsitteeseen voi liittyä vain yksi B-käsite, ja yhteen B-käsitteeseen voi liittyä vain yksi A-käsite.</figcaption>
	  </figure>
	  
	  
	  <p>Jos käsitteiden välillä on yhden suhde yhteen -yhteys, tyypillisin tapa tietokantataulujen luomiseen on se, että yhdelle käsitteistä määritellään pääavain, ja toiselle viiteavain, jolla viitataan toiseen käsitteeseen.</p>
	  
	  
	  
	  <figure>
	    <img src="img/viikko2/yhden-suhde-yhteen-viitteet.png" alt="[A|(pk) id]1-*[B|(fk) a_id: A]"/>
	    <figcaption>Yhden suhde yhteen tietokantakaaviona. Käsitteestä B viitataan käsitteeseen A. </figcaption>
	  </figure>
	  
	  <p>Kun pohdimme ylläolevaa tarkemmin, huomaamme, että yllä suoritettiin käytännössä samat askeleet kuin yhden suhde moneen -tapauksessa. Tämä on täysin totta -- käytännössä tietokantaan tulee määritellä viittaavan taulun määrittelyn yhteydessä lisäksi <em>uniikkiusrajoite</em> viiteavaimelle. Palaamme erilaisiin rajoitteisiin myöhemmin kurssilla.</p>
	  
	</aside>
	
	
	<h2>Useammassa taulussa olevan tiedon yhdistäminen</h2>
	
	
	<p>Hahmottelimme edellisessä luvussa opiskelun ja oppimisen seuraamiseen tarkoitetun järjestelmämme tietokantaa. Päädyimme yhteystyyppien käsittelyssä kahteen tietokantakaavioon, jotka ovat seuraavat:</p>
	
	
	<figure>
	  <img src="img/viikko2/opiskelija-kurssisuoritus-kurssi-tietokantakaavio.png" alt="[Opiskelija|(pk) opiskelijanumero;nimi;syntymävuosi;pääaine]1-*[Kurssisuoritus|(fk) opiskelija: Opiskelija;(fk) kurssi: Kurssi;päivämäärä;arvosana;opintopistemäärä]
											    [Kurssisuoritus]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]"/>
	</figure>

	
	<figure>
	  <img src="img/viikko2/monesta-moneen-tehtava-kurssitehtava-kurssi.png" alt="[Tehtävä|(pk) tunnus;nimi;kuvaus]1-*[Kurssitehtävä|(fk) tehtävä: Tehtävä; (fk) kurssi: Kurssi]
										      [Kurssitehtävä]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]"/>
	</figure>
	
	
	<p>Voimme yhdistää tietokantakaaviot suoraan, sillä kumpikin kaavio sisältää taulun Kurssi. Tietokantakaavio, missä kaikki taulut ovat yhdessä, näyttää seuraavalta:</p>
	

	<figure>
	  <img src="img/viikko2/tietokantakaavio.png" alt="[Opiskelija|(pk) opiskelijanumero;nimi;syntymävuosi;pääaine]1-*[Kurssisuoritus|(fk) opiskelija: Opiskelija;(fk) kurssi: Kurssi;päivämäärä;arvosana;opintopistemäärä]
							   [Kurssisuoritus]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]
							   [Tehtävä|(pk) tunnus;nimi;kuvaus]1-*[Kurssitehtävä|(fk) tehtävä: Tehtävä; (fk) kurssi: Kurssi]
							   [Kurssitehtävä]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]"/>
	  
	</figure>
	
	<p>Voit tutkia uudessa esimerkkitietokannassa olevaa tietoa allaolevan SQL-komentotulkin avulla.</p>
	
	
	<div ng-controller="weekTwoSqlController">
	  
	  <togglable content="taulut" db="db">
            <table-info></table-info>
	  </togglable>
	  
	  <query db="db"></query>
	</div>
	
	
	
	<p>Tutustuimme aiemmin SQL-kyselyihin, joiden avulla teimme erilaisia kyselyitä yksittäisiin tietokantatauluihin. Tutustutaan seuraavaksi erääseen tapaan useammassa taulussa olevan tiedon yhdistämiseen.</p>
	
	<p>Aiempaa materiaalia kertaamalla muistamme, että avainsanaa <code>FROM</code> seuraa taulu, josta tietoa haetaan. Voimme määritellä haun kohteeksi useampia tauluja listaamalla ne FROM-avainsanan jälkeen pilkulla eroteltuna seuraavasti <code>SELECT * FROM Opiskelija, Kurssisuoritus</code>. Jos emme kerro miten taulujen rivit yhdistetään, on lopputuloksessa kaikki rivit yhdistettynä kaikkiin riveihin -- esimerkiksi jokainen taulun Opiskelija rivi yhdistettynä jokaiseen taulun Kurssisuoritus riviin.</p>
	
	
	<div ng-controller="weekTwoSqlController">
	  <query
	     db="db"
	     query="SELECT * FROM Opiskelija, Kurssisuoritus"
	     editable="false">
	  </query>
	</div>
	
	<p>Yllä esitetyn kyselyn tuottama lopputulos ei ole tyypillisesti tavoiteltu -- jokaiseen opiskelijaan on kytketty jokainen kurssisuoritus, eli kaikilla on kaikki kurssisuoritukset.</p>
	
	<p>Taulujen yhdistäminen tapahtuu kyselyä rajaavan <code>WHERE</code>-ehdon avulla siten, että taulun pääavainta verrataan siihen viittaavan taulun viiteavaimeen. Esimerkiksi, jos haluamme vain kurssisuoritukset ja niihin liittyvät opiskelijat, hyödynnämme Opiskelija-taulun avainta opiskelijanumero sekä Kurssisuoritus-taulun viiteavainta opiskelija, joka viittaa Opiskelija-taulun pääavaimeen. Käytännössä tämä tapahtuu ehdolla <code>WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija</code>.</p>
	
	<p>Kokonaisuudessaan lause "Anna kaikki riviyhdistelmät tauluista Opiskelija ja Kurssisuoritus, joissa attribuuttien opiskelijanumero ja opiskelija arvot ovat samat" kirjoitetaan seuraavasti: <code>SELECT * FROM Opiskelija, Kurssisuoritus WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija</code>.</p>
	
	<div ng-controller="weekTwoSqlController">
	  
	  <query
	     db="db"
	     query="SELECT * FROM Opiskelija, Kurssisuoritus WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija"
	     editable="false"
	     done="listOpiskelijatJaKurssisuoritukset">
	  </query>
	  
	  <div ng-show="listOpiskelijatJaKurssisuoritukset">
	    
	    <h4>Tehtävät</h4>
	    
	    <p>Tee nyt kysely, joka tulostaa jokaisen opiskelijan nimen, kurssisuorituksen päivämäärän, ja kurssisuorituksen arvosanan.</p>
	    
	    
	    <togglable content="taulut" db="db">
              <table-info></table-info>
	    </togglable>
	    
	    <query db="db"></query>
	  </div>
	</div>
	
	
	<p><strong><em>Useamman taulun yhdistäminen</em></strong></p>
	
	<p>Useamman taulun yhdistäminen onnistuu samalla tavalla. Kaikki taulut, jotka haluamme lisätä kyselyyn, tulevat FROM-avainsanan jälkeen. Jos tauluja on useampi, on hyvä varmistaa, että kaikki taulut yhdistetään avainkenttien perusteella, sillä muuten haun vastaus voi olla iso.</p>
	
	<p>Kun yhdistämme useampia tauluja, päädymme helposti tilanteeseen, missä tuloksessa on myös useampia samannimisiä kenttiä. Esimerkiksi omassa tietokantamäärittelyssämme kenttä nimi löytyy tauluista Tehtävä, Kurssi ja Opiskelija. Voimme määritellä taulun, mihin haettava kenttä liittyy, pisteoperaattorin avulla. Kyselyn <code>SELECT nimi FROM Opiskelija</code> voi siis kirjoittaa myös muodossa <code>SELECT Opiskelija.nimi FROM Opiskelija</code>.</p>
	
	<p>Voimme toisaalta myös nimetä kentän tulostusmuodon seuraavasti <code>SELECT Opiskelija.nimi AS opiskelija FROM Opiskelija</code>. Edelläoleva kysely hakee Opiskelija-taulusta opiskelijan nimen, mutta tulostaa nimet otsikolla 'opiskelija'. </p>
	
	<p>Allaoleva kysely listaa jokaiselta opiskelijalta opiskelijan nimen sekä opiskelijan suorittamat kurssit.</p>
	
	<div ng-controller="weekTwoSqlController">
	  
	  <query
	     db="db"
	     query="SELECT Opiskelija.nimi AS opiskelija, Kurssi.nimi AS kurssi
		    FROM Opiskelija, Kurssisuoritus, Kurssi
		    WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija
		    AND Kurssisuoritus.kurssi = Kurssi.kurssitunnus"
	     editable="false"
	     done="listOpiskelijanSuorittamatKurssit">
	  </query>
	  
	  <div ng-show="listOpiskelijanSuorittamatKurssit">
	    
	    <h4>Tehtävät</h4>
	    
	    <p>Tee nyt kysely, joka tulostaa jokaiseen kurssiin liittyvän tehtävän. Tulostuksen otsikoiden nimien tulee olla 'kurssi' ja 'tehtävä'.</p>
	    
	    
	    <togglable content="taulut" db="db">
              <table-info></table-info>
	    </togglable>
	    
	    <query db="db"></query>
	  </div>
	</div>
	
	
	<aside class="info">
	  
	  <br/>
	  <h1>Taulujen yhdistämisestä</h1>
	  
	  <p>Yksi tapa taulujen yhdistämiseen tarvittujen kyselyjen hahmottamiseen on tietokantakaavion katsominen. Jos tavoitteena olisi esimerkiksi etsiä kaikki tehtävät, mitä Joni-niminen opiskelija on saattanut tehdä, ensimmäinen askel on etsiä polku taulusta <code>Tehtävä</code> tauluun <code>Opiskelija</code>.</p>
	  
	  <p>Aloitamme siis taulusta <code>Tehtävä</code>, ja etsimme polun tauluun <code>Opiskelija</code>. Jotta pääsemme taulusta Tehtävä tauluun Opiskelija, tulee meidän vierailla tauluissa <code>Kurssitehtävä</code>, <code>Kurssi</code> ja <code>Kurssisuoritus</code>, jota seuraa taulu <code>Opiskelija</code>.</p>
	  <p>Kyselyä muodostaessa on hyvä yhdistää taulu kerrallaan toisiinsa.</p>
	  
	  <ol>
	    <li>Yhdistämme ensin taulut Tehtävä ja Kurssitehtävä:
	      <pre class="sh_sql">
SELECT Tehtävä.nimi AS tehtävä
    FROM Tehtävä, Kurssitehtävä
    WHERE Tehtävä.tunnus = Kurssitehtava.tehtävä</pre></li>

	    <li>Yhdistämme seuraavaksi edellisiin tauluihin taulun Kurssi:
	      <pre class="sh_sql">
SELECT Tehtävä.nimi AS tehtävä
    FROM Tehtävä, Kurssitehtävä, Kurssi
    WHERE Tehtävä.tunnus = Kurssitehtävä.tehtävä
        AND Kurssitehtävä.kurssi = Kurssi.kurssitunnus</pre></li>
	    
	    <li>Seuraavaksi, yhdistämme kurssin kurssisuoritukseen:
	      <pre class="sh_sql">
SELECT Tehtävä.nimi as tehtävä
    FROM Tehtävä, Kurssitehtävä, Kurssi, Kurssisuoritus
    WHERE Tehtävä.tunnus = Kurssitehtävä.tehtävä
        AND Kurssitehtävä.kurssi = Kurssi.kurssitunnus
        AND Kurssi.kurssitunnus = Kurssisuoritus.kurssi</pre></li>
	    
	    <li>Ja viimeinkin, saamme yhdistettyä polun opiskelijaan:
	      <pre class="sh_sql">
SELECT Tehtävä.nimi AS tehtävä
    FROM Tehtävä, Kurssitehtävä, Kurssi, Kurssisuoritus, Opiskelija
    WHERE Tehtävä.tunnus = Kurssitehtävä.tehtävä
        AND Kurssitehtävä.kurssi = Kurssi.kurssitunnus
        AND Kurssi.kurssitunnus = Kurssisuoritus.kurssi
        AND Kurssisuoritus.opiskelija = Opiskelija.opiskelijanumero</pre></li>

	    <li>Koska halusimme saada Joniin mahdollisesti liittyvät tehtävät, lisätään haettaviin kenttiin vielä opiskelijan nimi:
	      <pre class="sh_sql">
SELECT Tehtävä.nimi AS tehtävä
    FROM Tehtävä, Kurssitehtävä, Kurssi, Kurssisuoritus, Opiskelija
    WHERE Tehtävä.tunnus = Kurssitehtävä.tehtävä
        AND Kurssitehtävä.kurssi = Kurssi.kurssitunnus
        AND Kurssi.kurssitunnus = Kurssisuoritus.kurssi
        AND Kurssisuoritus.opiskelija = Opiskelija.opiskelijanumero
        AND Opiskelija.nimi = 'Joni'</pre></li>
	    
	  </ol>
	  
	  
	</aside>
	
	<p>Voit kokeilla juuri rakennettua kyselyä alla.</p>
	
	<div ng-controller="weekTwoSqlController">
	  <query
	     db="db"
	     query="SELECT Tehtävä.nimi AS Tehtävä
    FROM Tehtävä, Kurssitehtävä, Kurssi, Kurssisuoritus, Opiskelija
    WHERE Tehtävä.tunnus = Kurssitehtävä.tehtävä
        AND Kurssitehtävä.kurssi = Kurssi.kurssitunnus
        AND Kurssi.kurssitunnus = Kurssisuoritus.kurssi
        AND Kurssisuoritus.opiskelija = Opiskelija.opiskelijanumero
        AND Opiskelija.nimi = 'Joni'">
	  </query>
	  
	</div>
	
	
	<p><strong><em>Opiskelijan tekemät tehtävät</em></strong></p>
	
	<p>Voimme hakea kurssiin liittyvät tehtävät, kurssiin liittyvät opiskelijat, sekä opiskelijan <em>mahdollisesti</em> tekemät tehtävät, jotka saadaan hakemalla kaikkiin opiskelijan kursseihin liittyvät tehtävät. Emme kuitenkaan saa selville yksittäisen opiskelijen tekemiä tai tekemättä jättämiä tehtäviä. </p>
	
	<p>Jotta tuleva opintojen seurantaan liittyvä järjestelmämme toimisi mielekkäästi, lisätään tietokantaan mahdollisuus opiskelijan ja tehtyjen tehtävien yhdistämiseen. Voimme yhdistää opiskelijan joko tehtävään tai kurssiin liittyvään tehtävään.</p>
	
	<p>Jos opiskelija yhdistetään tehtävään, opiskelijan tekemä tehtävä näkyy merkittynä kaikilla tehtävää käyttävillä kursseilla. Tämä ei kuitenkaan ole aina toivottua, sillä tehtäviä käytetään myös kertaamistarkoituksessa. Linkitetään siis opiskelija kurssitehtävään: <em>yksi opiskelija voi suorittaa monta kurssitehtävää, ja yhden kurssitehtävän voi suorittaa monta opiskelijaa</em> -- yhteys on monen suhde moneen -tyyppinen.</p>

	<p>Tiedämme miten toimia. Koska Opiskelija-taulussa on pääavain, avainta ei tarvitse määritellä siihen. Kurssitehtävä-taulussa pääavainta ei ole, joten määritellään sille pääavain -- kutsutaan avainta nimellä <em>tunnus</em>. Luodaan tämän jälkeen liitostaulu, jonka tehtävänä on kytkeä Opiskelija-taulun ja Kurssitehtävä-taulun rivejä, ja sitä kautta pitää kirjaa suorituksista. Kutsutaan liitostaulua nimellä <em>Tehtäväsuoritus</em>, ja määritellään sille viiteavaimet tauluun Opiskelija ja tauluun Kurssitehtävä. Lisätään tämän lisäksi tauluun myös kenttä <em>suoritusaika</em>, johon merkitään tehtävän suoritusaika.</p>
	
	<p>Taulu Tehtäväsuoritus näyttää seuraavanlaiselta:</p>
	
	<figure>
	  <img src="img/viikko3/taulu-tehtavasuoritus.png" alt="[Tehtäväsuoritus|(fk) opiskelija: Opiskelija; (fk) tehtävä: Kurssitehtävä; suoritusaika]"/>
	</figure>
	
	<p>Yhteen tehtäväsuoritukseen liittyy yksi opiskelija, mutta opiskelijalla voi olla monta tehtäväsuoritusta. Samoin, yhteen tehtäväsuoritukseen liittyy yksi kurssitehtävä, mutta yhteen kurssitehtävään voi liittyä monta tehtäväsuoritusta. Kokonaisuudessaan tietokantakaaviomme on nyt seuraavanlainen:</p>

	<figure>
	  <img src="img/viikko3/tietokantakaavio-tehtavasuorituksella.png" alt="[Opiskelija|(pk) opiskelijanumero;nimi;syntymävuosi;pääaine]1-*[Kurssisuoritus|(fk) opiskelija: Opiskelija;(fk) kurssi: Kurssi;päivämäärä;arvosana;opintopistemäärä]
[Kurssisuoritus]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]
[Tehtävä|(pk) tunnus;nimi;kuvaus]1-*[Kurssitehtävä|(pk) tunnus; (fk) tehtävä: Tehtävä; (fk) kurssi: Kurssi]
[Kurssitehtävä]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]
[Tehtäväsuoritus|(fk) opiskelija: Opiskelija; (fk) tehtävä: Kurssitehtävä; suoritusaika]
[Tehtäväsuoritus]*-1[Opiskelija]
[Tehtäväsuoritus]*-1[Kurssitehtävä]"/>
	</figure>
	
	<p>&nbsp;</p>
	
	<p><strong><em>Opiskelijan tekemien tehtävien hakeminen</em></strong></p>
	
	<p>Nyt opiskelijan tekemien tehtävien hakeminen on suoraviivaisempaa. Hahmotellaan kysely, joka hakee kaikki opiskelijat, jotka ovat tehneet tietokantojen perusteet -kurssin tehtäviä, sekä näiden opiskelijoiden tekemät tehtävät. Muotoillaan tulostus siten, että tuloksessa on opiskelijan nimi ja opiskelijan tekemän tehtävän nimi.</p>
	
	<p>Aloitetaan hakemalla Kurssi-taulusta kurssi Tietokantojen perusteet.</p>
	
<pre class="sh_sql">
SELECT * FROM Kurssi WHERE nimi = 'Tietokantojen perusteet';
</pre>

	<p>Kytketään seuraavaksi kyselyn tulos tauluun Kurssitehtävä, eli haetaan kaikki kurssitehtävät, joissa kurssina on Tietokantojen perusteet.</p>
	
<pre class="sh_sql">
SELECT * FROM Kurssi, Kurssitehtävä
    WHERE Kurssi.nimi = 'Tietokantojen perusteet'
        AND Kurssi.kurssitunnus = Kurssitehtävä.kurssi;
</pre>

	<p>Liitetään kyselyyn tämän jälkeen taulu Tehtävä, jonka kautta saamme tehtävien nimet.</p>
	
<pre class="sh_sql">
SELECT * FROM Kurssi, Kurssitehtävä, Tehtävä
    WHERE Kurssi.nimi = 'Tietokantojen perusteet'
        AND Kurssi.kurssitunnus = Kurssitehtävä.kurssi
        AND Tehtävä.tunnus = Kurssitehtävä.tehtävä;
</pre>

	<p>Tulostetaan välitarkastuksena tehtävien nimet:</p>

<pre class="sh_sql">
SELECT Tehtävä.nimi AS Tehtävä
    FROM Kurssi, Kurssitehtävä, Tehtävä
    WHERE Kurssi.nimi = 'Tietokantojen perusteet'
        AND Kurssi.kurssitunnus = Kurssitehtävä.kurssi
        AND Tehtävä.tunnus = Kurssitehtävä.tehtävä;
</pre>


	<p>Kyselyn tulos on seuraava -- tuntuu toimivan.</p>
	
	
	<div class="data-table">
	  <table class="table">
	    <thead>
	      <tr>
		<th>Tehtävä</th>
	      </tr>
	    </thead>
	    <tbody>
	      <tr>
		<td>Onko tässä rekursio?</td>
	      </tr>
	      <tr>
		<td>Keksi tehtävä</td>
	      </tr>
	      <tr>
		<td>Koetus</td>
	      </tr>
	    </tbody>
	  </table>
	</div>
	
	
	
	<p>Lisätään kyselyyn tämän jälkeen taulu Tehtäväsuoritus, jonka kautta pääsemme kohta Opiskelija-tauluun.</p>


<pre class="sh_sql">
SELECT Tehtävä.nimi AS Tehtävä
    FROM Kurssi, Kurssitehtävä, Tehtävä, Tehtäväsuoritus
    WHERE Kurssi.nimi = 'Tietokantojen perusteet'
        AND Kurssi.kurssitunnus = Kurssitehtävä.kurssi
        AND Tehtävä.tunnus = Kurssitehtävä.tehtävä
        AND Tehtäväsuoritus.tehtävä = Kurssitehtävä.tunnus;
</pre>

	<p>Lisätään lopulta kyselyyn vielä Opiskelija-taulu, ja haetaan sieltä opiskelijan nimi. Voit kokeilla tuloksena olevaa kyselyä alla.</p>


	<div ng-controller="weekThreeSqlController">
		  
	  
	  <query
	     db="db"
	     editable="false"
	     done="listTikapeTehtavat"
	     query="SELECT Opiskelija.nimi AS Opiskelija, Tehtävä.nimi AS Tehtävä
    FROM Kurssi, Kurssitehtävä, Tehtävä, Tehtäväsuoritus, Opiskelija
    WHERE Kurssi.nimi = 'Tietokantojen perusteet'
        AND Kurssi.kurssitunnus = Kurssitehtävä.kurssi
        AND Tehtävä.tunnus = Kurssitehtävä.tehtävä
        AND Tehtäväsuoritus.tehtävä = Kurssitehtävä.tunnus
        AND Tehtäväsuoritus.opiskelija = Opiskelija.opiskelijanumero">
	  </query>

	  <div ng-show="listTikapeTehtavat">
	    
	    <h4>Tehtävät</h4>
	    
	    <p>Tee nyt kysely, joka tulostaa kaikki tehtävät, jotka opiskelija 'Anna' on suorittanut. Tee tulostuksesta sellainen, että yksi sarake sisältää kurssin nimen, ja toinen sarake tehtävän nimen.</p>
	    
	    
	    <togglable content="taulut" db="db">
              <table-info></table-info>
	    </togglable>
	    
	    <query db="db"></query>
	  </div>
	</div>
	  
	
	<aside class="info">
	  <br/>
	  <h1>Pohdi</h1>
	  
	  <p>Alla on kaksi vaihetta edellisessä esimerkissä rakennetusta kyselystä.</p>
	    
	  <pre class="sh_sql">
SELECT Tehtävä.nimi AS Tehtävä
    FROM Kurssi, Kurssitehtävä, Tehtävä
    WHERE Kurssi.nimi = 'Tietokantojen perusteet'
        AND Kurssi.kurssitunnus = Kurssitehtävä.kurssi
        AND Tehtävä.tunnus = Kurssitehtävä.tehtävä;</pre>

	  <pre class="sh_sql">
SELECT Opiskelija.nimi AS Opiskelija, Tehtävä.nimi AS Tehtävä
    FROM Kurssi, Kurssitehtävä, Tehtävä, Tehtäväsuoritus, Opiskelija
    WHERE Kurssi.nimi = 'Tietokantojen perusteet'
        AND Kurssi.kurssitunnus = Kurssitehtävä.kurssi
        AND Tehtävä.tunnus = Kurssitehtävä.tehtävä
        AND Tehtäväsuoritus.tehtävä = Kurssitehtävä.tunnus
        AND Tehtäväsuoritus.opiskelija = Opiskelija.opiskelijanumero;</pre>
	  
	  <p>Ensimmäisen kyselyn tuloksena on kolme riviä, ja se listaa kaikki tehtävät jotka liittyvät kurssiin 'Tietokantojen perusteet'. Miksi kuitenkin toisen kyselyn tuloksena on viisi riviä? Jos kurssiin liittyviä tehtäviä on vain kolme, mistä neljäs ja viides rivi tulee, ja miksi?</p>
	  
	  
	</aside>
	  
	  
	<h2>Useammassa taulussa olevan tiedon yhdistäminen JOIN-kyselyillä</h2>
	
	<p>Kyselyssä, missä taulujen rivit yhdistetään WHERE-ehdon ja avainten perusteella, valitaan näytettäväksi vain ne rivit, jotka täyttävät annetun ehdon. Esimerkiksi, voimme hakea kaikki kurssit ja ne tehneet opiskelijat seuraavasti:</p>

	<div ng-controller="weekThreeSqlController">
	  
	  <query
	     db="db"
             editable="false"
	     query="SELECT Kurssi.nimi AS Kurssi, Opiskelija.nimi AS Opiskelija
    FROM Kurssi, Kurssisuoritus, Opiskelija
    WHERE Kurssi.kurssitunnus = Kurssisuoritus.kurssi
        AND Kurssisuoritus.opiskelija = Opiskelija.opiskelijanumero">
	  </query>
	</div>


	<p>Entä jos haluaisimme nähdä myös ne kurssit, joita kukaan ei ole suorittanut? Tämä ei ratkea, ainakaan suoraviivaisesti.</p>

	<p>Vuonna 1992 julkaistu SQL-standardin versio toi mukanaan JOIN-kyselyt, joiden avulla edellä määritelty ongelma ratkeaa -- pienen harjoittelun kautta. Tutustutaan seuraavaksi aiemmin oppimaamme taulujen yhdistämistapaa tukeviin erityyppisiin JOIN-kyselyihin.</p>

	<p><strong><em>INNER JOIN</em></strong></p>
	
	<p>Aiemmin tutuksi tullut kysely <code>SELECT * FROM Opiskelija, Kurssisuoritus WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija</code> valitsee vastaukseen vain ne rivit, joiden kohdalla ehto <em>Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija</em> pätee, eli missä Opiskelija-taulun opiskelijanumero-sarakkeen arvo on sama kuin Kurssisuoritus-taulun opiskelija-sarakkeen arvo.</p>

	<p>Edellinen kysely voidaan kirjoittaa myös muodossa <code>SELECT * FROM Opiskelija INNER JOIN Kurssisuoritus ON Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija</code>.</p>
	
	<div ng-controller="weekThreeSqlController">
	  
	  <query
	     db="db"
             editable="false"
	     query="SELECT * FROM Opiskelija
    INNER JOIN Kurssisuoritus
        ON Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija">
	  </query>
	</div>
	
	<p>Jos haluamme kyselyyn useampia tauluja, lisätään ne INNER JOIN -komennon avulla kyselyn jatkoksi. Esimerkiksi kaksi seuraavaa kyselyä ovat toiminnallisuudeltaan samankaltaiset.</p>
	
	<pre class="sh_sql">
SELECT Kurssi.nimi AS Kurssi, Opiskelija.nimi AS Opiskelija
    FROM Kurssi, Kurssisuoritus, Opiskelija
    WHERE Kurssi.kurssitunnus = Kurssisuoritus.kurssi
        AND Kurssisuoritus.opiskelija = Opiskelija.opiskelijanumero;</pre>


	<div ng-controller="weekThreeSqlController">
	  <query
	     db="db"
             editable="false"
	     query="SELECT Kurssi.nimi AS Kurssi, Opiskelija.nimi AS Opiskelija
    FROM Kurssi
    INNER JOIN Kurssisuoritus
        ON Kurssi.kurssitunnus = Kurssisuoritus.kurssi
    INNER JOIN Opiskelija
        ON Kurssisuoritus.opiskelija = Opiskelija.opiskelijanumero">
		</query>

	</div>
	
	<p>Kyselyn <em>INNER JOIN</em> avulla voimme siis tehdä kutakuinkin saman työn kuin aiemman WHERE-ehdon avulla, eli valita mukaan vain ne rivit, joiden kohdalla ehto pätee.</p>
	
	<p><strong><em>LEFT JOIN</em></strong></p>
	
	<p>Mikä tekee taulujen liitoksesta JOIN-kyselyn avulla WHERE-ehtoa monipuolisemman, on se, että JOIN-kyselyn avulla voidaan määritellä kyselyehtoa täyttämättömille riveille toiminnallisuutta. Avainsanalla <code>LEFT JOIN</code> voidaan määritellä kyselyn tulos sellaiseksi, että ehdon täyttävien rivien lisäksi vastaukseen sisällytetään kaikki FROM-avainsanaa seuraavan taulun rivit, joille liitosehto ei täyttynyt.</p>
	
	<p>Allaoleva kysely listaa kurssisuorituksia keränneiden opiskelijoiden lisäksi myös opiskelijat, joilla ei ole kurssisuorituksia. Tällöin kurssisuoritukseen liittyvä vastauksen osa jää tyhjäksi.</p>

	<div ng-controller="weekThreeSqlController">
	  <query
	     db="db"
             editable="false"
	     query="SELECT * FROM Opiskelija
    LEFT JOIN Kurssisuoritus
        ON Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija">
		</query>
	</div>
	  
	<p>Niiden kurssien listaus, joilla on kävijöitä, tai joilla ei ole kävijöitä onnistuu myös esimerkiksi seuraavasti.</p>
	  
	<div ng-controller="weekThreeSqlController">
	  <query
	     db="db"
	     editable="false"
	     query="SELECT * FROM Kurssi
    LEFT JOIN Kurssisuoritus
        ON Kurssi.kurssitunnus = Kurssisuoritus.kurssi">
	  </query>
	</div>

	<p><strong><em>Liitostyypit lyhyesti</em></strong></p>

	<p>Kyselyn JOIN-tyypin voi muotoilla usealla eri tavalla:</p>
	
	<ul>
	  <li><code>INNER JOIN</code> -- palauta vain ne rivit, joihin valintaehto kohdistuu.</li>
	  <li><code>LEFT JOIN</code> -- palauta kaikki FROM-komentoa seuraavan taulun rivit, ja liitä niihin LEFT JOIN-komentoa seuraavan taulun rivit niiltä kohdin, kuin se on ON-liitosehdossa määritellyn ehdon mukaan mahdollista</li>
	  <li><code>RIGHT JOIN</code> -- palauta kaikki RIGHT JOIN-komentoa seuraavan taulun rivit, ja liitä niihin FROM-komentoa seuraavan taulun rivit niiltä kohdin, kuin se on ON-liitosehdossa määritellyn ehdon mukaan mahdollista</li>
	  <li><code>FULL JOIN</code> -- palauta kaikki FROM-komentoa seuraavan taulun rivit sekä kaikki FULL JOIN-komentoa seuraavan taulun rivit, ja liitä ne toisiinsa niiltä kohdin, kuin se on ON-liitosehdossa määritellyn ehdon mukaan mahdollista</li>
	</ul>
	
	<p><em>Valitettavasti tällä sivulla käytössä oleva kyselyiden harjoitteluun tarkoitettu apuväline ei tue RIGHT JOIN ja FULL JOIN -tyyppisiä kyselyitä.</em></p>
	
	
	<aside class="info">
	  
	  <br/>
	  
	  <h1>Visuaalinen opas JOIN-kyselyihin</h1>
	  
	  <p>C.L. Moffatt on kirjoittanut hyvän yhteenvedon erilaisista JOIN-tyypeistä. Tutustu yhteenvetoon osoitteessa <a href="http://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins" target="_blank">http://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins</a>.</p>
	  
	  <figure>
	    <img src="img/viikko3/moffatt-visual_joins.png" alt="pyydä piirtämään seuraavassa miitissä :)"/>
	    <p>&nbsp;</p>
	    <figcaption>Yhteenveto erilaisista JOIN-kyselyistä ja niiden merkityksistä joukkojen kautta visualisoituna.</figcaption>
	  </figure>
	  
	  
	</aside>
	
	
	<h2>Tietokantarivien lisääminen ja poistaminen</h2>
	
	<p>Kyselyiden lisäksi on tärkeää pystyä sekä lisäämään rivejä tauluihin, että poistamaan rivejä tauluista.</p>
	
	<p><strong><em>Rivien poistaminen taulusta</em></strong></p>
	
	<p>Rivien poistaminen tietokantataulusta tapahtuu komennon <code>DELETE FROM</code> avulla, mitä seuraa taulun nimi, mistä poistetaan tietoa, sekä <code>WHERE</code>-ehto, millä määritellään ehdot, joihin osuvat rivit poistetaan.</p>
	
	<p>Esimerkiksi, opiskelija nimeltä 'Gandhi' voidaan poistaa seuraavalla komennolla.</p>
	
<pre class="sh_sql">
DELETE FROM Opiskelija WHERE nimi = 'Gandhi'
</pre>


	<p><strong><em>Rivien lisääminen tauluun</em></strong></p>

	<p>Rivien lisääminen tietokantatauluun tapahtuu komennon <code>INSERT INTO</code> avulla, mitä seuraa kohdetaulun nimi. Taulun jälkeen määritellään sarakkeet, joihin arvot asetetaan, jota seuraa uudelle riville lisättävät arvot.</p>
	
	<p>Esimerkiksi, uusi Kurssi nimeltä 'Web-selainohjelmointi', jonka kurssitunnus on 582354 lisätään tauluun seuraavalla komennolla. Lisäyksen </p>

<pre class="sh_sql">
INSERT INTO Kurssi (kurssitunnus, nimi, kuvaus)
    VALUES (582354,
            'Web-selainohjelmointi',
            'Web-sovellusten selainpuolen toiminnallisuuden toteuttamisen perustekniikoita');
</pre>


        <p>Toisaalta, uuden opiskelijan -- Jack Bowerin -- lisääminen tapahtuu seuraavasti:</p>
	
	<div ng-controller="weekThreeSqlController">
	  <query
	     db="db"
	     query="INSERT INTO Opiskelija (opiskelijanumero, nimi, syntymävuosi, pääaine)
    VALUES (123456, 'Jack Bower', 1962, 'e-Spinach')">
	  </query>

	  <p>Uusien rivien lisäämiseen on myös toinen merkintätapa. Jos jokaiseen taulun sarakkeeseen ollaan lisäämässä arvo, ei sarakkeiden nimiä tarvitse erikseen kertoa.</p>

	  <query
	     db="db"
	     query="INSERT INTO Opiskelija VALUES (123458, 'Maggie Simpson', 1988, 'Genetiikka')">
	  </query>


	  <query
	     db="db"
	     editable="false"
	     query="SELECT * FROM Opiskelija">
	  </query>

	</div>
	
	
	<header>
	  <h1 id="viikko2">Viikko 2</h1>
	</header>
	
	
	<h1>Käsiteanalyysi</h1>
	
	
	<p>Käsiteanalyysia (conceptual modeling) käytetään tutkittavaan aihepiiriin tai ongelma-alueeseen liittyvien käsitteiden sekä niiden välisten yhteyksien selvittämiseen. Käsite voidaan määritellä löyhästi jonkinlaisena asiana, jonka nykyinen olemassaolo ei vaadi jonkun muun asian olemassaoloa -- jos asia on olemassaoloriippuvainen, se on mahdollisesti hyvä attribuuttiehdokas. Esimerkiksi <em>Henkilön nimi</em> ei ole tässä mielessä käsite, sillä henkilön nimi on riippuvainen henkilön olemassaolosta. Toisaalta, Henkilö taas on käsite, sillä sen olemassaolo ei vaadi jonkun muun asian olemassaoloa. Käsitteet voidaan tyypillisesti myös erottaa toisistaan jollain tavalla, tai niille tulee olla vähintäänkin mahdollista määritellä jonkunlainen yksilöivä tunnus.</p>
	
	<p>Käsitteiden välisillä yhteyksillä taas tarkoitetaan esimerkiksi käsitteiden välisiä suhteita, esimerkiksi Henkilöllä voi olla sisaruksia sekä vanhemmat, ja henkilö voi vaikkapa opiskella jossain opinahjossa.</p>
	
	<p>Seuraamme tällä kurssilla kurssin <em>Ohjelmistotekniikan menetelmät</em> <a href="http://www.cs.helsinki.fi/u/mluukkai/otm2012/otm.pdf" target="_blank">luentomonisteessa</a> esitettyä menetelmää käsiteanalyysiin. Siinä missä kurssilla ohjelmistotekniikan menetelmät puhutaan luokkaehdokkaista, puhumme tällä kurssilla käsitteistä. Kurssi ohjelmistotekniikan menetelmät linjaa seuraavat askeleet käsitteiden eriyttämiseen:</p>
		  
	<ol>
	  <li><em>Kartoita käsite-ehdokkaita</em>
	    
	    <p>Laadi luettelo tarkasteltavan ilmiön kannalta keskeisistä kohteista tai ilmiöistä, jotka voisivat tulla kyseeseen käsitteinä. Tällaisia voisivat olla toimintaan osallistujat, toiminnan kohteet, toimintaan liittyvät tapahtumat, materiaalit, tuotteet ja välituotteet, toiminnalle edellytyksiä luovat asiat.</p>
	    
	    <p>Kartoituksen pohjana voi käyttää vapaamuotoista tekstikuvausta tarkasteltavasta ilmiöstä, jota kutsutaan jatkossa kohdealueeksi (engl. problem domain). Tästä kuvauksesta alleviivataan käsite-ehdokkaita ja kerätään ne luetteloon. Käsite-ehdokkaat esiintyvät kuvauksessa usein substantiiveina. Alustavaa karsintaa voi tehdä sen perusteella, onko asia lainkaan oleellinen mallinnettavan ilmiön kannalta.</p>
	    
	  </li>
	  
	  <li><em>Karsi ehdokkaita</em>
	    
	    <p>Luetteloon saadut ehdokkaat käydään läpi ja arvioidaan voisiko ehdokas tulla kyseeseen käsitteenä. Arvioinnissa tulisi tarkastella:</p>
	    
	    <ul>
	      <li>Liittyykö ilmiöön tietosisältöä, joka on välttämätöntä järjestelmän kannalta.</li>
	      <li>Onko asia riittävän tärkeä kohdealueen kannalta.</li>
	    </ul>
	    
	    <p>Karsintaa ja ehdokkaiden kartoitusta joudutaan usein tekemään iteratiivisesti. Ensimmäinen karsintakierros ei välttämättä tuota lopullista tulosta.</p>
	    
	  </li>
	  
	  <li><em>Tunnista käsitteiden väliset yhteydet</em>
	    
	    <p>Yhteyksiä voi etsiä vapaamuotoisesta kuvauksesta. Yhteyttä ilmaisevat usein verbit, genetiivit, muut kytkentää kuvaavat ilmaukset. Yhteyksienkin suhteen tulisi miettiä onko yhteys oleellinen tarkasteltavan ilmiön kannalta sekä onko se rakenteellinen eli jollain lailla pysyvä ilmiöiden välinen suhde. Yhteyksiksi otetaan ainoastaan merkitykselliset, pysyvämpiluonteiset suhteet ilmiöiden välillä.</p>
	    
	  </li>
	  
	  <li><em>Määrittele yhteyksiin liittyvät osallistumisrajoitteet</em>
	    
	    <p>Osallistumisrajoitteiden avulla ilmaistaan rakenteellisia sääntöjä. Ne eivät välttämättä tule esiin vapaamuotoisessa kuvauksessa vaan edellyttävät tarkempaa kohdealueen analysointia.</p>
	    
	  </li>
	  
	  
	  <li><em>Täsmennä käsitteitä määrittelemällä attribuutit</em>
	    
	    <p>Attribuutteja saattaa löytyä vapaamuotoisesta kuvauksesta, mutta yleensä niiden löytäminen edellyttää lisäselvityksiä kohdealueesta, esimerkiksi toiminnan osapuolten haastatteluja. Attribuuttien kohdalla tulee myös selvittää mihin niitä tarvitaan.</p>
	    
	  </li>
	  
	</ol>
	
	
	<p>Sovelletaan edellisiä askeleita jo nyt tuttuun Uimari-esimerkkiin:</p>
	
	<aside class="info">
	  <br/>
	  
	  <p>Uimaseuramme Loch Nessin hirviöt on tähän päivään asti käyttänyt paperia uimareidensa tulosten seuraamiseen ja ylläpitoon. Uimaseuraamme juuri liittynyt valmennuspäällikkö vaatii kirjanpidon nykyaikaistamista, ja haluaa että tulokset tallennetaan tietokoneelle.</p>
	  
	  <p>Valmennuspäällikkömme antoi minulle tehtäväksi välittää tietoa seurastamme, eli tässäpä sitä: Meillä on noin sata mies- ja naispuolista uimaria. Uimarit kilpailevat yleensä yhdessä lajissa, esimerkiksi selkäuinnissa, mutta jotkut uimarit kilpailevat useammassakin lajissa. Tuloksia kirjataan sekä kuukausittain järjestettävistä seuran sisäisistä "kuukauden vesihiisi"-kisoista, että jokaisesta seuran ulkopuolella järjestettävästä kilpailusta. Valmentajien tulee pystyä käyttämään tietokoneelle tallennettuja tietoja myös kotoa esimerkiksi internetin välityksellä.</p>
	  
	  <p>Mitä mieltä olette edeltävästä järjestelmätarpeesta, olisiko sellainen mahdollista toteuttaa? Pahoittelut kirjoitusvirheistä!</p>
	  
	</aside>
	
	
	<h2>Käsite-ehdokkaiden kartoitus</h2>
	
	<p>Eristetään tekstistä keskeiset kohteet, ilmiöt ja käsitteet alleviivaamalla ne tekstistä. Aloitetaan valitsemalla lähes kaikki substantiivit tarkasteltavaksi.</p>
	
	<aside class="info">
	  <br/>
	  
	  <p><u>Uimaseuramme</u> Loch Nessin hirviöt on tähän päivään asti käyttänyt <u>paperia</u> <u>uimareidensa</u> <u>tulosten</u> seuraamiseen ja ylläpitoon. <u>Uimaseuraamme</u> juuri liittynyt <u>valmennuspäällikkö</u> vaatii <u>kirjanpidon</u> nykyaikaistamista, ja haluaa että <u>tulokset</u> tallennetaan <u>tietokoneelle</u>.</p>
	  
	  <p><u>Valmennuspäällikkömme</u> antoi minulle tehtäväksi välittää tietoa <u>seurastamme</u>, eli tässäpä sitä: Meillä on noin sata <u>mies- ja naispuolista</u> <u>uimaria</u>. <u>Uimarit</u> kilpailevat yleensä yhdessä <u>lajissa</u>, esimerkiksi <u>selkäuinnissa</u>, mutta jotkut uimarit kilpailevat useammassakin <u>lajissa</u>. Tuloksia kirjataan sekä kuukausittain järjestettävistä seuran sisäisistä "kuukauden vesihiisi"-<u>kisoista</u>, että jokaisesta seuran ulkopuolella järjestettävästä <u>kilpailusta</u>. Valmentajien tulee pystyä käyttämään tietokoneelle tallennettuja tietoja myös kotoa esimerkiksi internetin välityksellä.</p>
	  
	</aside>
	
	<p>Listataan seuraavaksi alleviivatut termit, ja muunnetaan ne samalla yksikkömuotoon.</p>
	
	<ul>
	  <li>Uimaseura</li>
	  <li>Paperi</li>
	  <li>Uimari</li>
	  <li>Tulos</li>
	  <li>Valmennuspäällikkö</li>
	  <li>Kirjanpito</li>
	  <li>Tietokone</li>
	  <li>Seura</li>
	  <li>Miesuimari</li>
	  <li>Naisuimari</li>
	  <li>Selkäuinti</li>
	  <li>Laji</li>
	  <li>Kilpailu</li>
	</ul>
	
	
	<h2>Ehdokkaiden karsinta</h2>
	
	<p>Karsitaan seuraavaksi ehdokkaita.</p>
	
	
	<ul>
	  <li><s>Uimaseura</s> -- seuralle tehdään järjestelmää, voidaan jättää pois ainakin toistaiseksi.</li>
	  <li><s>Paperi</s> -- tästä haluttiin päästä eroon, tulokset kirjattiin aiemmin paperille.</li>
	  <li>Uimari</li>
	  <li>Tulos</li>
	  <li><s>Valmennuspäällikkö</s> -- valmennuspäällikkö haluaa uuden järjestelmän, mutta ei oleellinen käsite tietomallin kannalta.</li>
	  <li><s>Kirjanpito</s> -- järjestelmä tulee sisältämään kirjanpidon, mutta kirjanpito ei käsite järjestelmässä.</li>
	  <li><s>Tietokone</s> -- kts. edellinen</li>
	  <li><s>Seura</s> -- kts. uimaseura.</li>
	  <li><s>Miesuimari</s> -- Uimari on valittuna käsitteeksi, sukupuoli voi esim. olla uimarin attribuuttina.</li>
	  <li><s>Naisuimari</s> -- kts. edellinen</li>
	  <li><s>Selkäuinti</s> -- Laji on valittuna käsitteeksi.</li>
	  <li>Laji</li>
	  <li>Kilpailu</li>
	</ul>
	
	<p>Ehdokkaiden karsinnan jälkeen seuraavat käsitteet ovat jäljellä:</p>
	
	<ul>
	  <li>Kilpailu</li>
	  <li>Laji</li>
	  <li>Uimari</li>
	  <li>Tulos</li>
	</ul>
	
	<h2>Käsitteiden välisten yhteyksien tunnistaminen</h2>
	
	<p>Yhteydet tunnistetaan joko tekstistä tai "rivien välistä" aiempaa tietoa käyttämällä. Esimerkiksi lause "Uimarit kilpailevat yleensä yhdessä lajissa.." vihjaavat että (1) uimarit liittyvät lajiin, (2) uimarit liittyvät kilpailuun, ja (3) lajit liittyvät kilpailuun.</p>
	
	<p>Tämän lisäksi, tulokset liittynevät myös uimariin, kilpailuun ja lajiin. Hahmotellaan käsitekaaviota olemassaolevien käsitteiden perusteella.</p>
	
	<figure>
	  <img src="img/viikko3/uimari-kasitteet.png" alt="[Uimari]-[Laji]
[Laji]-[Kilpailu]
[Kilpailu]-[Uimari]
[Tulos]-[Uimari]
[Tulos]-[Laji]
[Tulos]-[Kilpailu]"/>
	  <p>&nbsp;</p>
	  <figcaption>Kun käsitteet on tunnistettu, hahmotellaan niiden välisiä yhteyksiä. Yllä pohdittu erästä mahdollisuutta ongelma-alueen käsitteiden yhteyksiksi.</figcaption>
	</figure>
	
	
	<h2>Yhteyksiin liittyvien osallistumisrajoitteiden määrittely</h2>
	
	<p>Kun yhteydet on määritelty, määritellään niille seuraavaksi osallistumisrajoitteet. Osallistumisrajoitteilla tarkoitetaan "viivojen päissä" olevia rajoitteita, joilla kerrotaan esimerkiksi tieto, että yhteen tietyn käsitteen ilmentymään liittyy korkeintaan yksi toinen tietyn käsitteen ilmentymä.</p>
	
	<p>Uimari voi osallistua yhteen tai useampaan lajiin, eli uimariin voi liittyä monta lajia. Toisaalta, yhtä lajia voi harrastaa useampi uimari. Kilpailussa voi olla monta lajia, ja lajia voidaan todennäköisesti uida monessa kilpailussa. Kilpailussa voi olla monta uimaria, ja uimari voi uida useammassa kilpailussa. Yksittäiseen tulokseen taas liittyy yksi uimari, yksi laji, ja yksi kilpailu -- mutta, yhteen uimariin voi liittyä monta tulosta, yhteen lajiin voi liittyä monta tulosta, ja yhteen kilpailuun voi liittyä monta tulosta.</p>
	
	<p>Ehdotus käsitekaavioksi osallistumisrajoitteiden kanssa on seuraavanlainen:</p>
	
	<figure>
	  <img src="img/viikko3/uimari-kasitteet-rajoitteilla.png" alt="[Uimari]*-*[Laji]
[Laji]*-*[Kilpailu]
[Kilpailu]*-*[Uimari]
[Tulos]*-1[Uimari]
[Tulos]*-1[Laji]
[Tulos]*-1[Kilpailu]"/>
	  <p>&nbsp;</p>
	  <figcaption>Kun käsitteiden väliset yhteydet on tunnistettu, lisätään yhteyksiin osallistumisrajoitteet. Yllä pohdittu erästä mahdollisuutta osallistumisrajoitteiksi.</figcaption>
	</figure>
	
	
	<h2>Attribuuttien määrittely käsitteisiin</h2>
	
	<p>Käsitteisiin liittyvien attribuuttien määrittely tapahtuu sekä haastatteluiden että ongelma-alueen analyysin kautta. Ongelma-alueen tekstimuotoisesta kuvauksesta tiedämme esimerkiksi, että kilpailuilla on paikka ("paikalliset kilpailut", "seuran ulkopuoliset kilpailut"), mutta toisaalta tekstimuotoinen kuvaus ei esimerkiksi kerro kilpailujen järjestämisajankohdasta. Tieto kilpailun ajankohdasta -- ja sitä kautta tulosten ajankohdasta -- on oleellinen uimareiden kehittymisen seurantaan.</p>


		<h1>Ali- ja yhteenvetokyselyt sekä tilastojen luominen</h1>


		<p>Osaamme hakea yhdestä tai useammasta tietokantataulusta tietoa, sekä rajata kyselyiden palauttamia tuloksia erilaisilla ehdoilla. On kuitenkin kysymyksiä, joihin vastaaminen nykyisillä työvälineillämme on melko hankalaa. Miten esimerkiksi ratkaisisit seuraavat ongelmat?</p>

		<ul>
		  <li>Mitkä tehtävät ovat sellaisia, joita kursseilla heikommin menestyneet opiskelijat -- esimerkiksi hylätyn arvosanan tai ykkösen saaneet -- eivät ole saaneet tehtyä?</li>
		  <li>Miten haen opiskelijat, jotka eivät ole vielä osallistuneet yhdellekään kurssille?</li>
		  <li>Kuinka monta opiskelijaa pääsi tietyn kurssin läpi?</li>
		  <li>Mikä on jokaisen kurssin keskiarvo?</li>
		</ul>

		<p>Yhteistä edellä olevilla kysymyksillä on se, että lähes kaikki niistä ovat oikeastaan yhteenvetokyselyjä. Tutustutaan kohta näiden käsittelyyn liittyviin menetelmiin.</p>

		<aside class="info">
		  <br/>
		  <h1>SQL-kyselyt lyhyemmiksi</h1>

		  <p>Olemme -- tarkoituksella -- käyttäneet SQL-kyselykielestä pidempää kirjoitusasua, missä myös ei-pakollisia komentoja on kirjoitettu kyselyihin niiden selkeyttämiseksi. Jos olet tykästynyt tähän aiemmin käytettyyn runsassanaisempaan kirjoitusasuun, ei siitä tarvitse vaihtaa pois. Alla on kuitenkin esitelty vinkkejä SQL-kyselyiden lyhentämiseksi:</p>

		  <ul>
		    <li><p>Taulujen nimeäminen SQL-kyselyissä.</p> <p>Kirjoittaessamme tauluja yhdisteleviä kyselyjä kuten <code>SELECT * FROM Opiskelija, Kurssisuoritus WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija</code> taulujen nimet toistuvat. Tauluja voidaan uudelleennimetä SQL-kyselyissä asettamalla taulun nimen jälkeen kyselyn aikana käytettävän nimi. Seuraavassa esimerkissä taulu Opiskelija on uudelleennimetty <code>o</code>:ksi, ja taulu Kurssisuoritus on uudelleennimetty <code>k</code>:ksi.</p>

<pre class="sh_sql">
SELECT * FROM Opiskelija o, Kurssisuoritus k WHERE o.opiskelijanumero = k.opiskelija</pre></li>

		    <li><p>Sarakkeiden nimeäminen SQL-kyselyissä.</p><p>Olemme käyttäneet avainsanaa <code>AS</code> taulun sarakkeiden uudelleennimennässä. Kysely <code>SELECT nimi FROM Opiskelija</code> palauttaa sarakkeen, jonka nimi on 'nimi', ja jossa on kaikkien Opiskelija-taulussa olevien opiskelijoiden nimet. Toisaalta, kysely <code>SELECT nimi AS opiskelija FROM Opiskelija</code> nimeää sarakkeen 'nimi' tulostuksessa uudestaan, jolloin sarakkeen 'nimi' otsikoksi tulee 'opiskelija' -- rivit sisältävät opiskelijoiden nimet. Avainsanan <code>AS</code> voi myös jättää pois. Alla oleva kysely tulostaa Opiskelija-taulun nimi-sarakkeen sisällön, mutta siten, että sarakkeen otsikkona on 'opiskelija'.</p><br/>

<pre class="sh_sql">
SELECT nimi opiskelija FROM Opiskelija</pre>

		      <p>Sarakkeet erotellaan pilkulla kuten aiemminkin.</p>

<pre class="sh_sql">
SELECT nimi opiskelija, syntymävuosi vuosi FROM Opiskelija</pre>

		      <p>Kyselyssä voi luonnollisesti sekä lyhentää taulun nimeä, että jättää <code>AS</code> avainsanan pois:</p>

<pre class="sh_sql">
SELECT o.nimi opiskelija, k.arvosana
    FROM Opiskelija o, Kurssisuoritus k
    WHERE o.opiskelijanumero = k.opiskelija</pre></li>

		    <li><p>INNER JOIN ja JOIN</p>

		      <p>Liitoskyselyn INNER JOIN voi kirjoittaa muodossa JOIN.</p></li>
		  </ul>
		</aside>


		<h2>Alikyselyt</h2>

		<p>Alikyselyt ovat nimensä mukaan kyselyn osana suoritettavia alikyselyitä, joiden tuloksia käytetään osana pääkyselyä. Pohditaan kysymystä <em>Miten haen opiskelijat, jotka eivät ole vielä osallistuneet yhdellekään kurssille?</em>, ja käytetään siihen ensin aiemmin tutuksi tullutta tapaa, eli LEFT JOIN -kyselyä. Yhdistetään opiskelijaa ja kurssisuoritusta kuvaavat taulut LEFT JOIN-kyselyllä siten, että myös opiskelijat, joilla ei ole suorituksia tulevat mukaan vastaukseen. Tämän jälkeen, jätetään vastaukseen vain ne rivit, joilla kurssisuoritukseen liittyvät tiedot ovat tyhjiä -- tämä onnistuu katsomalla mitä tahansa kurssisuoritus-taulun saraketta, ja tarkistamalla onko se tyhjä, eli <em>null</em>. Tämä onnistuu seuraavasti:</p>


		<div ng-controller="weekThreeSqlController">

		  <query
		     db="db"
		     editable="false"
		     query="SELECT opiskelijanumero FROM Opiskelija o
    LEFT JOIN Kurssisuoritus k
    ON o.opiskelijanumero = k.opiskelija
    WHERE k.kurssi IS null">
		  </query>

		</div>

		<p>Toinen vaihtoehto edellisen kyselyn toteuttamiseen on toteuttaa kysely, joka hakee kaikki ne opiskelijat, jotka eivät ole kurssisuorituksia saaneiden opiskelijoiden joukossa. Tässä on oleellisesti kaksi kyselyä: (1) hae opiskelijat, joilla on kurssisuoritus, ja (2) hae opiskelijat, jotka eivät ole edellisen kyselyn palauttamassa joukossa.</p>

		<p><strong><em>Alikyselyn toteuttaminen</em></strong></p>

		<p>Alikyselyn toteuttamiseksi voimme määritellä kyselyn WHERE-osaan sarakkeen nimen, jota seuraa avainsana <em>NOT IN</em>, jota taas seuraa suluissa oleva kysely.</p>


		<div ng-controller="weekThreeSqlController">

		  <query
		     db="db"
		     editable="false"
		     query="SELECT opiskelijanumero FROM Opiskelija o
    WHERE o.opiskelijanumero
        NOT IN (SELECT opiskelija FROM Kurssisuoritus)"
		     done="unlockListCoursesWithNoAssignments">
		  </query>

		  <div ng-show="unlockListCoursesWithNoAssignments">

		    <p>Tee nyt kysely, joka listaa kaikki kurssit, joilla ei ole yhtään tehtävää.</p>

		    <query
		       db="db"
		       query="">
		    </query>
		  </div>

		</div>

		<p>Käytännössä alikyselyt tuottavat kyselyn tuloksena taulun, josta pääkyselyssä tehtävä kysely tehdään. Ylläolevassa esimerkissä alikyselyn tuottamassa taulussa on vain yksi sarake, jossa on kurssisuorituksen saaneiden opiskelijoiden opiskelijanumerot.</p>

		<p>Määreen <code>NOT IN</code>, joka tarkastaa että valitut arvot eivät ole alikyselyn tuottamassa taulussa, lisäksi käytössä on määre <code>IN</code>. Määreen <code>IN</code> avulla voidaan luoda ehto, jolla tarkastetaan, että valitut arvot ovat annetussa joukossa tai taulussa. Esimerkiksi alla haetaan kaikki kurssisuoritukset, joissa arvosana on kolme tai viisi.</p>

		<div ng-controller="weekThreeSqlController">

		  <query
		     db="db"
		     editable="false"
		     query="SELECT * FROM Kurssisuoritus WHERE arvosana IN (5, 3)">
		  </query>
		</div>

		<aside class="info">
		  <br/>

		  <h1>EXISTS ja NOT EXISTS</h1>

		  <p>Määreiden IN ja NOT IN lisäksi alikyselyissä voidaan käyttää määreitä EXISTS ja NOT EXISTS, joiden avulla voidaan rajata hakujoukkoa alikyselyssä olevan ehdon perusteella. Voimme esimerkiksi kirjoittaa aiemmin kirjoitetun kursseja suorittamattomia opiskelijoita etsivän kyselyn siten, että jokaisen Opiskelija-taulussa olevan opiskelijanumeron kohdalla tarkistetaan, että sitä ei löydy taulusta Kurssisuoritus.</p>

		  <div ng-controller="weekThreeSqlController">

		    <query
		       db="db"
		       editable="false"
		       query="SELECT opiskelijanumero FROM Opiskelija o
    WHERE NOT EXISTS
        (SELECT opiskelija FROM Kurssisuoritus k
        WHERE k.opiskelija = o.opiskelijanumero)">
		    </query>
                  </div>

		  <p>Edellä oleva kysely tarkistaa jokaisen Opiskelija-taulussa olevan opiskelijanumeron kohdalla ettei sitä löydy Kurssisuoritus-taulun opiskelija-sarakkeesta. Käytännössä -- jos tietokantamoottori ei optimoi kyselyä -- jokainen opiskelija-taulun rivi aiheuttaa uuden kyselyn kurssisuoritus-tauluun, mikä tekee kyselystä tehottoman.</p>

		</aside>


		<h2>Yhteenvetokyselyt</h2>

		<p>Yhteenvetokyselyiden avulla kyselyiden tuloksia ryhmitellään sarakkeissa olevien arvojen perusteella, jonka jälkeen luoduille ryhmille tehdään erilaisia yhteenvetokyselyitä. Voimme esimerkiksi haluta selvittää opiskelijoiden määrän pääaineittain ryhmiteltynä -- toisin sanoen, listata pääaineet ja opiskelijalukumäärät. Kyselyn vastauksessa olevan rivien lukumäärän saa komennolla <code>COUNT(<em>sarake</em>)</code>, missä <em>sarake</em> on laskettavan sarakkeen nimi. Ryhmittely tapahtuu komennon <code>GROUP BY</code>-perusteella, jota seuraa sarakkeen nimi, jonka perusteella tulokset ryhmitellään.</p>


		<div ng-controller="weekThreeSqlController">

		  <query
		     db="db"
		     editable="false"
		     query="SELECT pääaine, COUNT(*) AS lukumäärä
    FROM Opiskelija GROUP BY pääaine"
                     done="unlockListCountKurssisuorituksetByKurssi">
		  </query>

		  <div ng-show="unlockListCountKurssisuorituksetByKurssi">
		    <p>Tee nyt kysely, jolla lasket kurssisuoritus-taulussa olevat kurssisuoritukset kurssin koodin perusteella. Käytä tulostuksessa sarekkeiden nimiä "kurssikoodi" ja "lukumäärä".</p>
		    <query
		       db="db"
		       query=""
		       valid="SELECT kurssi AS kurssikoodi, COUNT(*) lukumäärä FROM Kurssisuoritus GROUP BY kurssi">
		    </query>
		  </div>

		  <p>Useampien taulujen yhdistäminen toimii kuten ennen -- valittavat taulut kerrotaan joko FROM -avainsanan jälkeen tai JOIN -avainsanan jälkeen, riippuen kyselytavasta. Ryhmittelykomento tulee mahdollisten WHERE-ehtojen jälkeen. Alla olevassa esimerkissä lasketaan tehtävien määrä eri kursseilla siten, että kurssin nimi haetaan taulusta Kurssi, ja tehtävät haetaan kurssitehtävistä.</p>

		  <query
		     db="db"
		     editable="false"
		     query="SELECT k.nimi AS kurssi, COUNT(kt.tunnus) AS tehtäviä FROM Kurssi k, Kurssitehtävä kt
    WHERE k.kurssitunnus = kt.kurssi GROUP BY k.nimi"
		     done="unlockListCountKurssisuorituksetByKurssiWithName">
		  </query>



		  <div ng-show="unlockListCountKurssisuorituksetByKurssiWithName">

		    <p>Tee nyt kysely, jossa lasket kurssisuoritus-taulussa olevien kurssien suoritukset -- taas koodin perusteella. Tällä kertaa tulostuksessa tulee kuitenkn tulostaa kurssikoodin sijaan kurssin nimi. Käytä sarakkeiden niminä "kurssi" ja "lukumäärä". (Huomaa, että edellisessä osassa katsotaan kurssitehtäviä, tässä kurssisuorituksia!)</p>


		    <query
		       db="db"
		       query=""
		       valid="SELECT Kurssi.nimi AS kurssi, COUNT(*) lukumäärä FROM Kurssisuoritus, Kurssi WHERE Kurssisuoritus.kurssi = Kurssi.kurssitunnus GROUP BY kurssi">
		    </query>
		  </div>


		  <p>Edellä olevia tuloksia tarkasteltaessamme, huomaamme, että luku nolla ei esiinny yhdelläkään rivillä. Tämä selittyy kyselyillämme -- olemme valinneet mukaan vain rivit, joilla hakuehdot täyttyvät. Hups. Kirjoitetaan edellinen kysely siten, että otamme huomioon kurssit vaikka niihin ei liittyisikään yhtäkään toisen taulun riviä -- käytämme siis <code>LEFT JOIN</code>-liitosoperaatiota.</p>

		  <query
		     db="db"
		     editable="false"
		     query="SELECT k.nimi AS kurssi, COUNT(ks.kurssi) as tehtäviä FROM Kurssi k LEFT JOIN Kurssisuoritus ks
    ON k.kurssitunnus = ks.kurssi GROUP BY k.nimi"
		     done="unlockLeftJoinKurssiAndKurssisuoritus">
		  </query>


		  <div ng-show="unlockLeftJoinKurssiAndKurssisuoritus">

		    <p>Tee nyt LEFT JOIN -operaatiota käyttäen kysely, jolla listaat kurssikohtaiset suorituslukumäärät siten, että myös ne kurssit, joilla ei ole yhtäkään suoritusta otetaan huomioon. Käytä sarakkeiden niminä nimiä "kurssi" ja "lukumäärä".</p>

		    <query
		       db="db"
		       query=""
		       valid="SELECT Kurssi.nimi AS kurssi, COUNT(Kurssisuoritus.kurssi) lukumäärä FROM Kurssi LEFT JOIN Kurssisuoritus ON Kurssi.kurssitunnus = Kurssisuoritus.kurssi GROUP BY kurssi">
		    </query>

		  </div>

		</div>

		<p><strong><em>Ryhmittely useamman sarakkeen perusteella</em></strong></p>

		<p>Komennolle <code>GROUP BY</code> voi antaa myös useampia sarakkeita, jolloin se ryhmittelee ne annetussa järjestyksessä. Esimerkiksi ryhmittely <code>GROUP BY kurssi, arvosana</code> ryhmittelisi taulussa olevat rivit ensin kurssin perusteella, jonka jälkeen ne vielä ryhmiteltäisiin arvosanan perusteella. Tällöin jokaiselle kurssille tulisi erilliset arvosanaryhmät. Esimerkiksi kurssikohtaiset arvosanat saisi tulostettua seuraavalla kyselyllä:</p>


		<div ng-controller="weekThreeSqlController">

		  <query
		     db="db"
		     editable="false"
		     query="SELECT k.nimi AS kurssi, ks.arvosana AS arvosana, COUNT (ks.opiskelija) AS lukumäärä
    FROM Kurssi k, Kurssisuoritus ks WHERE k.kurssitunnus = ks.kurssi
        GROUP BY k.nimi, ks.arvosana">
		  </query>
		</div>

		<p>Edellisessä kyselyssä on hieman tylsää se, että kurssien nimet ja arvosanat eivät ole järjestyksessä.</p>

		<p><strong><em>Tulosten järjestäminen</em></strong></p>

		<p>Kyselyn tulokset voi järjestää komennolla <code>ORDER BY</code>, jota seuraa järjestettävät sarakkeet. Sarakkeelle voi antaa myös lisämääreen <code>ASC</code> (<em>ascending</em>), joka kertoo että tulokset tulee järjestää nousevaan järjestykseen, ja <code>DESC</code> (<em>descending</em>), joka kertoo että tulokset tulee järjestää laskevaan järjestykseen. Oletuksena järjestys on nouseva.</p>

		<p>Komento <code>ORDER BY</code> tulee kyselyn loppuun. Järjestetään edellisen kyselyn tulokset.</p>

		<div ng-controller="weekThreeSqlController">

		  <query
		     db="db"
		     editable="false"
		     query="SELECT k.nimi AS kurssi, ks.arvosana AS arvosana, COUNT (ks.opiskelija) AS lukumäärä
    FROM Kurssi k, Kurssisuoritus ks WHERE k.kurssitunnus = ks.kurssi
        GROUP BY k.nimi, ks.arvosana ORDER BY k.nimi, ks.arvosana DESC">
		  </query>
		</div>


		<p><strong><em>Yhteenvetokyselyissä käytettäviä funktioita</em></strong></p>

		<p>Komento <code>COUNT(<em>sarake</em>)</code> on funktio, jolle annetaan joukko arvoja, ja joka palauttaa niiden pohjalta luodun arvon -- annetun joukon koon eli arvojen lukumäärän. Yhteenvetokyselyiden käytössä on myös nippu muita funktioita, joista seuraavassa listataan muutamia.</p>


		<ul>
		  <li><p>Keskiarvon laskeminen <code>AVG</code></p>

		    <p>Funktio <code>AVG</code> laskee sille annettujen arvojen keskiarvon. Esimerkiksi kurssikohtaiset arvosanojen keskiarvot saa laskettua seuraavalla kyselyllä:</p>

		    <div ng-controller="weekThreeSqlController">

		      <query
			 db="db"
			 editable="false"
			 query="SELECT kurssi, AVG(arvosana) AS keskiarvo
    FROM Kurssisuoritus GROUP BY kurssi">
		      </query>
		    </div>

		  </li>

		  <li><p>Summan laskeminen <code>SUM</code></p>

		    <p>Funktio <code>SUM</code> laskee sille annettujen arvojen summan. Esimerkiksi kysely seuraava kysely laskee opiskelijakohtaisen opintopistemäärän.</p>

		    <div ng-controller="weekThreeSqlController">

		      <query
			 db="db"
			 editable="false"
			 query="SELECT o.nimi AS nimi, SUM(ks.opintopistemäärä) AS opintopisteitä
    FROM Opiskelija o LEFT JOIN Kurssisuoritus ks
        ON o.opiskelijanumero = ks.opiskelija
    WHERE ks.arvosana > 0 GROUP BY o.nimi">
		      </query>
		    </div>


		    <p>Kuten ehkä huomaat, kysely ei toimi tapauksissa, missä opiskelija on korottanut kurssin arvosanaa, sillä hänellä on tällöin useampia hyväksyttyjä merkintöjä samasta kurssista.</p></li>

		  <li><p>Pienimmän arvon valitseminen <code>MIN</code></p>

		    <p>Funktio <code>MIN</code> valitsee sille annettujen arvojen joukosta pienimmän arvon.</p></li>

		  <li><p>Suurimman arvon valitseminen <code>MAX</code></p>

		    <p>Funktio <code>MAX</code> valitsee sille annettujen arvojen joukosta suurimman arvon.</p></li>
		</ul>

		  <p><strong><em>Hakutulosten rajaaminen yhteenvetokyselyiden perusteella</em></strong></p>

		  <p>Jos haluat rajata yhteenvetokyselyn tuloksen perusteella kyselysi palauttamia rivejä, et voi käyttää <code>WHERE</code>-ehtoa tähän. <code>WHERE</code>-ehdon sijaan joudut käyttämään samankaltaista <code>HAVING</code>-ehtoa. Lisätään esimerkiksi edelliseen <code>SUM</code>-kyselyyn rajoitus että haluamme nähdä vain opiskelijat jotka ovat suorittaneet enemmän kuin 10 opintopistettä.</p>

		    <div ng-controller="weekThreeSqlController">

		      <query
			 db="db"
			 editable="false"
			 query="SELECT o.nimi AS nimi, SUM(ks.opintopistemäärä) AS opintopisteitä
    FROM Opiskelija o LEFT JOIN Kurssisuoritus ks
        ON o.opiskelijanumero = ks.opiskelija
    WHERE ks.arvosana > 0 GROUP BY o.nimi HAVING opintopisteitä > 10">
		      </query>
		    </div>



		  <p>Kuten esimerkissä näkyy, samassa kyselyssä voi olla sekä <code>WHERE</code>-ehto että <code>HAVING</code>-ehto.</p>


		<aside class="info">
		  <br/>

		  <h1>Funktiot osana kyselyitä, joissa ryhmittelyä ei tehdä</h1>

		  <p>Edellämainittuja funktioita voi käyttää osana käytännössä minkälaista kyselyä tahansa, jos kyselyn vastauksessa on selkeä yksittäinen sarake, jonka arvoja funktio käsittelee. Esimerkiksi kaikkien kurssien keskiarvon voi laskea seuraavasti:</p>

		  <div ng-controller="weekThreeSqlController">

		    <query
		       db="db"
		       editable="false"
		       query="SELECT AVG(arvosana) FROM Kurssisuoritus">
		    </query>
		  </div>

		  <p>Tässä on kuitenkin huomioitava se, että jos kyselyssä on useampia sarakkeita, tulee funktion pystyä laskemaan sarakekohtaisia tuloksia -- esimerkiksi ryhmittelyn kautta. Alla oleva kysely on esimerkki kyselystä, joka ei palauta oikeaa tulosta.</p>

		  <div ng-controller="weekThreeSqlController">

		    <query
		       db="db"
		       editable="false"
		       query="SELECT kurssi, AVG(arvosana) FROM Kurssisuoritus">
		    </query>
		  </div>

		</aside>



		<h2>Kyselyn tulos on taulu</h2>

		<p>Kaikki SQL-kyselyt tuottavat tuloksena taulun. Taulussa voi olla tasan yksi sarake ja rivi, tai vaikkapa tuhansia rivejä ja kymmeniä sarakkeita. Silloinkin, kun suoritamme yksinkertaisen haun, kuten vaikkapa "Hae kaikki kurssilla 'Tietokantojen perusteet' olevat opiskelijat", on haun tuloksena taulu.</p>

		<p>Kaikki tekemämme SQL-kyselyt ovat liittyneet tauluihin. Emmekö siis voisi tehdä kyselyjä myös vastauksiin? Vastaus on kyllä.</p>

		<p>Esimerkiksi vanhimman (tai vanhimmat, jos tämä ei ole yksikäsitteistä) opiskelijat löytää -- muunmuassa -- etsimällä kaikista pienimmän mahdollisimman syntymävuoden (kyselyn tulos on taulu), jonka jälkeen vastaustaulussa olevaa tulosta kaikkien opiskelijoiden syntymävuosiin.</p>

		<div ng-controller="weekThreeSqlController">
		  <query
		     db="db"
		     editable="false"
		     query="SELECT * FROM Opiskelija
    WHERE syntymävuosi
        IN (SELECT MIN(syntymävuosi) FROM Opiskelija)">
		  </query>
		</div>



		<h1>Tietokantataulujen luominen ja muokkaaminen</h1>

		<p>Tähän mennessä tietokantataulut ovat olleet valmiiksi annettuna, eikä meidän ole tarvinnut pohtia niiden luomista. Tehdään korjausliike, ja tutustutaan tietokantataulujen -- ja sitä kautta -- oman tietokannan rakenteen määrittelyyn ja luomiseen.</p>

		<h2>Tietokantataulun luominen</h2>

		<p>Tietokantataulu luodaan SQL-komennolla <code>CREATE TABLE</code>, jota seuraa luotavan taulun nimi, ja suluissa attribuuttien eli sarakkeiden nimet sekä niiden tyypit pilkulla eroteltuna. Tyyppien määrittely ei ole kaikissa tietokannanhallintajärjestelmissä pakollista, jolloin tietokannanhallintajärjestelmä käyttää mahdollista oletustyyppiä.</p>

		<p>Luodaan aiemmin tutuksi tullut Opiskelija-taulu.</p>

		<div class="data-table">
		  <h4>Opiskelija</h4>
		  <table class="table">
		    <thead>
		      <tr>
			<th>opiskelijanumero</th>
			<th>nimi</th>
			<th>syntymävuosi</th>
			<th>pääaine</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>9999999</td>
			<td>Pihla</td>
			<td>1997</td>
			<td>Tietojenkäsittelytiede</td>
		      </tr>
		      <tr>
 			<td>9999998</td>
			<td>Joni</td>
			<td>1993</td>
			<td>Tietojenkäsittelytiede</td>
		      </tr>
		    </tbody>
		  </table>
		</div>


                <p>Taulu opiskelija saadaan luotua SQL-komennolla <code>CREATE TABLE Opiskelija (opiskelijanumero, nimi, syntymävuosi, pääaine)</code> -- emme ota vielä kantaa sarakkeiden tietotyyppeihin, vaan määrittelemme vain nimet. Tällöin tietokannanhallintajärjestelmä ottaa vastuun sarakkeiden tyyppien asettamisesta -- jos se on mahdollista. </p>

		<div ng-controller="noTablesSqlController">

		  <togglable content="taulut" db="db">
		    <table-info></table-info>
		  </togglable>

		  <query
		     editable="false"
		     done="tableOpiskelijaWasCreated"
		     db="db"
		     rows="3"
		     query="CREATE TABLE Opiskelija (opiskelijanumero, nimi, syntymävuosi, pääaine)">
		  </query>


		  <div ng-show="tableOpiskelijaWasCreated">

		    <p>Juuri luotuun tauluun saa lisättyä uusia rivejä komennolla <code>INSERT INTO</code>, jota seuraa taulun nimi, sarakkeet suluissa eroteltuna, sekä uudelle riville asetettavat arvot.</p>

		    <query
		       db="db"
		       rows="3"
		       query="INSERT INTO Opiskelija (opiskelijanumero, nimi, syntymävuosi, pääaine)
    VALUES ('01283581', 'Jack Bower', 1983, 'Tietojenkäsittelytiede')"
		       done="opiskelijaAddedToTableOpiskelija">
		    </query>
		  </div>

		  <div ng-show="opiskelijaAddedToTableOpiskelija">
		    <p>Luodussa taulussa olevan tiedon hakeminen tapahtuu kuten ennenkin.</p>

		    <query
		       db="db"
		       rows="3"
		       query="SELECT * FROM Opiskelija">
		    </query>
		  </div>


		  <p><strong><em>Kurssi-taulun luominen</em></strong></p>

		  <p>Luo tietokantaan taulu <code>Kurssi</code>, jolla on sarakkeet <code>kurssitunnus</code>, <code>nimi</code> ja <code>kuvaus</code>.</p>


		  <togglable content="taulut" db="db">
		    <table-info></table-info>
		  </togglable>

		  <query
		     db="db"
		     rows="3"
		     done="tableKurssiWasCreated">
		  </query>

		  <div ng-show="tableKurssiWasCreated">
		    <p>Lisää nyt tauluun Kurssi kurssi nimeltä "SQL-kielen perusteet", jonka kurssitunnus on "12345" ja kuvaus "SELECT 'Hei maailma';".</p>

		    <query
		       db="db"
		       rows="3"
		       done="newCourseWasInserted">
		    </query>

		  </div>

		  <div ng-show="newCourseWasInserted">

		    <p>Tarkista vielä, että taulun luominen onnistui, ja että uusi kurssi löytyy tietokantataulusta.</p>

		    <query
		       db="db"
		       rows="3">
		    </query>

		  </div>



		  <aside class="info">
		    <br/>
		    <h1>Olemassaolevien taulujen listaaminen ja poisto</h1>

		    <p>Tietokannanhallintajärjestelmät tyypillisesti tarjoavat mahdollisuuden olemassaolevien tietokantataulujen listaamiseen. Tämä toiminnallisuus on kuitenkin järjestelmäkohtaista -- esimerkiksi tässä materiaalissa käyttämässämme SQLite-versiossa taulujen tiedot löytyvät piilotetusta tietokantataulusta <code>sqlite_master</code>.</p>

		    <query
		       db="db"
		       rows="2"
		       query="SELECT * FROM sqlite_master">
		    </query>


		    <p>Olemassaolevan taulun poistaminen -- esimerkiksi silloin jos sen nimen on kirjoittanut väärin, onnistuu komennolla <code>DROP TABLE</code>, mitä seuraa taulun nimi. Voit kokeilla sitä seuraavassa -- näet poistuiko tietokantataulu kyselyn <code>SELECT * FROM sqlite_master</code> avulla.</p>

		    <query
		       db="db"
		       rows="2">
		    </query>

		  </aside>
		</div>


		<h2>Attribuuttien datatyypit</h2>

                <p>Jokaisella attribuutilla tulee olla nimi sekä datatyyppi. Jos datatyyppiä ei määritellä, voi tietokannanhallintajärjestelmä määritellä sen itse -- esimerkiksi SQLite pyrkii päättelemään attribuutin tyypin dynaamisesti, mutta useimmat tietokannanhallintajärjestelmät eivät tällaista päättelyä tee.</p>

		<p>Tietokantaan säilöttävä tieto voi olla montaa eri muotoa, esimerkiksi merkkijonoja, numeroita, binäärimuodossa olevia tiedostoja, sekä päivämääriä. Tietokannan suunnittelijan tehtävänä on päättää, minkämuotoista dataa missäkin sarakkeessa on.</p>

                <p>Puhekielessä voidaan puhua sarakkeen tyypistä, sillä sarakkeen tyyppi määrää millaista tietoa sarakkeeseen tallennetaan. Käytännössä tietokantataulua luotaessa sarakkeen määrittelyssä annettavat tiedot kertovat tietokannanhallintajärjestelmälle siitä, että minkälaista tietoa sarakkeeseen voidaan lisätä, ja toisaalta samalla minkälaista tietoa sarakkeeseen ei voida lisätä. Sarakkeen tyyppi vaikuttaa myös toiminnallisuuksiin -- esimerkiksi keskiarvon laskeminen merkkijonotyyppisiä arvoja sisältävästä sarakkeesta ei todennäköisesti ole hyödyllistä.</p>

		<p>Tyypilliset datatyypit ovat seuraavat:</p>

		<ul>
		  <li><strong>varchar(n)</strong> korkeintaan <em>n</em> merkin pituinen merkkijono.</li>
		  <li><strong>integer</strong> kokonaisluku</li>
		  <li><strong>float</strong> liukuluku eli desimaaliluku</li>
		  <li><strong>date</strong> päivämäärä, tallentaa vuoden, kuukauden ja päivän</li>
		  <li><strong>timestamp</strong> aikaleima, tallentaa vuoden, kuukauden, päivän, tunnit, minuutit ja sekunnit -- mahdollisesti myös tarkempia arvoja</li>
		</ul>

                <p>Taulua luodessa sarakkeen tyyppi määritellään lisäämällä datatyypin nimi sarakkeen nimen perään. Esimerkiksi Opiskelija-taulua luodessa opiskelijanumero voitaisiin määritellä kokonaisluvuksi, nimi korkeintaan 200 merkkiä pitkäksi merkkijonoksi, syntymävuosi päivämääräksi ja pääaine korkeintaan 50 merkkiä pitkäksi merkkijonoksi seuraavasti:</p>

<pre class="sh_sql">
CREATE TABLE Opiskelija
(
    opiskelijanumero integer,
    nimi varchar(200),
    syntymävuosi date,
    pääaine varchar(50)
)
</pre>

                <p>Nyt -- riippuen käytetystä tietokannanhallintajärjestelmästä -- sarakkeeseen opiskelijanumero ei voisi esimerkiksi lisätä merkkijonoa, sillä se on kokonaisluku. Tämä johtaa tilanteeseen, missä tietokannanhallintajärjestelmä itsessään varoittaa tiedon lisääjää yksinkertaisista virheistä.</p>


		<aside class="info">
		  <br/>

		  <h1>Olemassaolevien attribuuttien datatyypin selvittäminen</h1>


		  <p>Attribuutin -- tai sarakkeen -- datatyypin kysymiseen tietokannalta <a href="http://stackoverflow.com/questions/13405572/sql-statement-to-get-column-type" target="_blank">ei ole yhtä tapaa</a>, vaan tapa liittyy käytettävään tietokannanhallintajärjestelmään. Käyttämässämme SQLite-versiossa sarakkeen tyypin saa selville kyselyllä <code>PRAGMA TABLE_INFO(<em>TaulunNimi</em>)</code>, missä <em>TaulunNimi</em> on tarkasteltavan taulun nimi.</p>

		  <div ng-controller="noTablesSqlController">

		    <p>Luo ensin tarkasteltava tietokantataulu.</p>

		    <query
		       db="db"
		       rows="3"
		       done="tableCreated">
		    </query>

		    <div ng-show="tableCreated">


		      <togglable content="taulut" db="db">
			<table-info></table-info>
		      </togglable>

		      <p>Kun tietokantataulu on luotu, saat tarkasteltua sen sisältöä <code>PRAGMA</code>-komennolla.</p>

		      <query
			 db="db"
			 rows="3"
			 query="PRAGMA TABLE_INFO(LuodunTaulunNimi)">
		      </query>
		    </div>

		  </div>
		</aside>


                <p><strong><em>Kurssi-taulun luominen sarakkeiden tyypeillä</em></strong></p>

		<p>Luo taulu <code>Kurssi</code>, jolla on sarakkeet <code>kurssitunnus</code>, <code>nimi</code> ja <code>kuvaus</code>. Kurssitunnuksen tulee olla kokonaisluku, nimen merkkijono, ja kuvauksen merkkijono.</p>


		<div ng-controller="noTablesSqlController">

		  <query
		     db="db"
		     rows="3"
		     done="tableCreated">
		  </query>

		  <div ng-show="tableCreated">


		    <togglable content="taulut" db="db">
		      <table-info></table-info>
		    </togglable>

		    <p>Varmista vielä PRAGMA-komennolla, että sarakkeiden tyypit ovat halutut.</p>

		    <query
		       db="db"
		       rows="3">
		    </query>
		  </div>
		</div>


		<aside class="info">
		  <br/>
		  <h1>Tietokannanhallintajärjestelmien datatyyppejä</h1>

		  <p>Eri tietokannanhallintajärjestelmät kuten <code>SQLite</code>, <code>MySQL</code> ja <code>PostgreSQL</code> tarjoavat hieman erilaisia datatyyppejä ohjelmoijan käyttöön. Tutustu seuraaviin dokumentteihin, missä näistä kerrotaan enemmän:</p>


		  <ul>
		    <li><a href="https://www.sqlite.org/datatype3.html" target="_blank">https://www.sqlite.org/datatype3.html</a></li>
		    <li><a href="http://www.postgresql.org/docs/9.4/static/datatype.html" target="_blank">http://www.postgresql.org/docs/9.4/static/datatype.html</a></li>
		    <li><a href="http://www.w3schools.com/sql/sql_datatypes.asp" target="_blank">http://www.w3schools.com/sql/sql_datatypes.asp</a></li>
		  </ul>
		</aside>


		<h2>Rajoitteet ja avaimet</h2>

		<p>Kun olemme aiemmin luoneet tietokantakaavioita käsitekaavioista, olemme määritelleet tietokantatauluille yksilöivän <em>pääavaimen</em>. Pääavain on taulukohtainen tunniste, joka on uniikki jokaiselle taulun riville, jonka lisäksi sen arvo ei saa olla tyhjä (<em>null</em>) millään rivillä. Pääavaimeksi valitaan joko olemassaoleva taulun sarake, tai tauluun luodaan uusi sarake.</p>

		<p><strong><em>Pääavaimen määrittely</em></strong></p>

		<p>Pääavain määritellään tietokantataulun luonnin yhteydessä lisäämällä sarakkeen tyypin perään rajoite <code>PRIMARY KEY</code>. Tämä tarkoittaa, että sarakkeen arvo on uniikki, ja että se ei saa koskaan olla tyhjä. Täydennetään aiempaa opiskelijan määrittelyä siten, että opiskelijanumerosta tehdään Opiskelija-taulun pääavain</p>


<pre class="sh_sql">
CREATE TABLE Opiskelija
(
    opiskelijanumero integer PRIMARY KEY,
    nimi varchar(200),
    syntymävuosi date,
    pääaine varchar(50)
)
</pre>


		<div ng-controller="noTablesSqlController">

		  <p>Kokeillaan edelläolevaa komentoa käytännössä.</p>

		  <query
		     db="db"
		     rows="7"
		     done="tableCreated"
		     editable="false"
		     query="CREATE TABLE Opiskelija
(
    opiskelijanumero integer PRIMARY KEY,
    nimi varchar(200),
    syntymävuosi date,
    pääaine varchar(50)
)">
		  </query>

		  <div ng-show="tableCreated">

		    <togglable content="taulut" db="db">
		      <table-info></table-info>
		    </togglable>

		    <p>Lisätään seuraavaksi tietokantatauluun uusi opiskelija nimeltä <code>Ada Lovelace</code>. Seuraavalla komennolla vain tietokantataulun kenttään <code>nimi</code> asetetaan arvo.</p>

		    <query
		       db="db"
		       rows="3"
		       query="INSERT INTO Opiskelija (nimi) VALUES ('Ada Lovelace')"
		       done="studentInserted">
		    </query>
		  </div>

		  <div ng-show="studentInserted">
		    <p>Listaa nyt taulussa olevat opiskelijat. Mitä huomaat jos opiskelijoita lisätään tietokantatauluun enemmän?</p>

		    <query
		       db="db"
		       rows="3"
		       query="SELECT * FROM Opiskelija"
		       done="studentsListed">
		    </query>
		  </div>

		  <div ng-show="studentsListed">
		    <p>Koska tietokantatauluun on määritelty avain, joka on uniikki, ei taulun sarakkeessa <code>opiskelijanumero</code> voi olla kahta samaa arvoa. Kokeile tätä painamalla alla olevaa nappia ensin kerran -- jolloin opiskelija lisätään -- ja sitten vielä toisen kerran. Mitä virheviesti kertoo?</p>

		    <query
		       db="db"
		       rows="3"
		       query="INSERT INTO Opiskelija (opiskelijanumero, nimi)
    VALUES (999, 'Beezow Doo-Doo Zopittybop-Bop-Bop')">
		    </query>

		  </div>

		</div>


		<aside class="info">

		  <br/>

		  <h1>Pääavaimen arvojen automaattinen luonti</h1>

		  <p>Tietyt tietokannanhallintajärjestelmät tarjoavat tuen automaattiselle pääavaimen arvojen luomiselle. Esimerkiksi SQLite luo automaattisesti kokonaislukutyyppiselle sarakkeelle arvoja, jos sarake on määritelty pääavaimeksi, ja ohjelmoija ei tauluun tietoa lisätessään arvoja erikseen määrittele. Vastaava toiminnallisuus löytyy myös useista muista tietokannanhallintajärjestelmistä -- tutustu esimerkiksi <a href="https://mariadb.com/kb/en/mariadb/auto_increment/" target="_blank">MariaDB:n dokumentaatioon asiasta</a>.</p>

		</aside>

                <p><strong><em>Kurssi-taulun luominen sarakkeiden tyypeillä ja pääavaimella</em></strong></p>

		<p>Luo taulu <code>Kurssi</code>, jolla on sarakkeet <code>kurssitunnus</code>, <code>nimi</code> ja <code>kuvaus</code>. Kurssitunnuksen tulee olla kokonaisluku, nimen merkkijono, ja kuvauksen merkkijono. Tämän lisäksi, kurssitunnuksen tulee olla pääavain.</p>


		<div ng-controller="noTablesSqlController">

		  <query
		     db="db"
		     rows="6"
		     done="tableCreated">
		  </query>

		  <div ng-show="tableCreated">


		    <togglable content="taulut" db="db">
		      <table-info></table-info>
		    </togglable>

		    <p>Seuraavan kyselyn useampaan otteeseen suorittamisen pitäisi epäonnistua, sillä tietokantataulun kurssitunnus-sarakkeen pitäisi olla olla pääavain, ja sen takia uniikki. </p>

		    <query
		       db="db"
		       rows="3"
		       query="INSERT INTO Kurssi (kurssitunnus, nimi) VALUES (42, 'Meaning of Life')">
		    </query>
		  </div>
		</div>


                <p>Jokaisella taululla voi olla vain yksi määritelty pääavain. Joskus kuitenkin haluamme, että pääavain liittyy useampaan sarakkeeseen, jolloin sarakkeiden yhdistelmän tulee olla uniikki. Voimme esimerkiksi haluta rajoittaa opiskelijoiden kurssi-ilmoittautumisia siten, että jokainen opiskelija voi ilmoittautua vain kerran tietylle kurssille. Tämä onnistuisi kuvitteellisen <em>KurssiIlmoittautuminen</em>-taulun kautta siten, että taulun pääavaimena toimisi opiskelijanumeron ja kurssin yhdistelmä.</p>

<pre class="sh_sql">
CREATE TABLE KurssiIlmoittautuminen
(
    opiskelijanumero integer,
    kurssi integer,
    PRIMARY KEY (opiskelija, kurssi)
)
</pre>

                <p>Nyt taulussa KurssiIlmoittautuminen voi olla vain yksi samanlainen <code>opiskelijanumero</code>-<code>kurssi</code> -arvopari, jolloin opiskelija voi ilmoittautua kurssille vain kerran.</p>



		<aside class="info">
		  <br/>
		  <h1>Pääavaimen valinta.</h1>

		  <p>Tietokantataulun pääavaimen valinta on herättänyt paljon keskustelua. Alla on muutamia linkkejä teemaan liittyen:</p>

		  <ul>
		    <li><a href="http://www.techrepublic.com/article/the-great-primary-key-debate/" target="_blank">The great primary key debate</a></li>
		    <li><a href="http://www.agiledata.org/essays/keys.html" target="_blank">Choosing a primary key: Natural or surrogate?</a></li>
		    <li><a href="http://dba.stackexchange.com/questions/10383/sql-server-primary-keys-advice-to-my-whitepaper-needed" target="_blank">Tips for explaining primary keys to junior developers?</a></li>
		  </ul>
		</aside>

		<p><strong><em>Uniikkius ja arvon pakollinen määrittely</em></strong></em>

                <p>Tietokantataulun sarakkeille voidaan määritellä myös muita rajoitteita, kuten se, että sarakkeen arvon tulee olla uniikki, tai että sarakkeessa on pakko olla arvo. Sarakkeen uniikkius määritellään komennolla <code>UNIQUE</code>, joka seuraa tyyppiä. Vastaavasti se, että sarakkeessa on pakko olla arvo määritellään komennolla <code>NOT NULL</code>.</p>

		<p>Jos haluamme esimerkiksi lisätä Opiskelija-tauluun rajoitteet, missä määritellään se, että nimeä ja syntymäaikaa ei saa jättää määrittelemättä, lisätään niihin <code>NOT NULL</code> määreet.</p>

<pre class="sh_sql">
CREATE TABLE Opiskelija
(
    opiskelijanumero integer PRIMARY KEY,
    nimi varchar(200) NOT NULL,
    syntymävuosi date NOT NULL,
    pääaine varchar(50)
)
</pre>

                <p>Toisaalta, jos määrittelisimme ylläolevan lisäksi säännöt, joiden mukaan nimen ja syntymävuoden tulisi olla uniikkeja, olisi määrittely seuraava.</p>

<pre class="sh_sql">
CREATE TABLE Opiskelija
(
    opiskelijanumero integer PRIMARY KEY,
    nimi varchar(200) NOT NULL UNIQUE,
    syntymävuosi date NOT NULL UNIQUE,
    pääaine varchar(50)
)
</pre>

                <p>Tämä ei kuitenkaan olisi kovin fiksua, sillä yllä määriteltävässä taulussa yhdelläkään opiskelijalla ei saisi olla samaa nimeä jonkun toisen kanssa. Vastaavasti, sama syntymävuosi (tai aika) johtaisi virhetilanteeseen.</p>


		<aside class="info">
		  <br/>
		  <h1>CHECK</h1>

		  <p>Edellämainittujen rajoitteiden lisäksi käytössä on mm. rajoite <code>CHECK</code>, jonka avulla voidaan rajoittaa arvoja esimerkiksi tietylle arvovälille. Voimme esimerkiksi luoda Opiskelija-tauluun säännön, jonka mukaan jokaisen opiskelijanumeron tulee olla suurempi kuin 0.</p>

<pre class="sh_sql">
CREATE TABLE Opiskelija
(
    opiskelijanumero integer PRIMARY KEY CHECK (opiskelijanumero &gt; 0),
    nimi varchar(200) NOT NULL,
    syntymävuosi date NOT NULL,
    pääaine varchar(50)
)
</pre>

                  <p>Rajoitteet voidaan määritellä myös sarakemäärittelyiden jälkeen. Tämä on näppärää esimerkiksi silloin, jos rajoitteita on useampia. Tehdään erillinen tarkistus, joss varmistetaan, että jokainen nimi on yli 2 merkkiä pitkä, ja opiskelijanumero on aina suurempi kuin 0.</p>

<pre class="sh_sql">
CREATE TABLE Opiskelija
(
    opiskelijanumero integer PRIMARY KEY,
    nimi varchar(200) NOT NULL,
    syntymävuosi date NOT NULL,
    pääaine varchar(50),
    CONSTRAINT <em>saannonNimi</em> CHECK (opiskelijanumero &gt; 0 AND LENGTH(nimi) &gt; 2)
)
</pre>

		  <p><em>Funktion <code>LENGTH</code> kirjoitusasu riippuu järjestelmästä, esimerkiksi MySQL:ssä se kirjoitetaan muodossa <code>LEN</code>.</em></p>

		</aside>



		<p><strong><em>Viiteavainten määrittely</em></strong></p>

		<aside class="info">
		  <br/>
		  <h1>SQLite ja viiteavaimet</h1>

		  <p>Käytössämme olevan SQLiten kolmosversiossa viiteavaimiin liittyvät tarkistukset ovat oletuksena poissa päältä. Tarkastukset saadaan päälle seuraavalla komennolla:</p>

		  <pre class="sh_sql">PRAGMA foreign_keys = ON;</pre>

		  <p>Oletamme, että komento on suoritettu.</p>

		</aside>

                <p>Tietokantataulujen viiteavaimet ovat sarakkeita, joissa olevat arvot viittaavat toisissa tauluissa oleviin pääavaimiin. Tietokantataulua määriteltäessä viiteavaimet listataan sarakkeiden määrittelyn jälkeen. Jokaisen viiteavaimen yhteydessä kerrotaan sekä luotavan taulun sarake -- eli sarake, joka on viiteavain -- että taulu ja sarake, johon viiteavaimella viitataan. Viiteavaimen määrittely tapahtuu komennolla <code>FOREIGN KEY(<em>sarake</em>) REFERENCES <em>ViitattavaTaulu(viitattavaSarake)</em></code>.</p>

		<p>Jos tietokantataulut Opiskelija ja Kurssi ovat määritelty seuraavasti:</p>

<pre class="sh_sql">
CREATE TABLE Opiskelija
(
    opiskelijanumero integer PRIMARY KEY,
    nimi varchar(200) NOT NULL,
    syntymävuosi date NOT NULL,
    pääaine varchar(50)
);

CREATE TABLE Kurssi
(
    kurssitunnus integer PRIMARY KEY,
    nimi varchar(200) NOT NULL,
    kuvaus varchar(3000)
);</pre>

                <p>Voidaan taulu kurssisuoritus, joka viittaa sekä opiskelijaan, että kurssiin, määritellä seuraavasti.</p>

<pre class="sh_sql">
CREATE TABLE Kurssisuoritus
(
    opiskelija integer NOT NULL,
    kurssi integer NOT NULL,
    päivämäärä date NOT NULL,
    arvosana integer NOT NULL,
    opintopistemäärä integer NOT NULL,
    FOREIGN KEY(opiskelija) REFERENCES Opiskelija(opiskelijanumero),
    FOREIGN KEY(kurssi) REFERENCES Kurssi(kurssitunnus)
);
</pre>

 		<p>Viiteavaimet ovat siis sarakkeita siinä missä muutkin sarakkeet, mutta niille määritellään erikseen rajoitteet, jotka kertovat, että ne ovat viiteavaimia. Taulussa käytettävien viiteavainten määrä ei käytännössä ole rajattu -- voi olla, että niitä ei ole yhtäkään, tai niitä voi olla useita. Yllä viiteavainsarakkeille <code>opiskelija</code> ja <code>kurssi</code> on lisäksi määritelty <code>NOT NULL</code>-rajoitteet, joiden avulla määritellään että sarakkeiden arvot eivät saa jäädä tyhjiksi.</p>

		<div ng-controller="noTablesSqlController">

		  <p>Kokeillaan edellä nähtyä käytännössä. Luodaan ensin tietokantataulut Opiskelija ja Kurssi, sekä lisätään niihin muutama rivi.</p>

		  <query
		     db="db"
		     rows="20"
		     editable="false"
		     query="PRAGMA foreign_keys = ON;

CREATE TABLE Opiskelija (
    opiskelijanumero integer PRIMARY KEY,
    nimi varchar(200) NOT NULL,
    syntymävuosi date NOT NULL,
    pääaine varchar(50)
);

CREATE TABLE Kurssi (
    kurssitunnus integer PRIMARY KEY,
    nimi varchar(200) NOT NULL,
    kuvaus varchar(3000)
);

INSERT INTO Opiskelija (nimi, syntymävuosi) VALUES ('Ada', '1997');
INSERT INTO Opiskelija (nimi, syntymävuosi) VALUES ('Pihla', '1998');
INSERT INTO Kurssi (nimi) VALUES ('Ohpe');
INSERT INTO Kurssi (nimi) VALUES ('Tikape');"
		     done="tablesCreated">
		  </query>

		  <div ng-show="tablesCreated">

		    <p>Nyt käytössämme on taulut Opiskelija ja Kurssi, jonka lisäksi niissä on kummassakin muutama rivi. Luodaan seuraavaksi taulu Kurssisuoritus, jossa on viiteavaimet kumpaankin edellä mainittuun tauluun.</p>


		    <togglable content="taulut" db="db">
		      <table-info></table-info>
		    </togglable>

		    <query
		       db="db"
		       rows="10"
		       editable="false"
		       query="CREATE TABLE Kurssisuoritus
(
    opiskelija integer NOT NULL,
    kurssi integer NOT NULL,
    päivämäärä date NOT NULL,
    arvosana integer NOT NULL,
    opintopistemäärä integer NOT NULL,
    FOREIGN KEY(opiskelija) REFERENCES Opiskelija(opiskelijanumero),
    FOREIGN KEY(kurssi) REFERENCES Kurssi(kurssitunnus)
);"

		       done="kurssisuoritusCreated">
		    </query>
		  </div>


		  <div ng-show="kurssisuoritusCreated">

		    <p>Nyt käytössä on tietokantataulut Opiskelija, Kurssi, ja Kurssisuoritus. Kurssisuoritus-taulussa on kaksi viiteavainta -- toinen viittaa tauluun Opiskelija, ja toinen tauluun Kurssi. Tutki ensin taulujen Opiskelija ja Kurssi sisältöjä, ja lisää sen jälkeen tauluun Kurssisuoritus suoritusmerkintä kurssista Tikape opiskelijalle Ada. Voit kokeilla ensin mitä tapahtuu, jos et aseta viiteavaimia oikein.</p>

		    <query
		       db="db"
		       rows="3">
		    </query>
		  </div>
		</div>

		<p><strong><em>Tehtävän ja Kurssitehtävän lisääminen.</em></strong></p>

                <p>Harjoitellaan edellä nähtyjä asioita vielä hieman. Käytämme pohjana seuraavaa tietokantakaaviota.</p>

		<figure>
		  <img src="img/viikko3/tietokantakaavio-tehtavasuorituksella.png" alt="[Opiskelija|(pk) opiskelijanumero;nimi;syntymävuosi;pääaine]1-*[Kurssisuoritus|(fk) opiskelija: Opiskelija;(fk) kurssi: Kurssi;päivämäärä;arvosana;opintopistemäärä]
[Kurssisuoritus]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]
[Tehtävä|(pk) tunnus;nimi;kuvaus]1-*[Kurssitehtävä|(pk) tunnus; (fk) tehtävä: Tehtävä; (fk) kurssi: Kurssi]
[Kurssitehtävä]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]
[Tehtäväsuoritus|(fk) opiskelija: Opiskelija; (fk) tehtävä: Kurssitehtävä; suoritusaika]
[Tehtäväsuoritus]*-1[Opiskelija]
[Tehtäväsuoritus]*-1[Kurssitehtävä]"/>

		</figure>

                <p></p>

		<hr/>

                <p>Alla olevaan kyselylaatikkoon on määritelty kysely, minkä avulla luodaan tietokantataulu Kurssi sekä lisätään sinne kurssit Ohpe ja Tikape.</p>

		<div ng-controller="noTablesSqlController">

		  <query
		     db="db"
		     rows="11"
		     editable="false"
		     query="PRAGMA foreign_keys = ON;

CREATE TABLE Kurssi (
    kurssitunnus integer PRIMARY KEY,
    nimi varchar(200) NOT NULL,
    kuvaus varchar(3000)
);

INSERT INTO Kurssi (nimi) VALUES ('Ohpe');
INSERT INTO Kurssi (nimi) VALUES ('Tikape');"
		     done="tablesCreated">
		  </query>

		  <div ng-show="tablesCreated">

		    <p>Toteuta nyt taulut Kurssitehtävä ja Tehtävä siten, että niissä on määriteltynä sekä pääavaimet että viiteavaimet. Pohdi, missä järjestyksessä taulut tulee toteuttaa, jotta saat viiteavaimet määriteltyä oikein.</p>


		    <togglable content="taulut" db="db">
                      <table-info></table-info>
		    </togglable>


		    <query
		       db="db"
		       rows="9"
		       query=""
		       done="kurssiTehtavaAndTehtavaCreated">
		    </query>
		  </div>

		  <div ng-show="kurssiTehtavaAndTehtavaCreated">

		    <p>Lisää nyt Tehtävä-tauluun muutama rivi, ja määrittele olemassaoleville kursseille muutamia tehtäviä.</p>

		    <query
		       db="db"
		       rows="4">
		    </query>
		  </div>
		</div>



		<h2>Hakuja nopeuttavat indeksirakenteet</h2>


		<p>Tietokantatauluun kohdistuvissa kyselyissä hakua rajataan ehdoilla. Esimerkiksi kysely <code>SELECT * FROM <em>Taulu</em> WHERE <em>sarake</em> = 'haluttu'</code>, hakee kaikki taulussa olevat rivit, joissa annetun sarakkeen 'sarake' arvo on 'haluttu'. Oletuksena tietokantamoottori käy läpi kaikki rivit, ja valitsee niistä vain ne rivin, joissa sarakkeen arvo on haluttu. Jos rivejä on vaikkapa 100 miljoonaa, käydään niistä jokainen yksitellen läpi.</p>

		<p>Tietokantakyselyiden tehostamista on tutkittu paljon, ja tietokantamoottorit tarjoavat tyypillisesti erilaisia välineitä kyselyiden tehostamiseksi. Yksi väline on usein toistuvien hakujen tehostamiseen tarkoitettu <em>indeksi</em>, eli hakurakenne.</p>

		<p>Pohditaan tilannetta, missä edellisen 100 miljoonaa riviä sisältävän taulun lisäksi tietokannalla on erillinen hakurakenne usein käytetylle sarakkeelle. Hakurakenteessa sarakkeen arvot ovat järjestettynä. Tällöin, tiettyä arvoa haettaessa, voimme aloittaa keskimmäisestä arvosta -- jos haettava arvo on pienempi, tutkitaan "vasemmalla" olevaa puolikasta. Jos taas haettava arvo on suurempi, tutkitaan "oikealla" olevaa puolikasta. Alueen rajaaminen jatkuu niin pitkään, kunnes haettava arvo löytyy, tai rajaus päätyy tilanteeseen, missä tutkittavia arvoja ei enää ole. Tämä menetelmä -- <em>puolitushaku</em> tai <em>binäärihaku</em> lienee jo tuttu kurssilta Ohjelmoinnin perusteet.</p>

                <p>Jos rivejä on yhteensä miljardi, voidaan ne jakaa kahteen osaan noin <em>log<sub>2</sub> 1 000 000 000</em> kertaa, eli noin 30 kertaa. Jos oletamme, että arvoa ei löydy taulusta, tulee yhteensä tarkastella siis noin 30 riviä aiemman miljardin sijaan.</p>


		<aside class="info">

		  <br/>

		  <h1>Häh?</h1>
		  
		  <p>Kurssilla <em>Tietorakenteet ja algoritmit</em> tutustutaan erilaisiin hakurakenteisiin tarkemmin. Tietokantakursseista esimerkiksi kurssilla <em>Tietovarastot</em> tutustutaan tähän myös syvemmin.</p>

		</aside>
		

		<p><strong><em>Indeksin määrittely</em></strong></p>

                <p>Indeksin määrittely tietokantataulun sarakkeelle tapahtuu tietokantataulun luomisen jälkeen komennolla <code>CREATE INDEX</code>, jota seuraa uuden indeksin nimi, avainsana <code>ON</code>, ja sarakkeet, joille indeksi luodaan. Tietokantataulun pääavaimelle ja viiteavaimelle luodaan indeksit automaattisesti.</p>

		<p>Oletetaan, että haluaisimme hakea opiskelijoita pääaineen perusteella melko usein, jolloin rajauksen tehokkuudella on hieman väliä. Tehdään siis tauluun Opiskelija erillinen indeksi pääaine-sarakkeelle.</p>

<pre class="sh_sql">
CREATE INDEX idx_paaaine ON Opiskelija (pääaine);
</pre>

                <p>Indeksien nimentä alkaa tyypillisesti sanalla <code>idx</code>, jatkuu alaviivalla sekä sarakkeita kuvaavalla sopivalla nimellä. Jos indeksin haluaa määritellä useammalle sarakkeelle samaan aikaan, voi indeksoitavat sarakkeet listata pilkuilla toisistaan erotettuna.</p>



		<h2>Tietokantataulun muokkaaminen</h2>

		<p>Valitettava totuus on se, että vaikka tekisimme kuinka hienon tietokantasuunnitelman, tulee se muuttumaan ajan myötä erilaisten asiakkailta ja muilta sidosryhmiltä tulevien toiveiden ja tarpeiden perusteella. Tietokantaa ei kannata luoda täysin uudestaan jokaisen muutoksen perusteella, vaan sitä voi muokata <code>ALTER TABLE</code> -lausekkeilla -- esimerkiksi uusien sarakkeiden lisääminen tauluun on melko suoraviivaista.</p>

		<p>Tässä materiaalissa toistaiseksi käyttämämme tietokannanhallintajärjestelmä, SQLite, tukee <a href="http://sqlite.org/lang_altertable.html" target="_blank">vain muutamia</a> muokkausoperaatiota. Näistä kannattaa varmaan tuntea ainakin <code>ADD COLUMN</code>, joka lisää tietokantatauluun uuden sarakkeen. Tämä tehdään SQLitessä seuraavasti:</p>

<pre class="sh_sql">
ALTER TABLE Opiskelija ADD COLUMN kutsumanimi varchar(50);
</pre>

		<p><code>ALTER TABLE</code> -lausekkeiden kanssa voi käyttää myös rajoitteita suunnilleen vastaavasti kuten tietokantataulua luotaessa.</p>

		<p>Muiden tietokannanhallintajärjestelmien tarjoamia monipuolisempia vaihtoehtoja voit nähdä esimerkiksi <em>W3Schools</em>-sivustolla -- lue nyt heidän <a href="http://www.w3schools.com/sql/sql_alter.asp" target="_blank">ALTER TABLE</a> -oppaansa.</p>



		<h2>Väliaikaisten näkymien luominen</h2>


		<p>Ohjelmia suunniteltaessa ja rakentessa ohjelmoija pilkkoo ohjelman toiminnallisuutta pienempiin osiin muunmuassa metodien ja luokkien avulla. Tietokantakyselyitä toteuttaessa ohjelmoija vastaavasti voi pilkkoa tehtäväänsä osiin väliaikaisten näkymien avulla. Väliaikaiset näkymät ovat tallennettuja SQL-kyselyitä, joiden suorituksesta saatuja tulostauluja voidaan käyttää osana muita kyselyitä.</p>

		<p>Väliaikainen näkymä luodaan komennolla <code>CREATE VIEW <em>NäkymänNimi</em> AS <em>kysely</em></code>, missä <code>NäkymänNimi</code> on nimi, jonka perusteella väliaikaiseen näkymään pääsee käsiksi, ja <code>kysely</code> on <code>SELECT</code>-kysely, jonka suoritus tuottaa näkymän.</p>


		<div ng-controller="noTablesSqlController">

		  <p>Tutustutaan tähän pikaisesti. Luodaan ensin käyttöömme taulu <code>Kurssi</code>, jossa on kursseja.</p>

		  <query
		     db="db"
		     rows="11"
		     editable="false"
		     query="CREATE TABLE Kurssi (
    kurssitunnus integer PRIMARY KEY,
    nimi varchar(200) NOT NULL,
    kuvaus varchar(3000)
);

INSERT INTO Kurssi (nimi) VALUES ('Ohpe');
INSERT INTO Kurssi (nimi) VALUES ('Tikape');
INSERT INTO Kurssi (nimi) VALUES ('Otm');
INSERT INTO Kurssi (nimi) VALUES ('Ohja');"
		     done="tablesCreated">
		  </query>

		  <div ng-show="tablesCreated">

		    <p>Luodaan tämän jälkeen näkymä nimeltä <code>Ohjelmointikurssit</code>, missä on vain ohjelmoinnin perusteet ja ohjelmoinnin jatkokurssi.</p>


		    <togglable content="taulut" db="db">
                      <table-info></table-info>
		    </togglable>


		    <query
		       db="db"
		       rows="3"
                       editable="false"
		       query="CREATE VIEW Ohjelmointikurssit AS
    SELECT * FROM Kurssi WHERE nimi LIKE 'Oh%'"
		       done="viewCreated">
		    </query>
		  </div>

		  <div ng-show="viewCreated">

		    <p>Valitse nyt kaikki kurssit näkymästä Ohjelmointikurssit -- haku tapahtuu samalla tavalla kuin taulusta haettaessa.</p>

		    <query
		       db="db"
		       rows="4"
		       done="viewSelected">
		    </query>
		  </div>

		  <div ng-show="viewSelected">

		    <p>Poista näkymä lopuksi komennolla <code>DROP VIEW <em>NäkymänNimi</em></code>.</p>

		    <query
		       db="db"
		       rows="2">
		    </query>
		  </div>
		</div>



		<header>
		  <h1 id="viikko3">Viikko 3</h1>
		</header>


		<h1>Relaatiomalli</h1>

		<p>Kurssin alussa materiaali johdatteli lukijoita relaatiomalliin seuraavalla kuvauksella.</p>

		<aside class="info">
		  	
		  <p>Relaatiomallin perusajatus on tallennettavan tiedon jakaminen käsitteisiin sekä käsitteiden välisiin yhteyksiin. Jokaista käsitettä vastaa relaatiotietokannassa taulu, ja jokaiselle käsitteen ominaisuudelle eli attribuutille on taulussa oma sarake. Jokainen taulun rivi vastaa yhtä käsitteen ilmentymää, ja tietokantatauluja määriteltäessä taululle määritellään tyypillisesti myös <em>avain</em>, jonka perusteella kukin rivi -- eli käsitteen ilmentymä -- voidaan yksilöidä.</p>

		</aside>

		<p>Relaatiomallille on myös hieman formaalimpi määritelmä, johon tutustutaan seuraavaksi. Noudatamme tässä Edgar Coddin vuonna 1970 julkaistun artikkelin <a href="ext/codd-1970.pdf" target="_blank">"A Relational Model of Data for Large Shared Data Banks"</a> esitysasua.</p>

		<h2>Relaatio</h2>

		<p>Olkoon <em>S<sub>1</sub>, S<sub>2</sub>, ..., S<sub>n</sub></em> arvojoukkoja, joiden sisältämät arvot eivät ole välttämättä täysin erillisiä. Relaatio <em>R</em> on joukko <em>n</em> alkion kokoisia monikkoja. Jokaisen relaatiossa R olevan monikon ensimmäisen arvon tulee kuulua joukkoon <em>S<sub>1</sub></em>, toisen arvon kuulua joukkoon <em>S<sub>2</sub></em> jne.</p>

		<p>Relaatio <em>R</em> on siis osajoukko joukkojen <em>S<sub>1</sub>, S<sub>2</sub>, ..., S<sub>n</sub></em> välisestä karteesisesta tulosta <em>S<sub>1</sub> &#10799; S<sub>2</sub> &#10799; ... &#10799; S<sub>n</sub></em>.</p>

		<p>Relaatio esitetään tyypillisesti taulukkona, jolla on seuraavat ominaisuudet:</p>

		<ul>
		  <li>Jokainen taulukon rivi kuvaa yhtä relaation R monikkoa.</li>
		  <li>Taulukon rivien järjestyksellä ei ole väliä.</li>
		  <li>Jokainen taulukon rivi on erilainen.</li>
		  <li>Sarakkeiden järjestyksellä kuvaa relaation arvojoukkoja; ensimmäisen sarakkeen arvot tulevat arvojoukosta S<sub>1</sub>, toisen sarakkeen arvojoukosta S<sub>2</sub> jne..</li>
		  <li>Jokaiselle sarakkeelle annetaan annetaan nimi, joka kuvaa kunkin arvojoukon mahdollisia arvoja.</li> 
		</ul>

		<h2>Pääavain, viittaaminen ja viiteavain</h2>

		<p>Jokaisella relaatiolla on tyypillisesti yksi arvojoukko tai arvojoukkojen yhdistelmä, joiden arvojen perusteella voidaan yksilöidä relaation monikko. Tällaista arvojoukkoa tai arvojoukkojen yhdistelmää kutsutaan <em>pääavaimeksi</em>. Oleellinen ominaisuus relaatioissa on myös saman tai toisen relaation arvoihin <em>viittaaminen</em>. Tämä tapahtuu <em>viiteavaimen</em> avulla. Relaatiossa R oleva arvojoukko tai arvojoukkojen yhdistelmä, joka ei ole relaation R pääavain, mutta sisältää jonkun relaation pääavaimia, on viiteavain.</p>


		<aside class="info">
		  <br/>
		  <p><strong>Joukko-operaatiot ja kyselyt</strong></p>

		  <p>Koska relaatiot ovat joukkoja, voi niitä käsitellä joukko-operaatioiden avulla. Tutustu kyselyiden toteuttamiseen artikkelista <a href="ext/codd-1970.pdf" target="_blank">"A Relational Model of Data for Large Shared Data Banks"</a>.</p>

		</aside>


		<h1>Tietokannan normalisointi</h1>


		<p><em>Omenan (data) herkullisuudella, kuljetusvälineellä (tietokantasovellus ja palvelin), tai kaupassa tehtävällä asettelulla (sovelluksen käyttöliittymä) ei ole merkitystä jos omenoiden säilöntään (tietokantakaavio) ei ole kiinnitetty huomiota.</em> -- <a href="https://news.ycombinator.com/item?id=8839017" target="_blank">Anonyymi</a></p>


		<p>Tutustuimme aiemmin tietokannan suunnitteluun käsiteanalyysin kautta. Tutustutaan nyt täydentävään lähestymistapaan nimeltä tietokannan normalisointi (<em>database normalization</em>).</p>

		<p>Tietokannan normalisointi on askeleittainen lähestymistapa tiedon jakamiseen loogisiksi tietokantatauluiksi ja niiden sarakkeiksi. Pääpiirteittäin lopputavoite on sama kuin käsiteanalyysissä -- jokaisen taulun pitäisi liittyä tiettyyn aiheeseen, ja tauluun määritellään vain sarakkeita jotka liittyvät samaan aiheeseen. Lähestymistapa on kuitenkin toisenlainen: tietokannan normalisoinnissa tutkimme tiedon välisiä riippuvuuksia ja suhteita, ja etsimme sieltä epäkohtia. Epäkohdat tyypillisesti jaetaan useampaan osaan, esimerkiksi tauluiksi.</p>

		<p>Lähtökohtana tietokannan normalisoinnille ovat seuraavat relaatiomalliin liittyvät oletukset:</p>

		<ul>

		  <li>Jokaisen tietokantataulun sarakkeen nimen tulee olla uniikki. Tietokantataulussa ei siis saa olla kahta saman nimistä saraketta.</li>

		  <li>Jokaisen tietokantataulun sarakkeen tulee olla sellainen, että se sisältää korkeintaan yhden arvon. Yksittäisessä sarakkeen rivissä ei siis esimerkiksi saa säilöä listaa asioita.</li>

		  <li>Jokaisen tietyssä tietokantataulun sarakkeessa olevan arvon tulee olla saman tyyppinen. Eri riveillä, mutta samassa sarakkeessa ei siis saa olla esimerkiksi kokonaislukutyyppisiä arvoja ja merkkijonotyyppisiä arvoja.</li>

		  <li>Tietokantataulun sarakkeiden järjestyksen ei tule vaikuttaa tietoon. Sarakkeiden paikkaa tulee siis voida vaihtaa tarvittaessa.</li>
		  <li>Tietokantataulussa ei tule olla kahta tai useampaa täsmälleen samat arvot sisältävää riviä. Jos rivi esiintyy kerran, ei sen toistamisesta ole hyötyä.</li>

		  <li>Tietokantataulussa olevien rivien järjestyksellä ei tule olla merkitystä.</li>

		</ul>


		<p>Tietokannan normalisointiin liittyy useampia tavoitteita; (1) tiedon kopioiden minimointi, (2) tiedon muuttamiseen liittyvien ongelmien vähentäminen, ja (3) tietokantaan tehtävien kyselyiden yksinkertaistaminen. Käytetään esimerkkinä seuraavaa yhden taulun avulla määriteltyä asiakastietokantaa, joka kertoo asiakkaan tiedot, laskutusosoitteen, ja kuljetusosoitteen.</p>


		<figure>

		  <img src="img/viikko5/normalisoitava.png" alt="[Asiakas|(pk) asiakastunnus;etunimi;sukunimi;kayttajatunnus;ika;sukupuoli;yritys;puhelin_koti;puhelin_tyo;laskutusosoite_1;laskutusosoite_2;laskutusosoite_3;laskutus_kaupunki;laskutus_postinumero;kuljetusosoite_1;kuljetusosoite_2;kuljetusosoite_3;kuljetus_kaupunki;kuljetus_postinumero]">

		</figure>

		<p></p>

		<p>Tietokannan suunnitteluun liittyy useampia normaalimuotoja, joista seuraavaksi tutustutaan muutamaan.</p>


		<h2>Ensimmäinen normaalimuoto</h2>

		<p>Ensimmäisessä normaalimuodossa olevien tietokantataulujen sarakkeiden arvot eivät saa olla listoja, eivätkä sarakkeet saa sisältää toistuvia ryhmiä. Jos tietokantataulun sarake olisi esimerkiksi "puhelinnumerot", mikä voisi sisältää useamman puhelinnumeron, tulisi se pilkkoa osiin, aivan kuten toistuvat arvot.</p>

		<p>Edelläolevassa tietokantataulussa on toistuvia ryhmiä. Sekä puhelinnumero (kotipuhelin, työpuhelin) että osoite toistuu (kotiosoite, laskutusosoite). Emme tiedä sarakkeiden sisällöstä, joten emme tässä kohtaa osaa sanoa siitä, että onko sarakkeiden arvoissa jotain omituista -- jos tietokantataulussa olisi esimerkiksi sarakkeessa <em>yritys</em> useamman yrityksen nimi, tulisi se ottaa myös käsittelyyn.</p>

		<p>Tietokannan saa ensimmäiseen normaalimuotoon eriyttämällä puhelinnumeron ja osoitteen omiksi tauluikseen, joista on viittaus Asiakas-tauluun. Uusissa tauluissa on myös sarake tyyppi, jonka avulla määritellään onko esimerkiksi puhelinnumero koti- vai työnumero.</p>


		<figure>

		  <img src="img/viikko5/1nf.png" alt="[Asiakas| (pk) asiakastunnus;etunimi;sukunimi;kayttajatunnus;ika;sukupuoli;yritys]
[Puhelin| (fk) asiakas:Asiakas; puhelin_tyyppi; numero]
[Osoite| (fk) asiakas:Asiakas; osoite_tyyppi; osoite_1; osoite_2; osoite_3; kaupunki; postinumero]
[Asiakas]1-*[Puhelin]
[Asiakas]1-*[Osoite]">

		</figure>

		<p></p>

		<p>Jos tietokantataulun sarakkeiden arvoissa olisi esimerkiksi listoja -- vaikkapa yksittäisen rivin yritys-sarakkeessa useampia yrityksiä, tulisi siitä myös tehdä erillinen taulu.</p>


		<h2>Toinen normaalimuoto</h2>

		<p>Ensimmäisessä normaalimuodossa kyse on ensiaskeleista tietokannan rakenteen järkevöittämiseen. Muissa normaalimuodoissa käsite <em>funktionaalinen riippuvuus</em> sarakkeiden välillä on oleellinen:</p>

		<aside class="info">
		  <br/>
		  <p><strong>Funktionaalinen riippuvuus</strong></p>

		  <p>Sarake B on funktionaalisesti riippuvainen sarakkeesta A, jos sarakkeen A arvon perusteella voidaan yksikäsitteisesti selvittää sarakkeen B arvo. Tällöin kirjoitetaan <code>A -&gt; B</code>, ja sanotaan, että "sarake B on funktionaalisesti riippuvainen sarakkeesta A". Huom! A voi olla myös kokoelma sarakkeita!</p>

		  <p><em>Esimerkiksi taulun Henkilo sarake nimi on funktionaalisesti riippuvainen sarakkeesta henkilötunnus, sillä henkilötunnuksen perusteella voidaan yksikäsitteisesti selvittää nimi.</em></p>

		  <p>Selvittäminen voi tapahtua kyselyllä "SELECT DISTINCT b FROM Taulu WHERE a=tiedetty_arvo". Jos attribuutti <code>b</code> on funktionaalisesti riippuva <code>a</code>:sta, tuottaa ylläoleva kysely joko yhden tai ei yhtään tulosriviä, mutta ei koskaan enempää. Tämän ehdon on oltava voimassa aina, ei vain hetkellisesti.</p>

		  <p>Esimerkki: <code>Henkilo( (pk) id, nimi, henkilötunnus)</code> -- mitkä arvot ovat funktionaalisesti riippuvaisia toisistaan?</p>

		  <table class="table">

		    <thead>
		      <tr>
			<th>Henkilo</th>
			<th>A: id</th>
			<th>A: nimi</th>
			<th>A: henkilötunnus</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>B: id</td>
			<td>?</td>
			<td>?</td>
			<td>?</td>
		      </tr>
		      <tr>
 			<td>B: nimi</td>
			<td>?</td>
			<td>?</td>
			<td>?</td>
		      </tr>
		      <tr>
			<td>B: henkilötunnus</td>
			<td>?</td>
			<td>?</td>
			<td>?</td>
		      </tr>
		    </tbody>
		  </table>

		  <p>Sarakkeen perusteella voi aina määritellä itsensä. Esimerkiksi <code>id -&gt; id</code> on aina totta.</p>

		  <table class="table">

		    <thead>
		      <tr>
			<th>Henkilo</th>
			<th>A: id</th>
			<th>A: nimi</th>
			<th>A: henkilötunnus</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>B: id</td>
			<td>kyllä</td>
			<td>?</td>
			<td>?</td>
		      </tr>
		      <tr>
 			<td>B: nimi</td>
			<td>?</td>
			<td>kyllä</td>
			<td>?</td>
		      </tr>
		      <tr>
			<td>B: henkilötunnus</td>
			<td>?</td>
			<td>?</td>
			<td>kyllä</td>
		      </tr>
		    </tbody>
		  </table>

		  <p>Voimmeko tunnistaa nimen perusteella henkilön yksilöivän tunnisteen? Useammalla henkilöllä voi olla sama nimi, joten tämä ei pidä paikkansa. Voimmeko tunnistaa henkilötunnuksen perusteella henkilön yksilöivän tunnisteen? Henkilötunnus on uniikki, joten oletetaan että kyllä (tämä pätee tosin vain Suomessa..).</p>

		  <table class="table">

		    <thead>
		      <tr>
			<th>Henkilo</th>
			<th>A: id</th>
			<th>A: nimi</th>
			<th>A: henkilötunnus</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>B: id</td>
			<td>kyllä</td>
			<td>ei</td>
			<td>kyllä</td>
		      </tr>
		      <tr>
 			<td>B: nimi</td>
			<td>?</td>
			<td>kyllä</td>
			<td>?</td>
		      </tr>
		      <tr>
			<td>B: henkilötunnus</td>
			<td>?</td>
			<td>?</td>
			<td>kyllä</td>
		      </tr>
		    </tbody>
		  </table>

		  <p>Voiko yksilöivän avaimen perusteella tunnistaa henkilön nimen? Kyllä. </p>

		  <table class="table">

		    <thead>
		      <tr>
			<th>Henkilo</th>
			<th>A: id</th>
			<th>A: nimi</th>
			<th>A: henkilötunnus</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>B: id</td>
			<td>kyllä</td>
			<td>ei</td>
			<td>kyllä</td>
		      </tr>
		      <tr>
 			<td>B: nimi</td>
			<td>kyllä</td>
			<td>kyllä</td>
			<td>?</td>
		      </tr>
		      <tr>
			<td>B: henkilötunnus</td>
			<td>?</td>
			<td>?</td>
			<td>kyllä</td>
		      </tr>
		    </tbody>
		  </table>

		  <p>Loput jäävät harjoitustehtäväksi.</p>

		</aside>

		<p>Tietokanta on toisessa normaalimuodossa jos (1) se on ensimmäisessä normaalimuodossa ja (2) tietokantataulun sarakkeet (poislukien avaimet) ovat <em>funktionaalisesti riippuvaisia</em> tietokantataulun pääavaimesta.</p>

		<p>Jos tietokantataulun pääavain on määritelty yhden sarakkeen avulla, ovat kaikki sen sen sarakkeet automaattisesti funktionaalisesti riippuvaisia pääavaimesta. Käytännössä siis, jos taulu on ensimmäisessä normaalimuodossa ja sillä on yhden tai useamman sarakkeen kautta määritelty pääavain, on se automaattisesti toisessa normaalimuodossa.</p>


		<h2>Kolmas normaalimuoto</h2>

		<p>Tietokantataulu on kolmannessa normaalimuodossa jos (1) se on toisessa normaalimuodossa ja (2) siinä on vain sarakkeita, jotka eivät ole transitiivisesti riippuvaisia taulun pääavaimesta. </p>

		<aside class="info">
		  <br/>

		  <h1>Transitiivinen riippuvuus</h1>

		  <p>Transitiivisella riippuvuudella tarkoitetaan sitä, että sarake A on riippuvainen sarakkeesta B jonkun toisen sarakkeen kautta. Käytännössä sarake A on transitiivisesti riippuvainen sarakkeesta B, jos sarake A on riippuvainen sarakkeesta C, joka on riippuvainen sarakkeesta B. Tässä A, B ja C voivat sisältää myös useampia sarakkeita.</p>

		</aside>

		<p>Kaikkien tietokantataulun sarakkeiden tulee olla itsenäisiä ja riippumattomia muista pääavaimeen kuulumattomista kentistä. Jos tietokantataulusta tunnistetaan sarakkeita, jotka ovat transitiivisesti riippuvaisia pääavaimesta, eriytetään ne omaksi taulukseen.</p>

		<p>Esimerkiksi Osoite-taulussa oleva sarake kaupunki on transitiivisesti riippuvainen asiakkaasta postinumeron kautta. Voimme tällöin luoda uuden tietokantataulun <em>Postinumero</em>, joka sisältää jokaiseen postinumeroon liittyvät kaupungit.</p>

		<aside class="info">
		  <br/>
		  <p><strong>Boyce-Codd normaalimuoto</strong></p>
		  
		  <p>Muitakin normaalimuotoja on. Tutustu Wikipediasta <a href="https://en.wikipedia.org/wiki/Boyce%E2%80%93Codd_normal_form" target="_blank">Boyce-Codd -normaalimuotoon</a>.</p>

		</aside>
		

		<aside class="info">
		  <br/>
		  <h1>Normalisoida vaiko eikö normalisoida?</h1>

		  <p>Lue CodingHorror.com-blogista kirjoitus <a href="http://blog.codinghorror.com/maybe-normalizing-isnt-normal/" target="_blank">Maybe Normalizing Isn't Normal</a>. Milloin tietokannan normalisointi kannattaa, ja milloin ei?</p>

		  <p>Tutki myös seuraavaa Asiakas-taulun rakennetta. Mitkä edellämainituista normaalimuodoista taulu täyttää?</p>

		  <table class="table">
		    <thead>
		      <tr>
			<th>asiakastunnus</th>
			<th>etunimi</th>
			<th>sukunimi</th>
			<th>kayttajatunnus</th>
			<th>ika</th>
			<th>sukupuoli</th>
			<th>yritys</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>1</td>
			<td>arto</td>
			<td>vainee</td>
			<td>avi</td>
			<td>30</td>
			<td>M</td>
			<td>yliopisto</td>
		      </tr>
		      <tr>
			<td>2</td>
			<td>arto</td>
			<td>vainee</td>
			<td>avi</td>
			<td>30</td>
			<td>M</td>
			<td>rage-research</td>
		      </tr>
		    </tbody>
		  </table>

		</aside>


		<h1>Tietokantakyselyiden tekeminen ohjelmallisesti</h1>
		
                <p>Vaikka edelliset esimerkit tehtiin osana kurssimateriaalia, tehdään tietokantakyselyjä usein ohjelmallisesti tai suoraan tietokannanhallintajärjestelmässä, esimerkiksi konsolin kautta. Lähes jokainen ohjelmointikieli tarjoaa myös jonkinlaisen rajapinnan tietokantakyselyiden tekemiseen. Esimerkiksi Java-kielelle on määritelty yhtenäinen standardi tietokantakyselyiden tekemiseen, minkä avulla lähes sama koodi käy useamman tietokannan käyttöön.</p>


		<h2>Java ja JDBC</h2>

		<p>Java-kielessä on määritelty standardi (JDBC, <a href="https://en.wikipedia.org/wiki/Java_Database_Connectivity" target="_blank">Java Database Connectivity API</a>) tietokantayhteyden luomiseen, tietoa hakevien kyselyjen muodolle, sekä tietoa muokkaavien kyselyjen muodolle. Jotta JDBCn avulla voidaan ottaa yhteys tietokantaan, tulee käytössä olla tietokannanhallintajärjestelmäkohtainen JDBC-ajuri, jonka vastuulla on tietokantayhteyden luomiseen liittyvät yksityiskohdat sekä kyselytulosten muuntaminen JDBC-standardin mukaiseen muotoon.</p>

		<p>Oletetaan, että käytössämme on aiemmin näkemämme tietokantataulu Opiskelija:</p>

		<div class="data-table">
		  <h4>Opiskelija</h4>
		  <table class="table">
		    <thead>
		      <tr>
			<th>opiskelijanumero</th>
			<th>nimi</th>
			<th>syntymävuosi</th>
			<th>pääaine</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>9999999</td>
			<td>Pihla</td>
			<td>1997</td>
			<td>Tietojenkäsittelytiede</td>
		      </tr>
		      <tr>
 			<td>9999998</td>
			<td>Joni</td>
			<td>1993</td>
			<td>Tietojenkäsittelytiede</td>
		      </tr>
		      <tr>
			<td>...</td>
			<td></td>
			<td></td>
			<td></td>
		      </tr>
		    </tbody>
		  </table>
		</div>


		<p>JDBCn avulla kyselyn tekeminen tietokantatauluun tapahtuu seuraavasti -- olettaen, että käytössämme on sekä tietokanta, että tietokannan ajuri:</p>


<pre class="sh_java">
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

public class Main {
    public static void main(String[] args) throws Exception {
        // luodaan yhteys jdbc:n yli sqlite-tietokantaan nimeltä "tietokanta.db"
        Connection connection = DriverManager.getConnection("jdbc:sqlite:tietokanta.db");

        // luodaan olio, jonka avulla voidaan tehdä kyselyitä tietokantaan
        Statement statement = connection.createStatement();
        // tehdään tietokantaan SQL-kysely "SELECT * FROM Opiskelija", jolla haetaan
        // kaikki tiedot Opiskelija-taulusta -- tuloksena resultSet-olio
        ResultSet resultSet = statement.executeQuery("SELECT * FROM Opiskelija");

        // käydään tuloksena saadussa oliossa olevat rivit läpi -- next-komento hakee
        // aina seuraavan rivin, ja palauttaa true jos rivi löytyi
        while(resultSet.next()) {
            // haetaan nykyiseltä riviltä opiskelijanumero int-muodossa
            Integer opNro = resultSet.getInt("opiskelijanumero");
            // haetaan nykyiseltä riviltä nimi String-muodossa
            String nimi = resultSet.getString("nimi");
            // haetaan nykyiseltä riviltä syntymävuosi int-muodossa
            Integer syntVuosi = resultSet.getInt("syntymävuosi");
            // haetaan nykyiseltä riviltä pääaine String-muodossa
            String paaAine = resultSet.getString("pääaine");

            // tulostetaan tiedot
            System.out.println(opNro + "\t" + nimi + "\t" + syntVuosi + "\t" + paaAine);
        }

        // suljetaan lopulta yhteys tietokantaan
        connection.close();
    }
}</pre>

		<p>Ohjelman suoritus tuottaa (esimerkiksi) seuraavanlaisen tulostuksen:</p>

<pre>
999999	Pihla	1997	Tietojenkäsittelytiede
999998	Joni	1993	Tietojenkäsittelytiede
999997	Anna	1991	Matematiikka
999996	Krista	1990	Tietojenkäsittelytiede
...
</pre>


		<h2>Java-projekti ja JDBC-ajurin noutaminen</h2>

		<p>Jotta Javalla tehtävään projektiin saa tietokannan käyttöön, tulee ohjelmoijan noutaa tietokanta-ajuri. Ajurien noutaminen kannattaa hoitaa ns. riippuvuuksia hallinnoivan projektinhallintatyökalun, kuten Mavenin, avulla.</p>

		<p>Oletamme tässä, että käytössäsi on <a href="http://www.oracle.com/technetwork/articles/javase/jdk-netbeans-jsp-142931.html" target="_blank">NetBeans-ohjelmointiympäristö sekä Java 8</a>. Huomaa, että tietojenkäsittelytieteen laitoksen NetBeans 8:aan on oletuksena määritelty käyttöön Java 7. Käynnistä laitoksen koneilla TMCBeans.</p>

		<p><strong><em>Maven-projektin luominen NetBeansissa</em></strong></p>

		<p>Uuden Mavenia käyttävän projektin luominen NetBeansissa tapahtuu valitsemalla <em>File</em> -> <em>New Project</em> -> Kategoriaksi <em>Maven</em> ja projektiksi <em>Java Application</em>. Tämän jälkeen valitaan <em>Next</em>, ja täytetään projektin tiedot. Alla on esimerkki projektin tiedoista, projektin sijainti (Project location) on konekohtainen.</p>

		  <figure>
		    <img src="img/viikko3/nb-maven.png" alt="Project Name: tikape

Project Location: (omasta koneesta riippuva)

Group Id: tikape

Version: (saa olla kuten on aluksi)

Package: tikape"
/>
		    <figcaption>Maven-projektin asetukset</figcaption>
		  </figure>

		  <p>Tämän jälkeen painetaan Finish, ja projekti ilmestyy NetBeansin vasemmassa laidassa olevalle listalle. Etsi nyt projektin <em>Project Files</em> sisältä <code>pom.xml</code>-tiedosto -- se näyttää esimerkiksi seuraavalta:</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;tikape&lt;/groupId&gt;
    &lt;artifactId&gt;tikape&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
&lt;/project&gt;
</pre>


		<p>Koska käytössämme on Java 8, vaihdetaan sekä <code>maven.compiler.source</code> että <code>maven.compiler.source</code> -arvot muotoon <code>1.8</code>.</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;tikape&lt;/groupId&gt;
    &lt;artifactId&gt;tikape&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;<strong>1.8</strong>&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;<strong>1.8</strong>&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
&lt;/project&gt;
</pre>

		<p><strong><em>SQLite-ajurin lisäämien Maven-projektin riippuvuuksiin</em></strong></p>

		<p>Lisätään <em>riippuvuus</em> (dependency) SQLite-ajuriin osaksi sovellusta.</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;tikape&lt;/groupId&gt;
    &lt;artifactId&gt;tikape&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;<strong>1.8</strong>&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;<strong>1.8</strong>&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.xerial&lt;/groupId&gt;
            &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt;
            &lt;version&gt;3.8.11.2&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</pre>

		<p>Nyt kun NetBeans-projektista valitsee oikealla hiirennapilla <em>Dependencies</em> ja klikkaa <em>Download Declared Dependencies</em>, latautuu JDBC-ajuri projektin käyttöön.</p>


		<p><strong><em>Ensimmäinen tietokantaa käyttävä Maven-ohjelma</em></strong></p>

		<p>Avaa projektiin liittyvä <em>Source Packages</em>, ja klikkaa <em>tikape</em>-pakkausta oikealle hiirennapilla. Valitse tämän jälkeen <em>New</em> -> <em>Java Class</em>, jonka jälkeen avautuu valikko, missä voit antaa luokalle nimen. Anna luokan nimeksi <code>Main</code>.</p>

		<p>Avaa tiedosto tuplaklikkaamalla sitä. Muokkaa tiedostoa vielä siten, että se on seuraavan näköinen:</p>

<pre class="sh_java">
package tikape;

public class Main {

    public static void main(String[] args) throws Exception {

    }
}</pre>



		<figure>
		  <img src="img/viikko3/nb-main.png" alt="Projektin lähdekooditiedosto Main.java on avattuna."/>
		  <figcaption>Avattu projekti NetBeansissa</figcaption>
		</figure>


		<p>Lisää projektiin <em>import</em>-komento <code>import java.sql.*;</code>, joka hakee kaikki SQL-kyselyihin liittyvät Javan kirjastot.</p>


<pre class="sh_java">
package tikape;

import java.sql.*;

public class Main {

    public static void main(String[] args) throws Exception {

    }
}</pre>


		<p>Avataan seuraavaksi tietokantayhteys tietokantaan <em>testi.db</em>, ja tehdään siellä kysely "SELECT 1", jolla pyydetään tietokantaa palauttamaan luku 1 -- käytämme tätä yhteyden testaamiseksi. Jos yhteyden luominen onnistuu, tulostetaan "Hei tietokantamaailma!", muulloin "Yhteyden muodostaminen epäonnistui".</p>

<pre class="sh_java">
package tikape;

import java.sql.*;

public class Main {

    public static void main(String[] args) throws Exception {
        Connection connection = DriverManager.getConnection("jdbc:sqlite:testi.db");

        Statement statement = connection.createStatement();

        ResultSet resultSet = statement.executeQuery("SELECT 1");

        if(resultSet.next()) {
            System.out.println("Hei tietokantamaailma!");
        } else {
            System.out.println("Yhteyden muodostaminen epäonnistui.");
        }
    }
}</pre>

<pre>
Hei tietokantamaailma!</pre>

		<p>Kun suoritamme ohjelman ensimmäistä kertaa valitsemalla <em>Run</em> -> <em>Run Project</em>, SQLite luo puuttuvan tietokannan paikalle uuden tietokannan. Projektin kansiossa on nyt tiedosto <code>testi.db</code>, joka on tietokantamme.</p>


		<figure>
		  <img src="img/viikko3/nb-testidb.png" alt="Kun ohjelma on suoritettu ensimmäistä kertaa, tiedosto testi.db luodaan projektiin."/>
		  <figcaption>Tietokantatiedosto <em>testi.db</em> löytyy projektin kansiosta. Tiedostot löytyvät <em>Files</em>-välilehdeltä.</figcaption>
		</figure>


		<p><strong><em>Tietokantakyselyiden tekeminen</em></strong></p>

		<p>Osoitteessa <a href="dbs/vuokraamo.db">vuokraamo.db</a> löytyy kuvitteellisen moottoripyörävuokraamon tietokanta. Lataa se edellä tehdyn projektin juureen ja kokeile kyselyn tekemistä kyseiseen tietokantaan.</p>

		<p>Tietokannassa on tietokantataulu <code>Pyora</code>, jolla on sarakkeet <code>rekisterinumero</code> ja <code>merkki</code>. Jokaisen pyörän rekisterinumeron ja merkin tulostaminen tapahtuu seuraavasti -- huomaa myös, että olemme vaihtaneet käytössä olevaa tietokantaa.<p>

<pre class="sh_java">
Connection connection = DriverManager.getConnection("jdbc:sqlite:vuokraamo.db");

Statement stmt = connection.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM Pyora;");

while (rs.next()) {
    String rekisterinumero = rs.getString("rekisterinumero");
    String merkki = rs.getString("merkki");

    System.out.println(rekisterinumero + " " + merkki);
}

stmt.close();
rs.close();

connection.close();</pre>

		<p>Käydään ylläoleva ohjelmakoodi läpi askeleittain.</p>

		<ol>
		  <li><p>Luomme ensin JDBC-yhteyden tietokantaan <em>vuokraamo.db</em>.
<pre class="sh_java">
Connection connection = DriverManager.getConnection("jdbc:sqlite:vuokraamo.db");</pre>
</p>
		  </li>

		  <li><p>Kyselyn tekeminen tapahtuu pyytämällä yhteydeltä <em>Statement</em>-oliota, jota käytetään kyselyn tekemiseen ja tulosten pyytämiseen. Metodi <em>executeQuery</em> suorittaa parametrina annettavan SQL-kyselyn, ja palauttaa tulokset sisältävän <em>ResultSet</em>-olion.

<pre class="sh_java">
Statement statement = connection.createStatement();
ResultSet resultSet = statement.executeQuery("SELECT * FROM Pyora;");</pre>
</p></li>
		    <li><p>Tämän jälkeen ResultSet-oliossa olevat tulokset käydään läpi. Metodia next() kutsumalla siirrytään kyselyn palauttamissa tulosriveissä eteenpäin. Kultakin riviltä voi kysyä sarakeotsikon perusteella solun arvoa. Esimerkiksi kutsu getString("rekisterinumero") palauttaa kyseisellä rivillä olevan sarakkeen "rekisterinumero" arvon String-tyyppisenä.

<pre class="sh_java">
while(resultSet.next()) {
    String rekisterinumero = rs.getString("rekisterinumero");
    String merkki = rs.getString("merkki");

    System.out.println(rekisterinumero + " " + merkki);
}</pre>
</p></li>
		    <li><p>Kun kyselyn vastauksena saadut rivit on käyty läpi, eikä niitä enää tarvita, vapautetaan niihin liittyvät resurssit.

<pre class="sh_java">
stmt.close();
rs.close();
</pre></p></li>


		    <li><p>Lopulta tietokantayhteys suljetaan.

<pre class="sh_java">
connection.close();</pre>
</p></li>
		</ol>


		<p><strong><em>Päivityskyselyiden tekeminen</em></strong></p>

		<p>Kyselyt kuten rivien lisääminen ja poistaminen onnistuu myös ohjelmallisesti. Tällöin tuloksessa ei kuitenkaan ole erillistä ResultSet-oliota, vaan luku, joka kertoo kyselyn muuttaneiden rivien määrän. Allaoleva ohjelmakoodi lisää tietokantaan uuden pyörän.</p>

<pre class="sh_java">
Connection connection = DriverManager.getConnection("jdbc:sqlite:vuokraamo.db");

Statement stmt = connection.createStatement();
int changes = stmt.executeUpdate("INSERT INTO Pyora (rekisterinumero, merkki) VALUES ('RIP-34', 'Jopo');");

System.out.println("Kyselyn vaikuttamia rivejä: " + changes);
stmt.close();

connection.close();</pre>



		<aside class="info">
		  <br/>

		  <h1>SQL-injektiot</h1>

		  <p>Suurin osa olemassaolevista sovelluksista liittyy tietoon: tiedon hakemiseen tietokannasta, tiedon muokkaamiseen ja näyttämiseen, ja tiedon tallentamiseen tietokantaan. Jos ulkopuolinen henkilö voi vaikuttaa tietokoneelle annettavien SQL-kyselyiden sisältöön, on myös mahdollista, että hän pääsee vaikuttamaan näytettävään tietoon sekä tietokannassa suoritettuihin kyselyihin.</p>

		  <p>SQL-injektio on tekniikka, millä sovellukselle annetaan komentoja, joita sille ei pitäisi pystyä antamaan. Oletetaan esimerkiksi että seuraava sovellus suorittaa kirjautumisen tarkistamalla onko suoritettavan tietokantakyselyn tulos tyhjä:</p>

<pre class="sh_java">
// ...
String nimi = "nimi";
String salasana = "salasana";

String kysely = "SELECT * FROM User WHERE username = '"
                           + nimi + "' AND password = '" + salasana + "'";
// ...</pre>

		  <p>Vaikka kysely toimii siinä mielessä oikein, että se ei palauta yhtäkään riviä, jos tietokannasta ei löydy annetulla käyttäjätunnuksella ja salasanalla tunnettua henkilöä, on se kuitenkin hieman ongelmallinen. Jos käyttäjä antaa käyttäjänimen <code>' OR '1' = '1' OR '1' = '1</code>, tulee tietokannassa suoritettava kysely olemaan <code>SELECT * FROM User WHERE username = 'nimi' OR '1' = '1' OR '1' = '1' AND password = 'salasana'</code>. Koska '1' on '1', palautuu vastauksessa kaikki rivit.</p>

		  <p>SQL-injektioita voi luonnollisesti tehdä myös muunlaisiin kyselyihin. Web-sarjakuva <a href="http://xkcd.com/" target="_blank">xkcd</a> kuvastaa tätä ilmiötä hyvin <em>Exploits of a Mom</em>-sarjakuvallaan.</p>

		  <figure>

		    <img src="http://imgs.xkcd.com/comics/exploits_of_a_mom.png" alt="School: Hi, this is your son's school. We're having some computer trouble.

Mom: Oh, dear -- Did he break something?

School: In a way. Did you really name your son Robert'); DROP TABLE Students;--?

Mom: Oh. Yes. Little Bobby Tables we call him.

School: Well, we've lost this year's student records. I hope you're happy.

Mom: And I hope you've learned to sanitize your database inputs."/>

		    <figcaption>http://xkcd.com/327/ -- Exploits of a Mom. </figcaption>

		  </figure>

		</aside>

		<aside class="info">
		  <br/>

		  <h1>Salasanan talletus tietokantaan</h1>

		  <p>Joskus luotavalla sovelluksella on käyttäjiä, joiden kirjautumistiedot halutaan tallentaa tietokantaan. Tällä kurssilla tähän ei paneuduta sen tarkemmin, mutta on hyvä tietää että hyviin tapoihin kuuluu olla tallentamatta itse salasanoja tietokantaan. Sen sijaan, suositeltavaa on:</p>

		  <ol>
		    <li>Lisätä salasanaan niin sanottu <a href="https://en.wikipedia.org/wiki/Salt_(cryptography)">suola</a> (pitkä satunnainen merkkijono).</li>
		    <li>Ajaa yhdistetty salasana ja suola kryptografisesti <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function#Cryptographic_hash_algorithms">turvallisen</a> tiivistefunktion läpi.</li>
		    <li>Tallettaa suola ja saatu tulos tietokantaan.</li>
		  </ol>

		  <p>Näin talletettua merkkijonoa ei enää saa helposti palautettua alkuperäiseen salasanaan.</p>

		  <p>Kirjautumisvaiheessa annettu salasana koodataan samalla tavalla ja tulosta verrataan tietokantaan talletettuun merkkijonoon.</p>

		  <p>Jos salasanojen käytölle on tarvetta, kannattaa myös tarkistaa käytetyn ohjelmointikielen mahdollisesti tarjoamat valmiit ominaisuudet salasanojen käsittelyä varten.</p>

		</aside>



                <h2>Vastuiden eriyttäminen ja debug-viestien tulostaminen</h2>


		<p>Tietokantaa ohjelmallisesti käytettäessä kannattaa tietokantalogiikka ja sovelluslogiikka eriyttää toisistaan. Esimerkiksi tietokanta-ajurin hakeminen ja yhteyden luominen sopii hyvin erillisen tietokantaluokan vastuulle, ja sovelluskehittäjän työtä helpottaa, jos ohjelma mahdollistaa viestien tulostuksen. Samalla myös tietokannassa olevia käsitteitä on kätevä esittää luokkien avulla.</p>

		<p>Pohditaan tätä seuraavaksi moottoripyörävuokraamoesimerkin ohjelmallisen käsittelyn kautta.</p>


		<p><strong><em>Koodissa on käsite, tehdään siitä olio (déjà-vu)</em></strong></p>

		<p>Moottoripyörävuokraamossa on pyöriä, joihin liittyy rekisterinumero ja merkki. Tehdään käsitteelle luokka <code>Pyora</code>, jolla on rekisterinumero ja merkki.</p>

<pre class="sh_java">
package tikape;

public class Pyora {

    private String rekisterinumero;
    private String merkki;

    public Pyora(String rekisterinumero, String merkki) {
        this.rekisterinumero = rekisterinumero;
        this.merkki = merkki;
    }

    public String getRekisterinumero() {
        return rekisterinumero;
    }

    public void setRekisterinumero(String rekisterinumero) {
        this.rekisterinumero = rekisterinumero;
    }

    public String getMerkki() {
        return merkki;
    }

    public void setMerkki(String merkki) {
        this.merkki = merkki;
    }
}</pre>

		<p>Luokasta <em>Pyora</em> voi tehdä uusia ilmentymiä konstruktorin avulla, joka saa ensimmäiseksi parametrikseen rekisterinumeron, ja toiseksi parametriksi merkin.</p>

<pre class="sh_java">
Pyora p = new Pyora("23-BC", "Royal Enfield");
System.out.println(p.getRekisterinumero());
System.out.println(p.getMerkki());
</pre>

<pre>
23-BC
Royal Enfield
</pre>


		<p><strong><em>Luodaan olioita ResultSetissä olevista riveistä</em></strong></p>

		<p>Loimme juuri luokan kuvastamaan Pyora-tietokannan rivejä. Luodaan seuraavaksi ohjelmakoodi, joka lukee tietokannan ja muuntaa tietokannan rivit olioiksi.</p>

<pre class="sh_java">
Connection connection = DriverManager.getConnection("jdbc:sqlite:vuokraamo.db");

Statement stmt = connection.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM Pyora;");

List&lt;Pyora&gt; pyorat = new ArrayList&lt;&gt;();

while (rs.next()) {
    String rekisterinumero = rs.getString("rekisterinumero");
    String merkki = rs.getString("merkki");

    pyorat.add(new Pyora(rekisterinumero, merkki));
}

stmt.close();
rs.close();

connection.close();

// pyorat-listalla on kaikki Pyora-tietokantataulun rivit pyora-olioina
</pre>


<!--

		<p><strong><em>Paremmin!</em></strong></p>

                <p>Edellinen esimerkki sitoo meidät Pyora-tietokannan ja Pyora-olion käyttöön. Entäpä jos haluaisimme hakea tietokannasta lähes minkälaisia olioita?</p>
 
                <p>Luodaan rajapinta <em>Collector</em>, jonka tehtävänä on muuttaa mikä tahansa tulosrivi olioksi. Teemme rajapinnasta geneerisen, eli rajapinnalle voidaan määritellä luotavan olion tyyppi lennosta.</p>

<pre class="sh_java">
package tikape;

import java.sql.*;

public interface Collector&lt;T&gt; {

    T collect(ResultSet rs) throws SQLException;

}</pre>

                <aside class="info">
                  <br/>
                  <h1>Tyyppiparametri?</h1>

                  <p>Javassa on mahdollista määritellä luokka siten, että sille annetaan vasta olion luonnin yhteydessä tyyppiparametreja. Esimerkiksi ArrayList toimii näin. ArrayListille annetaan tyyppiparametrina tallennettavan arvon tyyppi. Alla luodaan erityyppisiä arvoja tallentavia ArrayList-olioita.</p>

<pre class="sh_java">
// lista, joka käsittelee kokonaislukuja
ArrayList&lt;Integer&gt; kokonaislukulista = new ArrayList&lt;&gt;();
// lista, joka käsittelee merkkijonoja
ArrayList&lt;String&gt; merkkijonolista = new ArrayList&lt;&gt;();
// lista, joka käsittelee Pyora-olioita
ArrayList&lt;Pyora&gt; pyoralista = new ArrayList&lt;&gt;();
</pre>

                </aside>

                <p>Esimerkiksi pyörien luominen kyselyrivistä onnistuisi seuraavanlaisen <em>Collector</em>-rajapinnan toteuttavan olion avulla.</p>

<pre class="sh_java">
package tikape;

import java.sql.*;

public class Pyorakeraaja implements Collector&lt;Pyora&gt; {

    @Override
    public Pyora collect(ResultSet rs) throws SQLException {
        String reknro = rs.getString("rekisterinumero");
        String merkki = rs.getString("merkki");

        return new Pyora(reknro, merkki);
    }
}</pre>


                <p><strong><em>Tietokantaluokan luominen</em></strong></p>


		<p>Luodaan seuraavaksi konkreettinen tietokantaluokka, joka ottaa yhteyden tietokantaan, sekä käyttää aiemmin luomaamme Collector-rajapintaa kyselyn tulosten hakemiseksi.</p>

<pre class="sh_java">
package tikape;

import java.sql.*;
import java.util.*;

public class Database&lt;T&gt; {

    private boolean debug;
    private Connection connection;

    public Database(String address) throws Exception {
        this.connection = DriverManager.getConnection(address);
    }

    public void setDebugMode(boolean d) {
        debug = d;
    }

    public List&lt;T&gt; queryAndCollect(String query, Collector&lt;T&gt; col) throws SQLException {
        List&lt;T&gt; rows = new ArrayList&lt;&gt;();
        Statement stmt = connection.createStatement();
        ResultSet rs = stmt.executeQuery(query);

        while (rs.next()) {
            if (debug) {
                System.out.println("---");
                System.out.println(query);
                debug(rs);
                System.out.println("---");
            }

            rows.add(col.collect(rs));
        }

        rs.close();
        stmt.close();
        return rows;
    }

    private void debug(ResultSet rs) throws SQLException {
        int columns = rs.getMetaData().getColumnCount();
        for (int i = 0; i &lt; columns; i++) {
            System.out.print(
                    rs.getObject(i + 1) + ":"
                    + rs.getMetaData().getColumnName(i + 1) + "  ");
        }

        System.out.println();
    }
}</pre>

		<p>Tietokannan konkreettinen käyttö tapahtuu seuraavasti:</p>

<pre class="sh_java">
Database database = new Database("jdbc:sqlite:vuokraamo.db");
List&lt;Pyora&gt; pyorat = database.queryAndCollect("SELECT * FROM Pyora", new Pyorakeraaja());

for (Pyora pyora : pyorat) {
    System.out.println(pyora.getMerkki());
}</pre>


		<p>Tärkeää on myös debug-viestien hyödyntäminen ongelmatapauksissa sekä sovellusta kehitettäessä. Debug-viestit saa tietokantaan päälle metodilla <code>database.setDebugMode(true);</code>.</p>

<pre class="sh_java">
Database database = new Database("jdbc:sqlite:vuokraamo.db");
database.setDebugMode(true);

List&lt;Pyora&gt; pyorat = database.queryAndCollect("SELECT * FROM Pyora", new Pyorakeraaja());

for (Pyora pyora : pyorat) {
    System.out.println(pyora.getMerkki());
}</pre>

                <aside class="info">
		  <br/>
		  <h1>Java 8 ja anonyymit funktiot</h1>

		  <p>Aiemmin luomamme Pyorakeraaja-luokan voi jättää luomatta. Aiemmissa Javan versioissa olemme voineet tehdä seuraavasti:</p>

<pre class="sh_java">
Database database = new Database("jdbc:sqlite:vuokraamo.db");
List&lt;Pyora&gt; pyorat = database.queryAndCollect("SELECT * FROM Pyora", new Collector&lt;Pyora&gt;() {

    @Override
    public Pyora collect(ResultSet rs) throws SQLException {
        String reknro = rs.getString("rekisterinumero");
        String merkki = rs.getString("merkki");

        return new Pyora(reknro, merkki);
    }
});

for (Pyora pyora : pyorat) {
    System.out.println(pyora.getMerkki());
}</pre>

		  <p>Olemme siis voineet luoda Collector-rajapinnalle toteutuksen ilman erillista luokkamäärittelyä. Java 8 keventää tätä syntaksia hieman, jolloin voimme sanoa myös seuraavasti:</p>

<pre class="sh_java">
Database database = new Database("jdbc:sqlite:vuokraamo.db");
List&lt;Pyora&gt; pyorat = database.queryAndCollect("SELECT * FROM Pyora", rs -> {
    String reknro = rs.getString("rekisterinumero");
    String merkki = rs.getString("merkki");

    return new Pyora(reknro, merkki);
});

for (Pyora pyora : pyorat) {
    System.out.println(pyora.getMerkki());
}</pre>

		<p>Ylläolevassa esimerkissä metodi queryAndCollect saa parametrinaan kyselyn ja rajapintatoteutuksen rungon. Java päättelee luokan Database perusteella minkä rajapintatoteutuksen runkoa olemme määrittelemässä. Tässä mahdollisuuksia on vain yksi, ja komento</p>

<pre class="sh_java">
rs -> {
    String reknro = rs.getString("rekisterinumero");
    String merkki = rs.getString("merkki");

    return new Pyora(reknro, merkki);
}
</pre>

                <p>Muuttuu ohjelman sisällä aiemmin näkemäämme muotoon:</p>

<pre class="sh_java">
 new Collector&lt;Pyora&gt;() {

    @Override
    public Pyora collect(ResultSet rs) throws SQLException {
        String reknro = rs.getString("rekisterinumero");
        String merkki = rs.getString("merkki");

        return new Pyora(reknro, merkki);
    }
}
</pre>

                <p>Jos kokonaisuuden voi tehdä yhdellä rivillä, ei aaltosulkeita eikä erillistä return-komentoa tarvita.</p>
<pre class="sh_java">
rs -> new Pyora(rs.getString("rekisterinumero"), rs.getString("merkki"))
</pre>

<pre class="sh_java">
Database database = new Database("jdbc:sqlite:vuokraamo.db");
List&lt;Pyora&gt; pyorat = database.queryAndCollect("SELECT * FROM Pyora",
                                rs -> new Pyora(rs.getString("rekisterinumero"), rs.getString("merkki")));

for (Pyora pyora : pyorat) {
    System.out.println(pyora.getMerkki());
}</pre>

                <p>Melko näppärää.</p>

                </aside>



		<p><strong><em>Päivityskyselyiden lisääminen</em></strong></p>

		<p>Edellä luotu tietokantaluokkamme ei vielä kuitenkaan osaa tehdä päivityskyselyitä. Lisätään mahdollisuus päivityskyselyiden tekemiseen.</p>

<pre class="sh_java">
package tikape;

import java.sql.*;
import java.util.*;

public class Database&lt;T&gt; {

// ...

    public int update(String updateQuery) throws SQLException {
        Statement stmt = connection.createStatement();
        int changes = stmt.executeUpdate(updateQuery);

        if(debug) {
            System.out.println("---");
            System.out.println(updateQuery);
            System.out.println("Changed rows: " + changes);
            System.out.println("---");
        }
        stmt.close();

        return changes;
    }

// ...
}</pre>


		<p>Nyt myös päivityskyselyt onnistuvat.</p>

<pre class="sh_java">
Database database = new Database("jdbc:sqlite:vuokraamo.db");
database.setDebugMode(true);

database.update("INSERT INTO Pyora (rekisterinumero, merkki) VALUES ('AKU-313', 'Belchfire Runabout')");

List&lt;Pyora&gt; pyorat = database.queryAndCollect("SELECT * FROM Pyora",
                                rs -> new Pyora(rs.getString("rekisterinumero"), rs.getString("merkki")));

for (Pyora pyora : pyorat) {
    System.out.println(pyora.getMerkki());
}</pre>


-->


		<h2>Parameterisoidut kyselyt (Prepared Statement)</h2>
 
                <p>Tietokannan käyttämiseen tarkoitetut rajapinnat -- kuten tällä sivulla käytettävä <a href="https://github.com/kripken/sql.js/" target="_blank">sql.js</a> -- tyypillisesti rajoittavat tietokantaan tehtäviä kyselyitä. Suoran kyselyn tekeminen muodossa <code>DELETE FROM Opiskelija WHERE nimi = 'Gandhi'</code> ei ole aina mahdollista, vaan kysely määritellään parametrin avulla -- esimerkiksi <code>DELETE FROM Opiskelija WHERE nimi = ?</code>, missä parametri annetaan kyselylle erikseen.</p>

		<p>Prepared Statement-kyselyt ovat valmiiksi määriteltyjä kyselyitä, joissa kyselyissä käytettävät arvot annetaan parametreina. Valmiita kyselyitä käyttämällä estetään merkittävä osa SQL-injektioista, sillä parametreja käytettäessä varmistetaan että parametrien arvot käsitellään tiettyyn kenttään liittyvänä datana -- parametrit eivät siis "vuoda yli".</p>

		<p>Valmiit kyselyt määritellään Connection-olion prepareStatement-metodin avulla. Metodi palauttaa PreparedStatement-olion, johon kyselyn käyttämät arvot määritellään parametreina. Esimerkiksi SQL-injektioesimerkissä oleva kysely luodaan valmiiden kyselyiden avulla seuraavasti:</p>

<pre class="sh_java">
// ...
String name = "nimi";
String password = "kala";

PreparedStatement statement =
    connection.prepareStatement("SELECT * FROM User WHERE username = ? AND password = ?");

statement.setString(1, name);
statement.setString(2, password);

ResultSet resultSet = statement.executeQuery();
// ...</pre>

		<p>Vastaavasti tietokantaa muokkaavan kyselyn voi tehdä seuraavasti (alla oletetaan että taulussa User on vain kaksi saraketta):</p>


<pre class="sh_java">
// ...
String name = "nimi";
String password = "kala";

PreparedStatement statement =
    connection.prepareStatement("INSERT INTO User VALUES (?, ?)");

statement.setString(1, name);
statement.setString(2, password);

statement.execute();
// ...</pre>


                <aside class="info">
		  <br/>
		  <h1>Prepared Statement ja indeksien numerointi</h1>

		  <p>Tietojenkäsittelytieteilijöille epätyypillisesti kyselyissä käytettävien parametrien indeksit alkavat numerosta 1.</p>

		</aside>


		<p>Prepared Statement-kyselyitä voi käyttää edellisessä luvussa toteutetun tietokanta-abstraktion kautta. Toteutetaan tällöin päivitys- ja kyselymetodit sellaisina, että niille annetaan kysely merkkijonona sekä ennalta määrittelemätön määrä parametreja, jotka lisätään kyselyyn kyselyä muodostettaessa.</p>

<pre class="sh_java">
public int update(String updateQuery, Object... params) throws SQLException {
    PreparedStatement stmt = connection.prepareStatement(updateQuery);

    for (int i = 0; i &lt; params.length; i++) {
        stmt.setObject(i + 1, params[i]);
    }

    int changes = stmt.executeUpdate();

    if (debug) {
        System.out.println("---");
        System.out.println(updateQuery);
        System.out.println("Changed rows: " + changes);
        System.out.println("---");
    }
    stmt.close();

    return changes;
}</pre>

<!--
		<p>Vastaavasti myös olioita kyselystä muodostava olio voidaan toteuttaa PreparedStatement-kyselyn kautta.</p>

<pre class="sh_java">
public List&lt;T&gt; queryAndCollect(String query, Collector&lt;T&gt; col, Object... params) throws SQLException {
    if (debug) {
        System.out.println("---");
        System.out.println("Executing: " + query);
        System.out.println("---");
    }

    PreparedStatement stmt = connection.prepareStatement(query);
    for (int i = 0; i &lt; params.length; i++) {
        stmt.setObject(i + 1, params[i]);
    }

    ResultSet rs = stmt.executeQuery();

    List&lt;T&gt; rows = new ArrayList&lt;&gt;();
    while (rs.next()) {
        if (debug) {
            System.out.println("---");
            System.out.println(query);
            debug(rs);
            System.out.println("---");
        }

        rows.add(col.collect(rs));
    }

    rs.close();
    stmt.close();

    return rows;
}</pre>

-->

                <h2>Syötteen validointi</h2>


		<p>Käyttäjät voivat syöttää vahingossa (tai pahantahtoisesti) sovellukseen tietoa joka rikkoo sovelluksen toiminnan. Myös muilta sovelluksilta tuleva syöte saattaa olla vääränlaista. Ongelmien estämiseksi kaikki sovellukseen tuleva syöte on syytä <i>validoida</i>, eli tarkistaa että se on sellaista mitä sovellus odottaa.</p>

		<p>Tietokantarajapinnassa tehtävien parameterisoitujen kyselyiden lisäksi sovelluksessa on siis syytä varmistaa mitään syötettä vastaanottaessa onko syöte sovelluksen odotuksia vastaavaa. Kurssiarvosanoja käsittelevässä sovelluksessa esimerkiksi kannattaa tarkistaa että syötetty arvosana on kokonaisluku sekä 0:n (hylätty) ja 5:n välillä. Tätä kutsutaan syötteen validoinniksi.</p>

		<p>Tarkastettavia asioita:</p>
		<ul>
		  <li>Puuttuuko vaadittu syöte</li>
		  <li>Onko syötettä liikaa tai liian vähän</li>
		  <li>Onko syöte oikean muotoista</li>
		  <li>Jos syötteenä tulee numero, onko se liian suuri tai liian pieni</li>
		</ul>

		<p>Validointiin läheisesti liittyvä käsite on datan varmentaminen (verification), eli sen tarkistaminen että syötetty data on oikein. Esimerkiksi sähköpostiosoitteiden tarkka validointi <a href="http://stackoverflow.com/questions/210945/what-would-be-a-globally-accepted-regular-expression-to-match-e-mail-addresses">voi</a> <a href="http://stackoverflow.com/questions/156430/regexp-recognition-of-email-address-hard">olla</a> <a href="http://www.dominicsayers.com/isemail/">haastavaa</a>. Tällöin on järkevämpää tehdä perusvalidointi, mutta jättää yksityiskohtien validointi pois ja sen sijaan varmistaa tiedon oikeellisuus vertaamalla sitä muuta kautta saatavaan tietoon, mikä sähköpostin tapauksessa varmaan tapahtuu helpoiten lähettämällä varmistussähköposti.</p>



                <h2>Viiteavainten käsittely ja koosteoliot</h2>


		<p>Aiemmat esimerkit ovat olleet melko yksinkertaisia, sillä niissä on ladattu tietoa yhdestä taulusta kerrallaan. Todellisuudessa tietokannoissa on usein viitteitä taulujen välillä, ja ohjelmallista tietokanta-abstraktiota käyttävän ohjelmoijan näkökulmasta olisi hyvin kätevää, jos nämä viitteet toimisivat myös olioina. Tutustutaan seuraavaksi viitteiden käsittelyyn taulujen välillä.</p>


		<p>Oletamme, että tietokantakaaviomme on seuraavanlainen kuvitteellisen pyörävuokraamon tietokannan osa.</p>


		<figure>
		  <img src="img/viikko4/vuokraamokaavio.png" alt="[Pyora|(pk) rekisterinumero; merkki]
[Varaaja|(pk) asiakasnumero; etunimi; sukunimi]
[Varaus|(pk) varaustunnus; (fk) varaaja: Varaaja; (fk) pyora: Pyora; varaus_alkaa; varaus_loppuu]
[Pyora]1-*[Varaus]
[Varaus]*-1[Varaaja]"/>
		</figure>


		<p>Kun ylläoleva tietokantakaavio luodaan Java-ohjelmakoodina siten, että taulujen väliset viitteet on otettu huomioon, luomme käytännössä kolme luokkaa: <em>Pyora</em>, <em>Varaaja</em> ja <em>Varaus</em>. Yhteen pyörään voi liittyä monta varausta, eli jokaiseen pyöräolioon liittyy lista varauksia. Vastaavasti, jokaiseen varaajaan voi liittyä monta varausta, eli jokaiseen varaajaolioon liittyy lista varauksia. Jokaiseen varausolioon liittyy yksi pyöräolio ja yksi varaajaolio.</p>

		<pre class="sh_java">
import java.util.*;

public class Pyora {

    private String rekisterinumero;
    private String merkki;
    private List&lt;Varaus&gt; varaukset;

// konstruktorit, getterit ja setterit
}</pre>

		<pre class="sh_java">
import java.util.*;

public class Varaaja {

    private Integer asiakasnumero;
    private String etunimi;
    private String sukunimi;
    private List&lt;Varaus&gt; varaukset;

// konstruktorit, getterit ja setterit
}</pre>


		<pre class="sh_java">
import java.util.*;
import java.sql.*;

public class Varaus {

    private Integer varaustunnus;
    private Pyora pyora;
    private Varaaja varaaja;
    private Timestamp varausAlkaa;
    private Timestamp varausLoppuu;

// konstruktorit, getterit ja setterit
}</pre>


		<p>Luokassa Varaus käytetty muuttujan tyyppi <code><a href="https://docs.oracle.com/javase/8/docs/api/java/sql/Timestamp.html" target="_blank">Timestamp</a></code> on eräs tietokannoissa käytetty muuttujatyyppi ajan tallentamiseen.</p>


		<p>Ohjelmallisia tietokantakyselyitä suorittaessa -- esimerkiksi varauksen noutamisen yhteydessä -- tulee nyt hakea (1) varaustaulusta rivi, (2) haetun varausrivin pyora-kentästä löytyvällä viiteavaimella rivi pyörätaulusta, (3) haetun varausrivin varaaja-kentästä löytyvällä viiteavaimella rivi varaaja-taulusta, ja (4) luoda haettujen rivien perusteella oliot -- varaaja- ja pyörä-oliot tulee lisäksi asettaa varaukseen kuuluvaksi. Kokonaisuudessaan, ilman toiminnallisuuden jakamista erillisiin osiin, tietyn varauksen ja siihen liittyvän pyörän hakemiseen tarvittava kysely voisi olla vaikkapa seuraavanlainen.</p>

<pre class="sh_java">
String databaseAddress = "jdbc:sqlite:vuokraamo.db";

// haetaan tietokanta-ajuri ja avataan tietokantayhteys
Connection conn = DriverManager.getConnection(databaseAddress);

// haetaan yksittäinen varaus, jonka tunnus on 42
PreparedStatement stmt = conn.prepareStatement("SELECT * FROM Varaus WHERE varaustunnus = ?");
stmt.setObject(1, 42);

// suoritetaan kysely ja siirrytään ensimmäiseen vastausriviin
ResultSet rs = stmt.executeQuery();
rs.next();

// haetaan vastausriviltä oleelliset kentät
Integer varaustunnus = rs.getInt("varaustunnus");
Timestamp alku = rs.getTimestamp("varaus_alkaa");
Timestamp loppu = rs.getTimestamp("varaus_loppuu");
String pyora = rs.getString("pyora");

// luodaan varaus varaustunnuksen, sekä alun ja lopun perusteella
Varaus v = new Varaus(varaustunnus, alku, loppu);

// vapautetaan varaus-tauluun kohdistuneeseen kyselyyn liittyvät resurssin
rs.close();
stmt.close();

// haetaan yksittäinen pyörä, jonka rekisterinumero oli varaustaulusta haetussa rivissä
stmt = conn.prepareStatement("SELECT * FROM Pyora WHERE rekisterinumero = ?");
stmt.setObject(1, pyora);

// suoritetaan kysely ja siirrytään ensimmäiseen vastausriviin
rs = stmt.executeQuery();
rs.next();

// haetaan vastausriviltä oleelliset kentät
String rekisterinumero = rs.getString("rekisterinumero");
String merkki = rs.getString("merkki");

// luodaan pyörä vastauksen perusteella
Pyora p = new Pyora(rekisterinumero, merkki);

// asetetaan pyörä varaukseen liittyväksi pyöräksi
v.setPyora(p);

// vapautetaan kyselyyn liittyvät resurssit ja suljetaan tietokantayhteys
rs.close();
stmt.close();
conn.close();

// nyt käytössämme on varaus-olio, sekä varaukseen liittyvä pyörä-olio
</pre>

                <p>Käytännössä toiminnallisuutta kuitenkin jaetaan osiin.</p>


<!--
	  	 

        <figure>
	  <img src="img/paivitysraja.jpg" alt="päivitysraja ::
C
 (\.   \      ,/)
  \(   |\     )/
  //\  | \   /\\
 (/ /\_#oo#_/\ \)
  \/\  ####  /\/
       `##'
"/>
	  <figcaption>Tähän on hyvä lopettaa lukeminen.</figcaption>
	</figure>


                <aside class="info">
		  <br/>
		  <h1>Esimerkkiprojekti Githubissa</h1>

		  <p>Juuri rakennettu esimerkkiprojekti löytyy Githubista osoitteessa <a href="https://github.com/tietokantojen-perusteet/Vuokraamo" target="_blank">https://github.com/tietokantojen-perusteet/Vuokraamo</a></p>

		</aside>


		<h2>Prepared Statement -kyselyt</h2>

-->

		<h2>Data Access Object -suunnittelumalli</h2>

		<p>Tietokantasovelluksia toteuttaessa on hyvin tyypillistä abstrahoida, eli piilottaa, konkreettinen tiedon hakemis- ja tallennustoiminnallisuus siten, että ohjelmoijan ei tarvitse nähdä sitä jatkuvasti. Ideana on, että sovelluskehittäjä käyttää <em>DAO</em>-rajapinnan toteuttamia olioita, ja se, että mistä tai miten tiedot konkreettisesti haetaan ei ole sovelluksen muiden osien tiedossa.</p>

		<aside class="info">
		  <br/>
		  <h1>Data Access Object (DAO) -- Wikipedia:</h1>
		  <p><em>In computer software, a data access object (DAO) is an object that provides an abstract interface to some type of database or other persistence mechanism. By mapping application calls to the persistence layer, DAO provide some specific data operations without exposing details of the database. This isolation supports the Single responsibility principle. It separates what data accesses the application needs, in terms of domain-specific objects and data types (the public interface of the DAO), from how these needs can be satisfied with a specific DBMS, database schema, etc. (the implementation of the DAO).</em></p>
		  
		  <p><em>Although this design pattern is equally applicable to the following: (1- most programming languages; 2- most types of software with persistence needs; and 3- most types of databases) it is traditionally associated with Java EE applications and with relational databases (accessed via the JDBC API because of its origin in Sun Microsystems' best practice guidelines "Core J2EE Patterns" for that platform).</em></p>
		</aside>
		
		<p>Hahmotellaan hakemiseen ja poistamiseen liittyvää rajapintaa, joka tarjoaa metodit <code>findOne</code>, <code>findAll</code> ja <code>delete</code>, eli toiminnallisuudet hakemiseen ja poistamiseen. Tehdään rajapinnasta <em>geneerinen</em>, eli toteuttava luokka määrittelee palautettavien olioiden tyypin sekä avaimen.</p>

<pre class="sh_java">
import java.sql.*;
import java.util.*;

public interface Dao&lt;T, K&gt; {

    T findOne(K key) throws SQLException;

    List&lt;T&gt; findAll() throws SQLException;

    void delete(K key) throws SQLException;
}</pre>

                <p>Metodi findOne hakee tietyllä avaimella haettavan olion, jonka tyyppi voi olla mikä tahansa. Alustava hahmotelma konkreettisesta varausten hakemiseen tarkoitetusta <code>VarausDao</code>-luokasta on seuraavanlainen. </p>

<pre class="sh_java">
import java.util.*;
import java.sql.*;

public class VarausDao implements Dao&lt;Varaus, Integer&gt; {

    @Override
    public Varaus findOne(Integer key) throws SQLException {
        // ei toteutettu
        return null;
    }

    @Override
    public List&lt;Varaus&gt; findAll() throws SQLException {
	// ei toteutettu
	return null;
    }

    @Override
    public void delete(Integer key) throws SQLException {
        // ei toteutettu
    }
}</pre>

                <p>Käytännössä tyyppiparametrit annetaan rajapinnan toteuttamisesta kertovan avainsanan <code>implements</code>-yhteyteen. Ylläolevassa esimerkissä haettavan olion tyyppi on <code>Varaus</code>, ja sen avain on tyyppiä <code>Integer</code>.</p>

		<p>Koska varausten hakemiseen tarvitaan myös pyörien hakemista, hahmotellaan myös pyörien hakemiseen liittyvää toiminnallisuutta. Luokan rakenne on hyvin samankaltainen kuin edellä -- suurin ero liittyy käsiteltävään olioon sekä avaimen tyyppiin (VarausDao käsittelee olioita, joiden avain on Integer-tyyppinen, kun taas PyoraDao käsittelee olioita, joiden avain on String-tyyppinen.</p>


<pre class="sh_java">
import java.util.*;
import java.sql.*;

public class PyoraDao implements Dao&lt;Pyora, String&gt; {

    @Override
    public Pyora findOne(String key) throws SQLException {
        // ei toteutettu
        return null;
    }

    @Override
    public List&lt;Pyora&gt; findAll() throws SQLException {
	// ei toteutettu
	return null;
    }

    @Override
    public void delete(String key) throws SQLException {
        // ei toteutettu
    }
}</pre>

		<p>Jatketaan luokan <code>PyoraDao</code>-toteuttamista. Lisätään luokalle pääsy tietokanta-abstraktioon, jolta voi pyytää tietokantayhteyden, ja hahmotellaan yksittäisen pyörän hakemista aiemman ohjelmakoodin perusteella. Emme tässä esimerkissä lisää pyörään siihen liittyviä varauksia.</p>


<pre class="sh_java">
import java.util.*;
import java.sql.*;

public class PyoraDao implements Dao&lt;Pyora, String&gt; {

    private Database database;

    public PyoraDao(Database database) {
        this.database = database;
    }
 
    @Override
    public Pyora findOne(String key) throws SQLException {
        Connection connection = database.getConnection();
        PreparedStatement stmt = connection.prepareStatement("SELECT * FROM Pyora WHERE rekisterinumero = ?");
        stmt.setObject(1, key);

        ResultSet rs = stmt.executeQuery();
        boolean hasOne = rs.next();
        if (!hasOne) {
            return null;
        }

        String rekisterinumero = rs.getString("rekisterinumero");
        String merkki = rs.getString("merkki");

        Pyora p = new Pyora(rekisterinumero, merkki);

        rs.close();
        stmt.close();
        connection.close();

        return p;
    }

    @Override
    public List&lt;Pyora&gt; findAll() throws SQLException {
	// ei toteutettu
	return null;
    }

    @Override
    public void delete(String key) throws SQLException {
        // ei toteutettu
    }
}</pre>

		<p>Luokka <code>Database</code> on esimerkiksi seuraavanlainen -- huomaa, että jaamme tietokantakyselyiden tekemisen vastuuta jokaiselle Dao-rajapinnan toteuttavalle luokalle erikseen -- kyselyt eivät siis ole enää <code>Database</code>-luokassa.</p>

<pre class="sh_java">
import java.sql.*;

public class Database {

    private String databaseAddress;

    public Database(String databaseAddress) throws ClassNotFoundException {
        this.databaseAddress = databaseAddress;
    }

    public Connection getConnection() throws SQLException {
        return DriverManager.getConnection(databaseAddress);
    }
}</pre>

		<p>Hahmotellaan nyt yksittäisen varaus-olion hakemista. Toteutetaan luokka siten, että se saa konstruktorissaan sekä viitteen tietokanta-olioon, että viitteen pyörien hakemiseen tarkoitettuun Dao-rajapintaan.</p>

<pre class="sh_java">
import java.util.*;
import java.sql.*;

public class VarausDao implements Dao&lt;Varaus, Integer&gt; {


    private Database database;
    private Dao&lt;Pyora, String&gt; pyoraDao;

    public VarausDao(Database database, Dao&lt;Pyora, String&gt; pyoraDao) {
        this.database = database;
        this.pyoraDao = pyoraDao;
    }

    @Override
    public Varaus findOne(Integer key) throws SQLException {
        Connection connection = database.getConnection();
        PreparedStatement stmt = connection.prepareStatement("SELECT * FROM Varaus WHERE varaustunnus = ?");
        stmt.setObject(1, key);

        ResultSet rs = stmt.executeQuery();
        boolean hasOne = rs.next();
        if (!hasOne) {
            return null;
        }

        Integer varaustunnus = rs.getInt("varaustunnus");
        Timestamp alku = rs.getTimestamp("varaus_alkaa");
        Timestamp loppu = rs.getTimestamp("varaus_loppuu");

        Varaus v = new Varaus(varaustunnus, alku, loppu);

        Integer varaaja = rs.getInt("varaaja");
        String pyora = rs.getString("pyora");

        rs.close();
        stmt.close();
        connection.close();

        v.setPyora(this.pyoraDao.findOne(pyora));

        return v;
    }

    @Override
    public List&lt;Varaus&gt; findAll() throws SQLException {
	// ei toteutettu
	return null;
    }

    @Override
    public void delete(Integer key) throws SQLException {
        // ei toteutettu
    }
}</pre>


		<p>Nyt yksittäisen varauksen hakemisen yhteydessä palautetaan sekä varaus, että siihen liittyvä pyörä. Rajapintaa käyttävän toteutuksen näkökulmasta tietokannan käyttäminen toimii seuraavasti:</p>

<pre class="sh_java">
Database database = new Database("jdbc:sqlite:vuokraamo.db");
PyoraDao pyoraDao = new PyoraDao(database);
VarausDao varausDao = new VarausDao(database, pyoraDao);

Varaus varaus = varausDao.findOne(4);
System.out.println(varaus.getPyora().getRekisterinumero()
        + " " + varaus.getVarausAlkaa()
        + " - " + varaus.getVarausLoppuu());</pre>

<pre>
HAB-4 2015-07-17 16:00:00.0 - 2015-07-18 10:00:00.0</pre>



		<p><strong><em>Kokoelmien hakeminen</em></strong></p>

		<p>Voisimme nyt jo toteuttaa kaikkien varausten hakemisen siten, että kävisimme jokaisen varaus-taulussa olevan varaustunnuksen läpi yksitellen, ja lisäisimme siihen halutun pyörän. Tämä ei kuitenkaan ole haluttua. Kaikkien varausten hakeminen kannattanee toteuttaa siten, että haemme ensin kaikki varaukset, jonka jälkeen haemme pyörät, jotka lisäämme varauksiin. Kaikkien pyörien hakeminen -- jos emme toteuta erikseen pyöriin liittyvien varausten listausta -- tapahtuu esimerkiksi seuraavasti.</p>

<pre class="sh_java">
@Override
public List&lt;Pyora&gt; findAll() throws SQLException {
    Connection connection = database.getConnection();
    PreparedStatement stmt = connection.prepareStatement("SELECT * FROM Pyora");

    ResultSet rs = stmt.executeQuery();
    List&lt;Pyora&gt; pyorat = new ArrayList&lt;&gt;();
    while (rs.next()) {
        String rekisterinumero = rs.getString("rekisterinumero");
        String merkki = rs.getString("merkki");

        pyorat.add(new Pyora(rekisterinumero, merkki));
    }

    rs.close();
    stmt.close();
    connection.close();

    return pyorat;
}</pre>

		<p>Nyt pyörien liittäminen varauksiin onnistuu kahdella tietokantakyselyllä (1) haetaan kaikki varaukset ja (2) haetaan kaikki pyörät -- yhdistäminen tapahtuu ohjelmakoodissa esimerkiksi seuraavasti.</p>

<pre class="sh_java">
@Override
public List&lt;Varaus&gt; findAll() throws SQLException {
    Connection connection = database.getConnection();
    PreparedStatement stmt = connection.prepareStatement("SELECT * FROM Varaus");
    ResultSet rs = stmt.executeQuery();

    Map&lt;String, List&lt;Varaus&gt;&gt; varaustenPyorat = new HashMap&lt;&gt;();

    List&lt;Varaus&gt; varaukset = new ArrayList&lt;&gt;();

    while (rs.next()) {

        Integer varaustunnus = rs.getInt("varaustunnus");
        Timestamp alku = rs.getTimestamp("varaus_alkaa");
        Timestamp loppu = rs.getTimestamp("varaus_loppuu");

        Varaus v = new Varaus(varaustunnus, alku, loppu);
        varaukset.add(v);

        String pyora = rs.getString("pyora");

        if(!varaustenPyorat.containsKey(pyora)) {
            varaustenPyorat.put(pyora, new ArrayList&lt;&gt;());
        }
        varaustenPyorat.get(pyora).add(v);
    }

    rs.close();
    stmt.close();
    connection.close();

    for (Pyora pyora : this.pyoraDao.findAll()) {
        if(!varaustenPyorat.containsKey(pyora.getRekisterinumero())) {
            continue;
        }

        for (Varaus varaus : varaustenPyorat.get(pyora.getRekisterinumero())) {
            varaus.setPyora(pyora);
        }
    }

    return varaukset;
}</pre>

		<p>Yllä haetaan ensin kaikki varaukset. Varausolioita luotaessa luodaan kirjanpito varauksiin liittyvien pyörien (viiteavain tauluun Pyörä) liittymisestä varausolioihin. Tämän jälkeen haetaan pyörät, ja lisätään ne varaukseen.</p>

		<p><strong><em>Osajoukon hakeminen</em></strong></p>


		<p>Edellisessä esimerkissä on kuitenkin hieman hölmöä se, että haemme <em>kaikki</em> viitatussa taulussa olevat rivit. Pyörien tapauksessa tämä voi olla hyväksyttävää, jos niitä on melko vähän, ja voimme olettaa, että lähes jokaista pyörää varataan. Toisaalta, jos vastaavaa toteutusta tehtäisiin varaajiin liittyen, ei jokaisen varaajan hakeminen olisi toivottua.</p>

		<p>Lisätään Dao-rajapintaan metodi <code>findAllIn(Collection&lt;K&gt; keys)</code>, joka hakee ne oliot, joiden avaimet ovat annetussa joukossa.</p>

<pre class="sh_java">
import java.sql.*;
import java.util.*;

public interface Dao&lt;T, K&gt; {

    T findOne(K key) throws SQLException;

    List&lt;T&gt; findAll() throws SQLException;

    List&lt;T&gt; findAllIn(Collection&lt;K&gt; keys) throws SQLException;

    void delete(K key) throws SQLException;
}</pre>

		<p>Nyt jokaista rajapinnan toteuttavaa luokkaa tulee muokata siten, että se toteuttaa uuden metodin. Lisätään metodin luokalle <code>PyoraDao</code> -- metodissa haetaan kaikki ne rivit, joiden alkiot ovat annetussa joukossa.</p>

<pre class="sh_java">
@Override
public List&lt;Pyora&gt; findAllIn(Collection&lt;String&gt; keys) throws SQLException {
    if (keys.isEmpty()) {
        return new ArrayList&lt;&gt;();
    }

    // Luodaan IN-kyselyä varten paikat, joihin arvot asetetaan --
    // toistaiseksi IN-parametrille ei voi antaa suoraan kokoelmaa
    StringBuilder muuttujat = new StringBuilder("?");
    for (int i = 1; i &lt; keys.size(); i++) {
        muuttujat.append(", ?");
    }

    Connection connection = database.getConnection();
    PreparedStatement stmt = connection.prepareStatement("SELECT * FROM Pyora WHERE rekisterinumero IN (" + muuttujat + ")");
    int laskuri = 1;
    for (String key : keys) {
        stmt.setObject(laskuri, key);
        laskuri++;
    }

    ResultSet rs = stmt.executeQuery();
    List&lt;Pyora&gt; pyorat = new ArrayList&lt;&gt;();
    while (rs.next()) {
        String rekisterinumero = rs.getString("rekisterinumero");
        String merkki = rs.getString("merkki");

        pyorat.add(new Pyora(rekisterinumero, merkki));
    }

    return pyorat;
}</pre>

		<p>Nyt VarausDaon metodia voidaan muuttaa sopivasti, jolloin taulusta Pyora haetaan vain ne rivit, jotka liittyvät varauksiin.</p>

<pre class="sh_java">
@Override
public List&lt;Varaus&gt; findAll() throws SQLException {
    Connection connection = database.getConnection();
    PreparedStatement stmt = connection.prepareStatement("SELECT * FROM Varaus");
    ResultSet rs = stmt.executeQuery();

    Map&lt;String, List&lt;Varaus&gt;&gt; varaustenPyorat = new HashMap&lt;&gt;();

    List&lt;Varaus&gt; varaukset = new ArrayList&lt;&gt;();

    while (rs.next()) {

        Integer varaustunnus = rs.getInt("varaustunnus");
        Timestamp alku = rs.getTimestamp("varaus_alkaa");
        Timestamp loppu = rs.getTimestamp("varaus_loppuu");

        Varaus v = new Varaus(varaustunnus, alku, loppu);
        varaukset.add(v);

        String pyora = rs.getString("pyora");

        if (!varaustenPyorat.containsKey(pyora)) {
            varaustenPyorat.put(pyora, new ArrayList&lt;&gt;());
        }
        varaustenPyorat.get(pyora).add(v);
    }

    rs.close();
    stmt.close();
    connection.close();

    for (Pyora pyora : this.pyoraDao.findAllIn(varaustenPyorat.keySet())) {
        for (Varaus varaus : varaustenPyorat.get(pyora.getRekisterinumero())) {
            varaus.setPyora(pyora);
        }
    }

    return varaukset;
}</pre>

		<aside class="info">
		  <br/>

		  <h1>Mitä noudetaan?</h1>

		  <p>Eikö edellisessä esimerkissä varaukseen liittyvää pyörää noudettaessa pitäisi noutaa myös pyörään liittyvät varaukset? Entä näihin varauksiin liittyvät pyörät ja varaajat?</p>

		  <p>Hyvä kysymys. Kun tietokantataulujen välisten yhteyksien perusteella tehdään uusia kyselyitä tietokantaan, olemassa on oleellisesti kaksi epätoivottua tilannetta: (1) haetaan liikaa tietoa, jolloin hakemisoperaatioon menee turhaan aikaa, tai (2) haetaan liian vähän tietoa, jolloin tieto tulee hakea myöhemmin.</p>

		  <p>Yksi tapa ratkaista ongelma on toimia siten, että tietoa haetaan vain silloin kun sitä tarvitaan. Tällöin esimerkiksi vasta Varaus-olioon mahdollisesti liittyvää <code>getPyora</code>-metodia kutsuttaessa pyörään liittyvät tiedot haettaisiin tietokannasta -- getPyora-metodi tekisi siis tietokantahaun. Tämäkään ei kuitenkaan ratkaise tilannetta, sillä jos tavoitteenamme olisi vaikkapa tulostaa kaikki varaukset ja niihin liittyvät pyörät -- edellisellä lähestymistavalla kaksi tietokantakyselyä -- saattaisi toteutus lopulta tehdä jokaisen varauksen kohdalla oman erillisen tietokantahaun.</p>

		  <p>Tähän ei ole suoraviivaista ratkaisua. Tyypillisesti Dao-rajapinnan määrittelemille metodeille kerrotaan, tuleeko haettaviin olioihin liittyvät viitteet hakea erikseen.</p>

		</aside>


		<h2>Valmiit kirjastot</h2>

		<p>Nykyään markkinoilla löytyy huomattava määrä valmiita kirjastoja, jotka tarjoavat Dao-toiminnallisuuksia. Yksi tällainen kirjasto on <a href="http://ormlite.com/" target="_blank">ORMLite</a>, joka abstrahoi ja toteuttaa osan tietokantakyselyistä ohjelmoijan puolesta. ORMLite-kirjaston saa projektiin lisäämällä siihen liittyvän riippuvuuden Mavenin <code>pom.xml</code>-tiedostoon.</p>

<pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;com.j256.ormlite&lt;/groupId&gt;
    &lt;artifactId&gt;ormlite-jdbc&lt;/artifactId&gt;
    &lt;version&gt;4.48&lt;/version&gt;
&lt;/dependency&gt;
</pre>

		<p>ORMLiteä käytettäessä tietokantatauluja kuvaaville luokille lisätään annotaatiot <code>@DatabaseTable(tableName = "<em>taulun nimi</em>")</code>, jonka lisäksi oliomuuttujille lisätään <code>@DatabaseField</code>-annotaatiot, joissa määritellään sarakkeen nimi, johon oliomuuttuja liittyy. Jos oliomuuttuja on taulun pääavain, lisätään sille erillinen määrittely (id=true) annotaatioon @DatabaseField: <code>@DatabaseField(id = true, columnName = "<em>sarakkeen nimi</em>")</code>.</p>

		<p>Käytännössä ORMLite osaa luoda olioita tietokannasta haettavista riveistä annotaatioiden perusteella. Jokaisessa tietokantataulua kuvaavassa tulee olla myös tyhjä konstruktori. Luokka <code>Pyora</code> ORMLite-annotaatioilla olisi esimerkiksi seuraavanlainen (tässä pyörään liittyviä varauksia ei ole otettu huomioon):</p>

<pre class="sh_java">
import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.table.DatabaseTable;

@DatabaseTable(tableName = "Pyora")
public class Pyora {

    @DatabaseField(id = true, columnName = "rekisterinumero")
    private String rekisterinumero;
    @DatabaseField(columnName = "merkki")
    private String merkki;

    // jokaisella tallennettavalla oliolle tulee olla parametriton konstruktori
    public Pyora() {
    }

    public Pyora(String rekisterinumero, String merkki) {
        this.rekisterinumero = rekisterinumero;
        this.merkki = merkki;
    }

// getterit ja setterit
}</pre>

                <aside class="info">
		  <br/>
		  <h1>@DatabaseField</h1>

		  <p>Jos tietokannassa olevan sarakkeen nimi on sama kuin oliomuuttujan nimi, voidaan annotaatiosta <code>@DatabaseField</code> jättää <code>columnName</code>-määrittely pois. Tietokantataulun sarakkeet, jotka ovat muotoa <code>sarakkeen_nimi</code> tulee olla määriteltynä <em>camelCase</em>-muodossa oliomuuttujina. Sarake <code>sarakkeen_nimi</code> olisi siis oliomuuttujana muotoa <code>sarakkeenNimi</code>.</p>

		</aside>



		<p>Nyt kaikkien pyörien hakeminen tietokannasta onnistuu seuraavasti. Huom! Käytössä on ORMLiten tarjoama Dao-rajapinta -- emme siis kirjoita erikseen ohjelmakoodia kyselyiden tulosten muuttamiseksi olioiksi.</p>

<pre class="sh_java">
ConnectionSource connectionSource
        = new JdbcConnectionSource("jdbc:sqlite:vuokraamo.db");

Dao&lt;Pyora, String&gt; pyoraDao
        = DaoManager.createDao(connectionSource, Pyora.class);

List&lt;Pyora&gt; pyorat = pyoraDao.queryForAll();
for (Pyora pyora : pyorat) {
    System.out.println(pyora.getMerkki() + " " + pyora.getRekisterinumero());
}</pre>

		<p>Käytännössä ORMLite lukee luokkaan määritellyt annotaatiot, ja tekee niiden perusteella käytettävät tietokantakyselyt, joita ohjelmoija käyttää ORMLiten toteuttaman Dao-rajapinnan kautta.</p>

		<p><strong><em>Viitteiden käsittely</em></strong></p>

		<p>Osoitteessa <a href="http://ormlite.com/javadoc/ormlite-core/doc-files/ormlite_2.html" target="_blank">http://ormlite.com/javadoc/ormlite-core/doc-files/ormlite_2.html</a> oleva ORMLiten "How to Use"-dokumentaatio sisältää neuvoja ORMLiten käyttöön. Lisätään seuraavaksi toiminnallisuus pyörien hakemiseen Varaus-luokan kautta. Annotaatioiden määrittely tapahtuu kuten Pyora-luokalle, mutta viittausta pyörään määriteltäessä annotaatiolle <code>@DatabaseField</code> tulee kertoa, että sarake viittaa toiseen tauluun, ja että viitatusta taulusta tulee hakea oliolle arvo. Tämä tapahtuu lisäämällä annotaatioon parametrit <code>foreign = true</code> ja <code>foreignAutoRefresh = true</code>. Tämän lisäksi, myös viitattuun tauluun tulee lisätä annotaatiot.</p>

<pre class="sh_java">
@DatabaseTable(tableName = "Varaus")
public class Varaus {

    @DatabaseField(id = true)
    private Integer varaustunnus;
    @DatabaseField(columnName = "pyora", canBeNull = false, foreign = true, foreignAutoRefresh = true)
    private Pyora pyora;
    private Varaaja varaaja;
    @DatabaseField(columnName = "varaus_alkaa")
    private Timestamp varausAlkaa;
    @DatabaseField(columnName = "varaus_loppuu")
    private Timestamp varausLoppuu;

    public Varaus() {
    }

// konstruktorit, getterit, setterit
</pre>

		<p>Ylläolevassa esimerkissä Varaus-luokka on määritelty siten, että se liittyy tietokantatauluun Varaus. Sillä on lisäksi kenttä pyora, joka viittaa tauluun, johon Pyora-luokka liittyy. Luokalle Varaaja ei ole määritelty toiminnallisuutta.</p>

		<p>Varauksiin liittyvien pyörien tulostaminen onnistuu nyt seuraavasti:</p>

<pre class="sh_java">
ConnectionSource connectionSource
        = new JdbcConnectionSource("jdbc:sqlite:vuokraamo.db");

Dao&lt;Varaus, String&gt; varausDao
        = DaoManager.createDao(connectionSource, Varaus.class);

List&lt;Varaus&gt; varaukset = varausDao.queryForAll();
for (Varaus varaus : varaukset) {
    System.out.println(varaus.getPyora().getRekisterinumero() + ", alkaa " + varaus.getVarausAlkaa());
}</pre>


		<aside class="info">
		  <br/>

		  <h1>Java Persistence API ja Hibernate</h1>

		  <p>Vastaavia toimintoja tarjoavia kirjastoja on huomattava määrä, ja Javalle on määritelty myös standardi näille kirjastoille. Javalle määritellyn standardin nimi on <em>Java Persistence API</em>, ja se määrittelee notaation luokkien annotoinnille ja kyselyiden kirjoittamiselle.</p>

		  <p>Valitsemamme ORMLite-kirjasto tarjoaa pienen määrän toiminnallisuutta, mutta kuitenkin samalla oleelliset osat on toteutettu melko hyvin. Jos toiminnallisuutta kaipaa enemmän, voi käyttöön valita esimerkiksi <a href="http://hibernate.org/" target="_blank">Hibernaten</a>, joka on ehkäpä eniten käytetty vastaavaa toiminnallisuutta tarjoava Java-kirjasto.</p>
		</aside>


		<header>
		  <h1 id="viikko4">Viikko 4</h1>
		</header>


		<h1>Tietokannat osana muita sovelluksia</h1>

		<p>Viimeisen 20 vuoden aikana selaimen -- ja nykyään kännykän -- kautta käytettävät sovellukset ovat kiihtyvää tahtia syrjäyttäneet perinteisiä työpöytäsovelluksia. Tietokannan käyttöön toisen sovelluksen osana liittyvät perusajatukset eivät kuitenkaan ole juurikaan muuttuneet. Työpöytäsovellusten aikana työpöytäsovellus käytti joko paikallisella koneella olevaa tietokannanhallintajärjestelmää, tai otti etäyhteyden toisella koneella käynnissä olevaan tietokannanhallintajärjestelmään. Selaimessa toimivia sovelluksia käytettäessä tietokannanhallintajärjestelmä toimii palvelinohjelmiston -- eli sovelluksen, johon selain ottaa yhteyttä -- kanssa samalla koneella, tai erillisellä koneella, johon palvelinohjelmisto ottaa yhteyden tarvittaessa.</p>

		<p>Tutustutaan tässä kappaleessa tietokantaa käyttävän palvelinohjelmiston toimintaan, sekä toteutetaan sellainen itse.</p>

		<h2>Selaimen ja palvelimen välinen kommunikaatio</h2>

		<p>Selain kommunikoi palvelimen kanssa tekemällä pyyntöjä joihin palvelin vastaa. Selain tekee pyynnön esimerkiksi kun käyttäjä kirjoittaa osoitekenttään sivun osoitteen -- tietokantojen-perusteet.github.io -- ja painaa enter. Tällöin tehdään hakupyyntö (<code>GET</code>) osoitteessa <code>tietokantojen-perusteet.github.io</code> olevalle palvelimelle. Palvelin vastaanottaa pyynnön, käsittelee sen -- esimerkiksi hakee haluttavan dokumentin tiedostojärjestelmästä -- ja luo käyttäjälle näytettävän sivun. Sivu palautetaan vastauksena pyynnölle tekstimuodossa. Selain päättelee vastauksen sisällön perusteella miten sivu tulee näyttää käyttäjälle, luo sivun ulkoasun, ja näyttää sivun käyttäjälle.</p>

		<p>Sivun näyttämisen yhteydessä selain hakee myös sisältöä, joihin sivu viittaa. Esimerkiksi jokainen tällä sivulla oleva kuva haetaan erikseen, aivan kuten erilaiset dynaamista toiminnallisuutta lisäävät Javascript -tiedostot sekä sivun ulkoasun tyylittelyyn liittyvät tyylitiedostot.</p>

		<p>Käyttäjän näkökulmasta selain tekee käytännössä kahdenlaisia pyyntöjä. Hakupyynnöt (<code>GET</code>) liittyvät tietyssä osoitteessa olevan resurssin hakemiseen, kun taas lähestyspyynnöt (<code>POST</code>) liittyvät tiedon lähettämiseen tiettyyn osoitteeseen.</p>

		<p>Tutustutaan tähän käytännössä Javalla toteutetun <a href="http://sparkjava.com/" target="_blank">Spark</a>-nimisen web-sovelluskehyksen avulla.</p>

		<h2>Spark ja ensimmäinen web-sovellus</h2>

		<p><a href="http://sparkjava.com/" target="_blank">Spark</a>-sovelluskehyksen käyttöönotto toimii luvun 8.2 osassa "<em>Maven-projektin luominen NetBeansissa</em>" esitetyllä tavalla. Toisin kuin oppaassa, Maven-projektin riippuvuudeksi halutaan lisätä Spark. Tiedosto <code>pom.xml</code> näyttää lopuksi esimerkiksi seuraavalta:</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;tikape&lt;/groupId&gt;
    &lt;artifactId&gt;tikape-web-sample&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.sparkjava&lt;/groupId&gt;
            &lt;artifactId&gt;spark-core&lt;/artifactId&gt;
            &lt;version&gt;2.3&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</pre>


		<p>Oleellista edellä on se, että Javan versioksi on määritelty 1.8, ja sparkin versioksi 2.3.</p>

		<p>Nyt voimme luoda uuden pääohjelmaluokan (seuraa luvun 2.3 kohtaa "<em>Ensimmäinen tietokantaa käyttävä Maven-ohjelma</em>") pääohjelmaluokan luomiseksi. Lisätään <code>Main.java</code>-tiedostoon rivi <code>import static spark.Spark.*;</code>, jolloin käyttöömme tulee oleellisimmat Sparkin tarjoamat toiminnallisuudet. Kutsutaan tämän jälkeen Sparkin get-metodia, ja määritellään sen avulla osoite, jota palvelinohjelmistomme tulee kuuntelemaan, sekä teksti, joka palautetaan, kun selaimella tehdään pyyntö annettuun osoitteeseen.</p>

<pre class="sh_java">
package tikape;

import static spark.Spark.*;

public class Main {

    public static void main(String[] args) {

        get("/hei", (req, res) -&gt; {
            return "Hei maailma!";
        });

    }
}
</pre>

		<p>Yllä olevassa esimerkissä palvelimelle määritellään osoite <code>/hei</code>. Jos selaimella tehdään osoitteeseen pyyntö, pyyntöön vastataan tekstillä <code>Hei maailma!</code>.</p>

		<p>Jos ylläolevan sovelluksen käynnistää, Spark käynnistää web-palvelimen osoitteeseen <code>http://localhost:4567</code>, eli paikallisen koneen porttiin <code>4567</code>. Palvelin on tämän jälkeen käynnissä, ja odottaa siihen tehtäviä pyyntöjä. Kun haemme web-selaimella sivua osoitteesta <code>http://localhost:4567</code>, palauttaa palvelin selaimelle tekstimuotoista tietoa, ja selain näyttää käyttäjälle seuraavanlaisen sivun:</p>

                <figure>
		  <img src="img/viikko6/spark-localhost-not-found.png" alt="Kun osoitteeseen http://localhost:4567 tehdään pyyntö, sieltä palautuu sivu, jossa näkyy teksti '404 Not found'."/>
		  <figcaption>Kun osoitteeseen http://localhost:4567 tehdään pyyntö, sieltä palautuu sivu, jossa näkyy teksti '404 Not found'.</figcaption>
		</figure>

		<p>Mutta! Kun teemme pyynnön osoitteeseen <code>http://localhost:4567/hei</code>, eli palvelinohjelmiston osoitteeseen <code>/hei</code>, saammekin vastaukseksi ohjelmakoodissa määrittelemämme <code>Hei maailma!</code>-tekstin.</p>

                <figure>
		  <img src="img/viikko6/spark-localhost-hei-maailma.png" alt="Kun osoitteeseen http://localhost:4567/hei tehdään pyyntö, sieltä palautuu teksti 'Hei maailma!'."/>
		  <figcaption>Kun osoitteeseen http://localhost:4567/hei tehdään pyyntö, sieltä palautuu teksti 'Hei maailma!'.</figcaption>
		</figure>

		<p>Vapise, google.</p>

		<aside class="info">

		  <br/>

		  <h1>NetBeans ja palvelimen sammuttaminen</h1>

		  <p>Palvelimen sammuttaminen tapahtuu NetBeansissa punaista neliötä klikkaamalla. Joissakin käyttöjärjestelmissä tämä ei kuitenkaan toimi oikein, jolloin palvelin tulee sammuttaa komentoriviltä.</p>

		  <p>Saat portissa <code>4567</code> käynnissä olevan prosessin tunnuksen tietoon terminaalissa komennolla <code>lsof -i :4567</code>. Etsi komennon palauttamasta tulosteesta prosessin tunnus, jonka jälkeen voit sammuttaa prosessin komennolla <code>kill -9 prosessin-tunnus</code>.</p>

		  <p>Esimerkiksi:</p>
<pre>
> lsof -i :4567
COMMAND  PID     USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
java    9916 kayttaja   51u  IPv6 0x65802ef6be5c6f29      0t0  TCP *:tram (LISTEN)
>
</pre>

		  <p>Yllä prosessin tunnus (PID) on 9916. Tämän jälkeen prosessi sammutetaan komennolla <code>kill -9 9916</code>.</p>

<pre>
> lsof -i :4567
COMMAND  PID     USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
java    9916 kayttaja   51u  IPv6 0x65802ef6be5c6f29      0t0  TCP *:tram (LISTEN)
> kill -9 9916
</pre>

		</aside>


		<h2>Useamman osoitteen kuunteleminen</h2>


		<p>Spark-palvelimelle määritellään <code>get</code>-metodin avulla palvelimen kuuntelemia osoitteita. Metodikutsun yhteydessä määritellään myös palvelimen palauttama data. Palautettava data on tekstiä, mutta selain päättelee palautetun tekstin sisällön perusteella, mitä tekstille tulee tehdä. Alla olevassa ohjelmakoodissa määritellään kaksi osoitetta, joista palautetaan dataa. Toinen palauttaa aiemmin nähdyn tekstin <code>Hei maailma!</code>, ja toinen palauttaa <a href="http://www.w3schools.com/html/" target="_blank">HTML</a>-elementin, jonka selain käsittelee ja näyttää. Koska elementin sisällä on linkki Youtube-videoon, aloittaa selain videon hakemisen Youtube-palvelusta.</p>

<pre class="sh_java">
package tikape;

import static spark.Spark.*;

public class Main {

    public static void main(String[] args) {

        get("/hei", (req, res) -&gt; {
            return "Hei maailma!";
        });


        get("/testi", (req, res) -&gt; {
            return "&lt;iframe width=\"640\" height=\"420\" src=\"https://www.youtube.com/embed/dQw4w9WgXcQ?rel=0&autoplay=1\"&gt;&lt;/iframe&gt;";
        });

    }
}
</pre>


		<h2>Tiedon lähettäminen palvelimelle</h2>

		<p>Tiedon lähettäminen (<code>POST</code>) palvelimelle tapahtuu HTML-sivuilla lomakkeen avulla.</p>

		<p><strong><em>Lomakkeen määrittely</em></strong></p>

                <p>Lomakkeelle (<code>form</code>) määritellään metodiksi (<code>method</code>) lähetys, eli POST, sekä osoite, johon lomakkeella oleva tieto tulee lähettää. Lomakkeen määrittely alkaa muodossa <code>&lt;form method="POST" action="/osoite"&gt;</code>, missä <code>/osoite</code> on palvelimelle määritelty osoite. Tätä seuraa erilaiset lomakkeen kentät, esimerkiksi tekstikenttä (<code>&lt;input type="text" name="nimi"/&gt;</code>), johon syötettävälle arvolle tulee <code>name</code>-kentässä määritelty nimi. Lomakkeeseen tulee lisätä myös nappi (<code>&lt;input type="submit" value="Lähetä!"/&gt;</code>), jota painamalla lomake lähetetään. Lomake voi olla kokonaisuudessaan esimerkiksi seuraava:</p>

<pre class="sh_html">
&lt;form method="POST" action="/opiskelijat"&gt;
  Nimi:&lt;br/&gt;
  &lt;input type="text" name="nimi"/&gt;&lt;br/&gt;
  &lt;input type="submit" value="Lisää opiskelija"/&gt;
&lt;/form&gt;
</pre>


                <p>Yllä määritelty lomake näyttää selaimessa (esimerkiksi) seuraavalta:</p>

<pre>
<div>
<form method="POST" action="/opiskelijat">
Nimi:<br/>
<input type="text" name="nimi"/><br/>
<input type="submit" value="Lisää opiskelija"/>
</form>
</div>
</pre>

                <p>Nappia painamalla lomakkeeseen kirjoitettu tieto yritetään lähettää osoitteessa <code>http://tietokantojen-perusteet.github.io</code> olevan palvelimen osoitteeseen <code>/opiskelijat</code>. Ei taida onnistua :).</p>

		<p><strong><em>Tiedon lähetyksen vastaanotto</em></strong></p>

		<p>Palvelimelle määritellään tietoa vastaanottava osoite metodilla <code>post</code>, jolle annetaan parametrina kuunneltava osoite, sekä koodi, joka suoritetaan kun osoitteeseen lähetetään tietoa. Pyynnön mukana lähetettävään tietoon -- esimerkiksi ylläolevalla lomakkeella voidaan lähettää nimi-niminen arvo palvelimelle -- pääsee käsiksi <code>req</code>-nimisen parametrin metodilla <code>queryParams</code>.</p>

<pre class="sh_java">
        post("/opiskelijat", (req, res) -&gt; {
            String nimi = req.queryParams("nimi");
            System.out.println("Vastaanotettiin " + nimi);

            return "Kerrotaan siitä tiedon lähettäjälle: " + nimi;
        });
</pre>

		<p>Samaa osoitetta voi käsitellä sekä <code>get</code>, että <code>post</code>-metodilla. Palvelin voi siis palauttaa selaimen tekemiin hakupyyntöihin tiettyä dataa -- esimerkiksi vaikkapa lomakkeen -- ja käsitellä lähetetyn tiedon erikseen. Alla on määritelty kaksi <code>/opiskelijat</code>-osoitetta kuuntelevaa toiminnallisuutta. Toinen palauttaa lomakkeen, toinen taas palauttaa tekstin, jonka osana on lomakkeella lähetetty nimi.</p>

<pre class="sh_java">
package tikape;

import static spark.Spark.*;

public class Main {

    public static void main(String[] args) {

        get("/opiskelijat", (req, res) -&gt; {
            return "&lt;form method=\"POST\" action=\"/opiskelijat\"&gt;\n"
                    + "Nimi:&lt;br/&gt;\n"
                    + "&lt;input type=\"text\" name=\"nimi\"/&gt;&lt;br/&gt;\n"
                    + "&lt;input type=\"submit\" value=\"Lisää opiskelija\"/&gt;\n"
                    + "&lt;/form&gt;";
        });

        post("/opiskelijat", (req, res) -&gt; {
            String nimi = req.queryParams("nimi");
            return "Kerrotaan siitä tiedon lähettäjälle: " + nimi;
        });

    }
}
</pre>

		<p>Kun palvelin käynnistetään ylläolevalla ohjelmalla, löytyy osoitteesta <code>http://localhost:4567/opiskelijat</code> seuraavanlainen sivu:</p>

                <figure>
		  <img src="img/viikko6/spark-lomake.png" alt="Kun osoitteeseen http://localhost:4567/opiskelijat tehdään pyyntö, nähdään aiemmin määritelty."/>
		  <figcaption>Kun osoitteeseen http://localhost:4567/opiskelijat tehdään pyyntö, nähdään aiemmin määritelty.</figcaption>
		</figure>

		<p>Täytetään lomake -- vaikkapa nimellä <a href="https://en.wikipedia.org/wiki/Edgar_F._Codd" target="_blank">Edgar F. Codd</a>.</p>

                <figure>
		  <img src="img/viikko6/spark-lomake-taytetty.png" alt="Lomakkeen nimi-kenttään asetettu arvo 'Edgar F. Codd'."/>
		  <figcaption>Lomakkeen nimi-kenttään asetettu arvo 'Edgar F. Codd'.</figcaption>
		</figure>

		<p>Kun painamme nyt nappia <code>Lisää opiskelija</code>, tekstikentän sisältö lähetetään palvelimelle lomakkeen <code>action</code>-kentän määrittelemään osoitteeseen. Jos lomakkeessa määritelty metodiksi (<code>method</code>) post, tehdään lähetyspyyntö. Jos action kenttä on <code>/opiskelijat</code> ja metodi <code>POST</code>, lähetettävä tieto vastaanotetaan ja suoritetaan rivillä <code>post("/opiskelijat", (req, res) -&gt; {</code> alkavalla ohjelmakoodilla. Aiemmin määritellyllä ohjelmalla käyttäjälle näytetään seuraavanlainen sivu:</p>

                <figure>
		  <img src="img/viikko6/spark-lomake-lahetetty.png" alt="Lomake on lähetetty ja palvelin palauttaa tekstin 'Kerrotaan siitä tiedon lähettäjälle: Edgar F. Codd'."/>
		  <figcaption>Lomake on lähetetty ja palvelin palauttaa tekstin 'Kerrotaan siitä tiedon lähettäjälle: Edgar F. Codd'.</figcaption>
		</figure>


		<p><strong><em>Tiedon säilöminen palvelimelle hetkellisesti</em></strong></p>

		<p>Voimme tallentaa vastaanotetun tiedon palvelimelle palvelimen käynnissäoloajaksi säilömällä sen esimerkiksi <code>ArrayList</code>-tyyppiseen listaan. Muokataan ylläolevaa aiempaa koodia siten, että hakupyyntö osoitteeseen <code>/opiskelijat</code> palauttaa sekä lomakkeen että tallennetut opiskelijat. Tämän lisäksi, lisätään osoitteeseen <code>/opiskelijat</code> tehtävän lähetyspyynnön käsittelyyn lomakkeelta saatavan nimi-kentän lisääminen ohjelmassa olevaan listaan.</p>

<pre class="sh_java">
package tikape;

import java.util.ArrayList;
import static spark.Spark.*;

public class Main {

    public static void main(String[] args) {
        ArrayList&lt;String&gt; nimet = new ArrayList&lt;&gt;();

        get("/opiskelijat", (req, res) -&gt; {
            String opiskelijat = "";
            for (String nimi : nimet) {
                opiskelijat += nimi + "&lt;br/&gt;";
            }

            return opiskelijat
                    + "&lt;form method=\"POST\" action=\"/opiskelijat\"&gt;\n"
                    + "Nimi:&lt;br/&gt;\n"
                    + "&lt;input type=\"text\" name=\"nimi\"/&gt;&lt;br/&gt;\n"
                    + "&lt;input type=\"submit\" value=\"Lisää opiskelija\"/&gt;\n"
                    + "&lt;/form&gt;";
        });

        post("/opiskelijat", (req, res) -&gt; {
            String nimi = req.queryParams("nimi");
            nimet.add(nimi);
            return "Kerrotaan siitä tiedon lähettäjälle: " + nimi;
        });

    }
}
</pre>

                <p>Nyt kun osoitteessa <code>/opiskelijat</code> olevalla lomakkeella tehdään useampia pyyntöjä, tulee lomakesivulle lisää näytettäviä opiskelijoita.</p>


                <figure>
		  <img src="img/viikko6/spark-lomake-lahetetty-monesti.png" alt="Lomakkeella lähetetty arvot 'Edgar F. Codd' ja 'Ada Lovelace' ja lomake-sivu avattu uudestaan."/>
		  <figcaption>Lomakkeella lähetetty arvot 'Edgar F. Codd' ja 'Ada Lovelace' ja lomake-sivu avattu uudestaan.</figcaption>
		</figure>




		<aside class="info">
		  <br/>
		  <h1>Useamman kentän lähettäminen</h1>

		  <p>HTML-lomakkeelle voidaan määritellä useampia kenttiä. Jokaisella kentällä tulee olla eri nimi, jotta palvelimella voidaan ottaa lomakkeen tiedon vastaan. Esimerkiksi nimeä ja osoitetta voisi kerätä vaikkapa seuraavanlaisella lomakkeella.</p>

<pre class="sh_html">
&lt;form method="POST" action="/opiskelijat"&gt;
Nimi:&lt;br/&gt;
&lt;input type="text" name="nimi"/&gt;&lt;br/&gt;
Osoite:&lt;br/&gt;
&lt;input type="text" name="osoite"/&gt;&lt;br/&gt;
&lt;input type="submit" value="Lisää opiskelija"/&gt;
&lt;/form&gt;
</pre>


                <p>Lomake näyttää selaimessa (esimerkiksi) seuraavalta:</p>

<pre>
<div>
<form method="POST" action="/opiskelijat">
Nimi:<br/>
<input type="text" name="nimi"/><br/>
Osoite:<br/>
<input type="text" name="osoite"/><br/>
<input type="submit" value="Lisää opiskelija"/>
</form>
</div>
</pre>

		</aside>


		<h2>Tiedon esittäminen selaimessa</h2>


		<p>Selain näyttää käyttäjälle palvelimelta saamansa tekstimuotoisen vastauksen. Jos vastaus on HTML-muodossa, tulkitsee selain vastauksen, ja luo sen perusteella näkymän käyttäjälle. Toteutimme näkymän näyttämisen käyttäjälle aiemmin siten, että palautimme palvelimelta HTML-koodia.</p>

<pre class="sh_java">
return "&lt;form method=\"POST\" action=\"/opiskelijat\"&gt;\n"
        + "Nimi:&lt;br/&gt;\n"
        + "&lt;input type=\"text\" name=\"nimi\"/&gt;&lt;br/&gt;\n"
        + "&lt;input type=\"submit\" value=\"Lisää opiskelija\"/&gt;\n"
        + "&lt;/form&gt;";
</pre>

                <p>HTML-koodin palauttaminen suoraan palvelinohjelmistosta on kuitenkin hyvin epätyypillistä. Käytännössä html-sivut luodaan lähes aina ensin erilliseen tiedostoon, jonka palvelin palauttaa käyttäjälle. Voimme tehdä näin myös Sparkin kautta.</p>

		<p><strong><em>HTML-sivujen käyttöönotto projektissa</em></strong></p>

		<p>Lisätään projektiin riippuvuudeksi <code>spark-template-thymeleaf</code>-projekti, joka tuo käyttöön <a href="http://www.thymeleaf.org/" target="_blank">Thymeleaf</a>-kirjaston. Projektin konfiguraatio on nyt kokonaisuudessaan seuraavanlainen:</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;tikape&lt;/groupId&gt;
    &lt;artifactId&gt;tikape-web-sample&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.sparkjava&lt;/groupId&gt;
            &lt;artifactId&gt;spark-core&lt;/artifactId&gt;
            &lt;version&gt;2.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.sparkjava&lt;/groupId&gt;
            &lt;artifactId&gt;spark-template-thymeleaf&lt;/artifactId&gt;
            &lt;version&gt;2.3&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</pre>

                <p>Tehdään seuraavaksi resurssikansio (<code>resources</code>) projektin kansioon <code>src/main/</code>, jos sitä ei vielä ole. Uuden kansion saa luotua NetBeansin Files-välilehdellä klikkaamalla kansiota oikealla hiirennapilla, ja valitsemalla <code>New -> Folder</code>. Kun kansio on luotu, pitäisi käytössä olla kansio <code>src/main/resources</code>. Tämän jälkeen <code>resources</code>-kansioon tulee vielä luoda kansio <code>templates</code>, johon HTML-tiedostot tullaan laittamaan.</p>

                <figure>
		  <img src="img/viikko6/nb-src-main-resources-templates.png" alt="Kansio src/main/resources/templates on luotu."/>
		  <figcaption>Projektiin liittyvän kansion <code>src</code> allaolevassa kansiossa <code>main</code> on nyt kansio <code>resources</code>, jossa on taas kansio <code>templates</code>.</figcaption>
		</figure>

		<p>Lisätään kansioon <code>templates</code> uusi html-dokumentti (<code>New -&gt; HTML File</code>), ja asetetaan tiedoston nimeksi <code>index.html</code>.</p>

                <figure>
		  <img src="img/viikko6/nb-src-main-resources-templates-index.png" alt="Kansioon src/main/resources/templates on luotu index.html-niminen tiedosto."/>
		  <figcaption>Nyt kansiossa <code>src/main/resources/templates</code> on tiedosto <code>index.html</code>.</figcaption>
		</figure>

		<p>Käyttämämme Thymeleaf-kirjasto olettaa, että HTML-tiedostot ovat tietyn muotoisia -- palataan tähän myöhemmin. Tässä välissä riittää, että html-sivun sisällöksi kopioi seuraavan aloitussisällön.</p>

<pre class="sh_xml">
&lt;!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;

    &lt;head&gt;
        &lt;title&gt;Otsikko&lt;/title&gt;
        &lt;meta charset="utf-8" /&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;h1&gt;Hei maailma!&lt;/h1&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>


                <p>Huom! Jos näet virheen <code>500 Internal Server Error!</code> sekä NetBeansin lokeihin tulee viestiä "Parse errorista", tarkista, että sivun sisältö on aluksi täsmälleen ylläoleva.</p>


		<p><strong><em>HTML-sivun palauttaminen käyttäjälle</em></strong></p>


		<p>Voimme palauttaa kansiossa <code>src/main/java/resources/templates</code> olevia <code>.html</code>-päätteisiä tiedostoja Sparkin avulla seuraavasti. Allaolevassa metodikutsussa määritellään kuunneltavaksi osoitteeksi <code>/sivu</code>, jonka jälkeen käyttäjälle palautetaan <code>index</code>-niminen sivu. Sivun nimen perusteella päätellään palautettava html-tiedosto -- nimi <code>index</code> muunnetaan muotoon <code>src/main/java/resources/templates/</code>index<code>.html</code>.</p>

<pre class="sh_java">
package tikape;

import java.util.HashMap;
import spark.ModelAndView;
import static spark.Spark.*;
import spark.template.thymeleaf.ThymeleafTemplateEngine;

public class Main {

    public static void main(String[] args) {
        get("/sivu", (req, res) -> {
            HashMap map = new HashMap<>();

            return new ModelAndView(map, "index");
        }, new ThymeleafTemplateEngine());
    }
}
</pre>

		<p>Kun yllä määritelty sovellus käynnistetään, ja kansiossa <code>src/main/java/resources/templates</code> on tiedosto <code>index.html</code>, näytetään tiedoston sisältö käyttäjälle. Huomaathan, että tiedoston sisällön tulee olla kuten edellisessä kappaleessa näytetty. Näkymä on käyttäjälle esimerkiksi seuraavanlainen:</p>

                <figure>
		  <img src="img/viikko6/spark-index.png" alt="Osoite http://localhost:4567/sivu avattuna."/>
		  <figcaption>Osoite http://localhost:4567/sivu avattuna.</figcaption>
		</figure>

		<aside class="info">
		  <br/>
		  <h1>Sivun palauttaminen hieman tarkemmin</h1>

		  <p>Tutkitaan sivun palauttamista vielä tarkemmin.</p>

<pre class="sh_java">
get("/sivu", (req, res) -> {
    HashMap map = new HashMap&lt;&gt;();

    return new ModelAndView(map, "index");
}, new ThymeleafTemplateEngine());
</pre>

                  <p>Metodikutsun ensimmäinen rivi lienee tuttu. Kerromme, että ohjelman tulee kuunnella osoitteeseen <code>/sivu</code> tehtäviä hakupyyntöjä. Tämän jälkeen tulee pyynnön käsittelyyn liittyvä lohko, josta tällä kertaa palautetaan olio, joka sisältää <code>HashMap</code>-olion sekä tiedon näytettävästä html-sivusta. Tämän jälkeen pyynnön käsittelyyn lisätään vielä erillinen olio, <code>ThymeleafTemplateEngine</code>, joka käsittelee html-sivun ennen sen palautusta.</p>

		</aside>


		<p><strong><em>Palvelimelta saadun tiedon näyttäminen käyttäjälle</em></strong></p>

		<p>Thymeleaf-komponentin avulla voimme lisätä html-sivulle tietoa. Tämä tapahtuu lisäämällä <code>HashMap</code>-olioon <code>put</code>-metodilla arvo, esimerkiksi <code>map.put("teksti", "Hei mualima!");</code>.</p>

<pre class="sh_java">
get("/sivu", (req, res) -> {
    HashMap map = new HashMap<>();
    map.put("teksti", "Hei mualima!");

    return new ModelAndView(map, "index");
}, new ThymeleafTemplateEngine());
</pre>

		<p>Tämän jälkeen html-sivua <code>index.html</code> muokataan siten, että sinne lisätään "paikka" tiedolle. Tiedon lisääminen tapahtuu lisäämällä sivulle html-elementti, jossa on <em>attribuutti</em> <code>th:text</code>, jolle annetaan HashMap-olioon lisätyn arvon nimi aaltosulkujen sisällä siten, että aaltosulkuja edeltää dollarimerkki -- eli <code>th:text="${teksti}"</code>. Elementti voi olla vaikka <code>h2</code>-elementti, jolloin kokonaisuus voisi olla vaikkapa seuraava <code>&lt;h2 th:text="${teksti}"&gt;testi&lt;/h2&gt;</code>.</p>

<pre class="sh_xml">
&lt;!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;

    &lt;head&gt;
        &lt;title&gt;Otsikko&lt;/title&gt;
        &lt;meta charset="utf-8" /&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;h1&gt;Hei maailma!&lt;/h1&gt;

        &lt;h2 th:text="${teksti}"&gt;testi&lt;/h2&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

		<p>Kun käynnistämme palvelimen, ja avaamme osoitteen <code>http://localhost:4567/sivu</code>, näemme seuraavanlaisen näkymän.</p>




                <figure>
		  <img src="img/viikko6/spark-index-ja-thyme.png" alt="Osoite http://localhost:4567/sivu avattuna."/>
		  <figcaption>Osoite http://localhost:4567/sivu avattuna.</figcaption>
		</figure>


		<aside class="info">
		  <br/>
		  <h1>HashMap ja Thymeleaf</h1>

		  <p>Tässä oikeastaan tulee kaksi uutta ja mielenkiintoista asiaa.</p>

		  <p><strong>HashMap</strong> on ohjelmoinnissa käytettävä lokerikko, missä jokaisella lokerolla on nimi, mihin arvon voi asettaa. Alla olevassa esimerkissä luomme ensin HashMap-olion, jonka jälkeen asetamme lokeroon nimeltä <code>teksti</code> arvon <code>"Hei mualima!"</code>.</p>

<pre class="sh_java">
HashMap map = new HashMap&lt;&gt;();
map.put("teksti", "Hei mualima!");
</pre>

		  <p>Kun HashMap-olio <em>palautetaan</em> pyynnön käsittelyn jälkeen -- <code>return new ModelAndView(map, "index");</code> -- annetaan lokerikko Thymeleafin käyttöön.</p>

		  <p><strong>Thymeleaf</strong> etsii annetusta HashMap-oliosta lokeroita <code>th:text</code>-attribuutille annetulla nimellä. Esimerkiksi kun Thymeleaf käsittelee edellä näkemämme <code>&lt;h2 th:text="${teksti}"&gt;testi&lt;/h2&gt;</code>-rivin, etsii se HashMap-oliosta lokeron nimeltä <code>teksti</code>, ja asettaa siinä olevan arvon <em>elementin tekstiarvoksi</em>. Tässä tapauksessa teksti <code>testi</code> korvataan HashMap-olion lokerosta teksti löytyvällä arvolla, eli tekstillä <code>Hei mualima!</code>.</p>

		</aside>

		<p><strong><em>Listojen lisääminen sivulle</em></strong></p>

		<p>Tutustutaan vielä olioiden ja listojen käsittelyyn Thymeleafin avulla. Oletetaan, että käytössämme on seuraava <em>Opiskelija</em>-luokka.</p>

<pre class="sh_java">
package tikape;

public class Opiskelija {

    private Integer id;
    private String nimi;

    public Opiskelija() {
    }

    public Opiskelija(Integer id, String nimi) {
        this.id = id;
        this.nimi = nimi;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getNimi() {
        return nimi;
    }

    public void setNimi(String nimi) {
        this.nimi = nimi;
    }
}
</pre>

		<p>Jokaisella opiskelijalla on siis tunnus sekä nimi. Tämän lisäksi, jokaiselle opiskelijalle kuuluu <code>get</code>- ja <code>set</code>-metodit, joiden avulla opiskelijaan liittyviä tietoja voidaan hakea ja muokata. Muokataan aiempaa ohjelmaamme siten, että käytössämme on listallinen opiskelijoita, jotka palautetaan sivun mukana thymeleafin käsiteltäväksi.</p>

<pre class="sh_java">
package tikape;

import java.util.ArrayList;
import java.util.HashMap;
import spark.ModelAndView;
import static spark.Spark.*;
import spark.template.thymeleaf.ThymeleafTemplateEngine;

public class Main {

    public static void main(String[] args) {
        ArrayList&lt;Opiskelija&gt; opiskelijat = new ArrayList&lt;&gt;();
        opiskelijat.add(new Opiskelija(1, "Ada Lovelace"));
        opiskelijat.add(new Opiskelija(2, "Charles Babbage"));

        get("/opiskelijat", (req, res) -> {
            HashMap map = new HashMap&lt;&gt;();
            map.put("teksti", "Hei mualima!");
            map.put("opiskelijat", opiskelijat);

            return new ModelAndView(map, "index");
        }, new ThymeleafTemplateEngine());
    }
}
</pre>

		<p>Lisätään vielä opiskelijat html-sivulle.</p>


<pre class="sh_xml">
&lt;!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;

    &lt;head&gt;
        &lt;title&gt;Otsikko&lt;/title&gt;
        &lt;meta charset="utf-8" /&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;h1&gt;Hei maailma!&lt;/h1&gt;

        &lt;h2 th:text="${teksti}"&gt;testi&lt;/h2&gt;

        &lt;h2 th:text="${opiskelijat}"&gt;opiskelijatesti&lt;/h2&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

                <p>Kun nyt haemme sivua, saamme (esimerkiksi) seuraavanlaisen näkymän.</p>


                <figure>
		  <img src="img/viikko6/spark-index-opiskelijat.png" alt="Osoite http://localhost:4567/opiskelijat avattuna. Sivulla näkyy teksti Hei maailma!

Hei mualima!

[tikape.Opiskelija@4f4a43a5, tikape.Opiskelija@41ce9964]"/>
		  <figcaption>Osoite http://localhost:4567/sivu avattuna. Opiskelijat näkyvät, mutta eivät toivotussa muodossa.</figcaption>
		</figure>

		<p><strong><em>Thymeleafin "for-each"-lause</em></strong></p>

		<p>Kurssilla ohjelmoinnin perusteet käytetään listan läpikäymiseen <code>for</code>-lausetta. Voisimme esimerkiksi tulostaa opiskelijoihin liittyvät tiedot seuraavasti Java-koodissa:</p>

<pre class="sh_java">
ArrayList&lt;Opiskelija&gt; opiskelijat = new ArrayList&lt;&gt;();
opiskelijat.add(new Opiskelija(1, "Ada Lovelace"));
opiskelijat.add(new Opiskelija(2, "Charles Babbage"));

for(Opiskelija opiskelija : opiskelijat) {
    System.out.println("id: " + opiskelija.getId());
    System.out.println("nimi: " + opiskelija.getNimi());
    System.out.println();
}
</pre>

<pre>
id: 1
nimi: Ada Lovelace

id: 2
nimi: Charles Babbage
</pre>

                <p>Vastaavanlainen toiminnallisuus löytyy myös Thymeleafista. Voimme käydä listan elementit läpi attribuutilla <code>th:each</code>, jolle annetaan sekä läpikäytävän listan nimi -- taas aaltosulkujen sisällä siten, että aaltosulkuja ennen on dollarimerkki -- sekä yksittäisen listaelementin nimi, jota käytetään listaa läpikäydessä. Alla olevassa esimerkissä aloitetaan lista <code>ul</code>-elementin avulla. Jokaiselle opiskelijalle luodaan oma <code>li</code>-elementti (<code>&lt;li th:each="opiskelija: ${opiskelijat}"&gt;...&lt;/li&gt;</code>), jonka sisälle haetaan käsiteltävään opiskelijaan liittyvät tiedot.</p>

<pre class="sh_xml">
&lt;!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;

    &lt;head&gt;
        &lt;title&gt;Otsikko&lt;/title&gt;
        &lt;meta charset="utf-8" /&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;h1&gt;Hei maailma!&lt;/h1&gt;

        &lt;h2 th:text="${teksti}"&gt;testi&lt;/h2&gt;

        &lt;ul&gt;
            &lt;li th:each="opiskelija: ${opiskelijat}"&gt;
                &lt;span th:text="${opiskelija.id}"&gt;1&lt;/span&gt; &lt;span th:text="${opiskelija.nimi}"&gt;Essi esimerkki&lt;/span&gt;
            &lt;/li&gt;
        &lt;/ul&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

                <p>Kun sivua tarkastelee selaimesta, näyttää se seuraavalta:</p>

                <figure>
		  <img src="img/viikko6/spark-index-opiskelijat-listana.png" alt="Osoite http://localhost:4567/opiskelijat avattuna. Sivulla näkyy teksti
Hei maailma!

Hei mualima!

1 Ada Lovelace
2 Charles Babbage"/>
		  <figcaption>Osoite http://localhost:4567/sivu avattuna. Opiskelijat näkyvät listattuna.</figcaption>
		</figure>

                <p>Edelläolevassa esimerkissä käydään listalla olevat opiskelijat läpi, ja luodaan niiden perusteella sivulle dataa. Mielenkiintoista esimerkissä on se, että yksittäisen opiskelijan id-kenttään pääsee käsiksi sanomalla (esimerkiksi) <code>&lt;span th:text="${opiskelija.id}"&gt;1&lt;/span&gt;</code>. Tässä Thymeleaf päättelee <code>opiskelija.id</code>-kohdassa, että sen tulee etsiä opiskelija-oliolta <code>getId()</code>-metodia, kutsua sitä, ja asettaa tähän metodin palauttama arvo.</p>

		<h2>Tietokannan käyttöönotto</h2>

		<p>Tietokannan käyttöönotto onnistuu lukua 8 mukaillen. Tällä kertaa tosin hyödynnämme tietokantaa osana web-sovellusta. Opiskelijoiden noutaminen tietokannasta tapahtuisi esimerkiksi seuraavasti:</p>

<pre class="sh_java">
package tikape;

import java.util.HashMap;
import spark.ModelAndView;
import static spark.Spark.*;
import spark.template.thymeleaf.ThymeleafTemplateEngine;
import tikape.database.Database;
import tikape.database.OpiskelijaDao;

public class Main {

    public static void main(String[] args) throws Exception {
        Database database = new Database("jdbc:sqlite:opiskelijat.db");
        database.setDebugMode(true);

        OpiskelijaDao opiskelijaDao = new OpiskelijaDao(database);

        get("/opiskelijat", (req, res) -> {
            HashMap map = new HashMap&lt;&gt;();
            map.put("opiskelijat", opiskelijaDao.findAll());

            return new ModelAndView(map, "index");
        }, new ThymeleafTemplateEngine());
    }
}
</pre>


		<aside class="info">
		  <br/>
		  <h1>Toiseen tietokantaan vaihtaminen</h1>

		<p>JDBC on oikeastaan sekä tapa tietokantayhteyden muodostamiseen, että tietokanta-abstraktio. Tämä tarkoittaa sitä, että suurin osa toteutetusta toiminnallisuudesta voidaan siirtää helpohkosti myös toiselle tietokantamoottorille. Palaamme tähän tarkemmin myöhemmin, harjoituksissa tehtävissä harjoitustehtävissä.</p>
		</aside>




		<aside class="info">
		  <br/>
		  <h1>XML (EXtensible Markup Language)</h1>

		  <p>Näkemämme HTML-kieli on eräänlainen tapa kuvata rakenteellista tietoa, mutta muitakin tapoja löytyy.</p>

		  <p>XML on eräs kieli, jolla kuvataan rakenteellista tietoa. Se koostuu kahdesta osasta, otsakkeesta ja rungosta. Otsake on valinnainen, ja sisältää esimerkiksi dokumentin versionumeron, tiedon käsittelyohjeita, sekä mahdollisia tietoja tiedon rakenteesta. XML-dokumentin runko taas alkaa <em>juurielementistä</em>, joita on vain yksi, jonka alla on yksi tai useampia elementtejä, joilla voi olla arvoja.</p>

		  <p>Alla on esimerkki XML-dokumentista, jossa on kuvattu opiskelijoiden nimiä.</p>

<pre class="sh_xml">
&lt;?xml version="1.0"?&gt;
&lt;opiskelijat&gt;
  &lt;opiskelija&gt;
    &lt;nimi&gt;Ada Lovelace&lt;/nimi&gt;
  &lt;/opiskelija&gt;
  &lt;opiskelija&gt;
    &lt;nimi&gt;Edgar F. Codd&lt;/nimi&gt;
  &lt;/opiskelija&gt;
  &lt;opiskelija&gt;
    &lt;nimi&gt;Lixia Zhang&lt;/nimi&gt;
  &lt;/opiskelija&gt;
&lt;/opiskelijat&gt;
</pre>

		  <p>XML-dokumentin elementit voivat sisältää useita elementtejä. Alla on kuvaus kahdesta kurssista sekä niihin liittyvistä opettajista.</p>

<pre class="sh_xml">
&lt;?xml version="1.0"?&gt;
&lt;kurssit&gt;
  &lt;kurssi&gt;
    &lt;nimi&gt;Ohjelmoinnin perusteet&lt;/nimi&gt;
    &lt;luento&gt;Ma 10-12&lt;/luento&gt;
    &lt;opettaja&gt;
      &lt;nimi&gt;Charles Babbage&lt;/nimi&gt;
    &lt;/opettaja&gt;
  &lt;/kurssi&gt;
  &lt;kurssi&gt;
    &lt;nimi&gt;Tietokantojen perusteet&lt;/nimi&gt;
    &lt;luento&gt;Ti 10-12&lt;/luento&gt;
    &lt;opettaja&gt;
      &lt;nimi&gt;Edgar F. Codd&lt;/nimi&gt;
    &lt;/opettaja&gt;
  &lt;/kurssi&gt;
&lt;/kurssit&gt;
</pre>

		  <p>Tiedon välittämiseen löytyy toki myös useita muita muotoja, joista <a href="http://www.json.org/" target="_blank">JSON</a> on web-maailmassa ehkäpä tällä hetkellä eniten esillä.</p>

		</aside>



    <h1>Tietokantatransaktiot ja ACID</h1>
    
    <p><strong><em>Pohjustusta</em></strong></p>
    
    <p>Tietokantatransaktioiden ymmärtämiseksi on hyvä hieman tuntea tietokannan toimintaa rautatasolla. Tietokanta käyttää kovalevyä/ssd-levyjä tiedon tallentamiseen, mutta rivien käsittely tapahtuu (keskus)muistissa. Kun riviä halutaan päivittää, se haetaan ensin kovalevyltä muistiin, päivitetään ja viedään takaisin levylle.</p>
    
    <p>Keskusmuistin ongelma on se, että sen sisältö häviää esimerkiksi sähkökatkoksen sattuessa tai palvelimen kaatuessa. Havainnollistetaan ongelmallisuutta esimerkeillä:</p>
    
    <ul>
    <li>Annetaan kaikille yrityksen 1000000 kuukausipalkkaiselle työntekijälle 5% palkan korotus. <code>UPDATE Palkat SET kkpalkka = kkpalkka * 1,05</code> Mitä jos tietokantapalvelin kaatuu, kun vasta 10000 muutettua riviä on tallennettu levylle? 990000 vihaista työntekijää jää ilman palkankorotusta? Tarvitaan jokin keino varmistaa, että päivitys tehdään kokonaan tai ei lainkaan.</li>
    <li>Entä jos toinen prosessi lukee palkkatietoja juuri samalla kun niitä ollaan päivittämässä? Lukuoperaatio voi lukea esimerkiksi vain tietyn toimipaikan työntekijöiden palkat - 100 riviä. Jos päivitys on yhtäaikaa kesken, voi käydä niin, että osaan luetuista riveistä on ehditty jo tehdä päivitys ja osaan ei. Nyt osa työntekijöistä saa syyskuun palkkansa korotettuna ja osa ei? Tarvitaan jokin keino hallita yhtäaikaisia prosesseja.
    </ul>
    
    <p><strong><em>Tietokantatransaktiot</em></strong></p>
    
    <p>Tietokantatransaktiot ratkaisevat edellä mainitut ongelmat. Ongelmat voidaan jakaa kahteen kategoriaan:<p>
    
    <ul>
    <li>Operaatioden keskeytymiset järjestelmän kaatuessa, häiriötilanteissa tai hallituissa keskeytyksissä</li>
    <li>Samanaikaset prosessit</li>
    </ul>
    
    <p>Tietokantatransaktio sisältää yhden tai useamman tietokantaan kohdistuvan operaation, jotka suoritetaan (järjestyksessä) kokonaisuutena. Jos yksikin operaatio epäonnistuu, kaikki operaatiot perutaan, ja tietokanta palautetaan tilaan, missä se oli ennen transaktion aloitusta. Klassinen esimerkki tietokantatransaktiosta on tilisiirto, missä nostetaan rahaa yhdeltä tililtä, ja siirretään rahaa toiselle tilille. Jos tilisiirron suoritus ei onnistu -- esimerkiksi rahan lisääminen toiselle tilille epäonnistuu -- tulee myös rahan nostaminen toiselta tililtä perua.</p>

    <p>Jokainen tietokantakysely suoritetaan omassa transaktiossaan, mutta, käyttäjä voi myös määritellä useamman kyselyn saman transaktion sisälle. Transaktio aloitetaan komennolla <code>BEGIN TRANSACTION</code>, jota seuraa kyselyt, ja lopulta komento <code>COMMIT</code>. Oletetaan, että käytössämme on taulu <code>Tili(id, saldo)</code>.</p>

<pre class="sh_sql">
CREATE TABLE Tili 
(
    id integer PRIMARY KEY,
    saldo NOT NULL
)
</pre>

    <p>Tilisiirto kahden tilin välillä toteutetaan yhtenä transaktiona seuraavasti.</p>

<pre class="sh_sql">
BEGIN TRANSACTION;
  UPDATE Tili SET saldo = saldo - 10 WHERE id = 1;
  UPDATE Tili SET saldo = saldo + 10 WHERE id = 2;
COMMIT;
</pre>

    <p>Ylläolevassa transaktiossa suoritetaan kaksi kyselyä, mutta tietokannan näkökulmasta toiminto on <em>atominen</em>, eli sitä ei voi pilkkoa osiin. Komennon <code>COMMIT</code> yhteydessä muutokset joko tallennetaan kokonaisuudessaan tietokantaan, tai tietokantaan ei tehdä minkäänlaisia muutoksia.</p>

    <p>Tietokantatransaktiota kirjoittaessa, ohjelmoija voi huomata tehneensä virheen. Tällöin suoritetaan komento <code>ROLLBACK</code>, joka peruu aloitetun transaktion aikana tehdyt muutokset. Suoritettua (<code>COMMIT</code>) tietokantatransaktiota ei voi perua.</p>

    <p>Alla esimerkki kahdesta tietokantatransaktiosta. Ensimmäinen perutaan, sillä siinä yritettiin vahingossa siirtää rahaa väärälle tilille. Toinen suoritetaan. Kokonaisuudessaan allaolevan kyselyn lopputulos on se, että tililtä 1 on otettu 10 rahayksikköä, ja tilille 2 on lisätty 10 rahayksikköä.</p>

<pre class="sh_sql">
BEGIN TRANSACTION;
  UPDATE Tili SET saldo = saldo - 10 WHERE id = 1;
  UPDATE Tili SET saldo = saldo + 10 WHERE id = 3;
ROLLBACK;

BEGIN TRANSACTION;
  UPDATE Tili SET saldo = saldo - 10 WHERE id = 1;
  UPDATE Tili SET saldo = saldo + 10 WHERE id = 2;
COMMIT;
</pre>

    <p>Jokainen tietokantakysely suoritetaan transaktion sisällä.</p>

    <p><strong><em>Tietokantatransaktiot ja rajoitteet</em></strong></p>

    <p>Koska tietokannanhallintajärjestelmä näkee transaktioiden sisällä suoritettavat käskyt atomisina, eli yksittäisenä kokonaisuutena, voivat tietokantatauluun määritellyt rajoitteet olla hetkellisesti rikki, kunhan ne transaktion suorituksen jälkeen ovat kunnossa.</p>

    <p>Esimerkiksi suomen kirjanpitosääntöjen mukaan jokaisessa yrityksessä tulee olla kaksinkertainen kirjanpito. Tässä jokaisen tilitapahtuman yhteydessä tulee merkitä sekä mistä raha on otettu (debit), että mihin raha on laitettu (credit). Tällaisessa järjestelmässä tulee olla (esimerkiksi) tietokantataulu <code>Kirjanpitotapahtuma</code>, johon muutokset merkitään.</p>

<pre class="sh_sql">
CREATE TABLE Kirjanpitotapahtuma
(
    id integer PRIMARY KEY,
    paivamaara date NOT NULL,
    kirjanpitotili integer NOT NULL,
    kuvaus text NOT NULL,
    debit integer NOT NULL,
    credit integer NOT NULL,
    FOREIGN KEY(kirjanpitotili) REFERENCES Tili(id),
    CONSTRAINT kirjaus_tasmaa CHECK (SUM(debit) = SUM(credit))
)
</pre>

    <p>Nyt yhden transaktion sisällä voi tehdä useamman kirjanpitotapahtuman, kunhan transaktion suorituksen yhteydessä kirjanpitotapahtumien debit- ja credit-sarakkeiden summa täsmää.</p>


    <p><strong>ACID</strong> (<strong>A</strong>tomicity, <strong>C</strong>onsistency, <strong>I</strong>solation, <strong>D</strong>urability) on joukko tietokannanhallintajärjestelmän ominaisuuksia:</p>

    <ul>
      <li>Atomisuudella (<code>Atomicity</code>) varmistetaan, että tietokantatransaktio suoritetaan joko kokonaisuudessaan tai ei lainkaan. Jos tietokannanhallintajärjestelmään tehtävät transaktiot eivät olisi atomisia, voisi esimerkiksi päivityskyselyistä päätyä tietokantaan asti vain osa -- tilisiirtoesimerkissä vain rahan ottaminen yhdeltä tililtä, mutta ei sen lisäämistä toiselle.</li>
      
      <li>Eheydellä (<code>Consistency</code>) varmistetaan, että tietokantaan määritellyt rajoitteet, kuten viiteavaimet, pätevät jokaisen transaktion jälkeen. Jos tietokanta ei mahdollistaisi eheystarkistusta, voisi esimerkiksi kirjanpito olla virheellinen.</li>
      <li>Eristäytyneisyydellä (<code>Isolation</code>) varmistetaan, että transaktio (A) ei voi lukea toisen transaktion (B) muokkaamaa tietoa ennenkuin toinen transaktio (B) on suoritettu loppuun. Tällä varmistetaan se, että jos transaktioita suoritetaan rinnakkaisesti, kumpikin näkee tietokannan eheässä tilassa.</li>

      <li>Pysyvyydellä (<code>Durability</code>) varmistetaan, että transaktion suorituksessa tapahtuvat muutokset ovat pysyviä. Kun käyttäjä lisää tietoa tietokantaan, tietokannanhallintajärjestelmän tulee varmistaa että tieto säilyy myös virhetilanteissa (jos transaktion suoritus onnistuu).</li> 

   </ul>

   <p>DBMS:t toteuttavat ACID-ominaisuudet käyttäen write-ahead-lokia (WAL). Se tarkoittaa sitä, että suoritettavaksi tuleva tietokantaoperaatio tallennetaan lokina levylle ennen rivien varsinaista päivitystä. Tällöin operaatiot voidaan suorittaa uudelleen, jos tietokantapalvelin kaatuu ennen kuin muistissa päivitetyt rivit ehditään tallentaa levylle. Tämä nopeuttaa tietokannan toimintaa merkittävästi, sillä pitkien operaatioden suorituksen valmistumista ei tarvitse odottaa ennen kuin sovellukselle voidaan vastata operaation onnistuneen. Kurssilla <em>Transaktioiden hallinta</em> tutustutaan tarkemmin transaktioiden toimintaan.</p>
   



		<header>
		  <h1 id="viikko5">Viikko 5</h1>
		</header>


<h1>NoSQL eli jotain muuta kuin relaatiomallia noudattavat tietokannat</h1>

<p>
Relaatiomalli ja SQL ovat hyvin ilmaisuvoimainen kombinaatio ja relaatiotietokannoilla pystytään ainakin teoriassa hoitamaan lähes kaikki mahdolliset tiedonhallintatarpeet. Relaatiotietokannat dominoivatkin tietokantaskeneä muutaman kymmenen vuoden ajan. 2000-luvulla alkoi kuitenkin nousta esiin uudentyyppisiä tietokantaratkaisuja, joita kuvaamaan lanseeratiin vuonna 2009 termi <em>NoSQL</em>.
</p>

<h2>Syitä uusien tietokantaratkaisujen syntyyn</h2>

<p>
Motivaatiota NoSQL-tietokantojen syntyyn oli muutamia. Ehkä tärkeimpänä tekijänä olivat massiivisen skaalan internetpalveluiden, esim. Amazonin ja Googlen käsittelemät tietomäärät, jotka edellyttävät tiedon hajautettua tallentamista ja käsittelyä. Relaatiomallia oli mahdotonta saada skaalautumaan palveluiden tarpeeseen ja monet yhtiöt kehittivät omia, aivan uudenlaisia tietokantaratkaisuja. Yhteistä näille oli se, että ne <em>skaalautuivat</em> hyvin, eli niiden suorituskyky oli mahdollista pitää riittävällä tasolla liittämällä tietokantaan uusia "koneita" kuormituksen kasvaessa, ja myös se, että toiminnallisuudeltaan ratkaisut olivat paljon rajoittuneempia kuin relaatiotietokannat.
</p>

<p>
Useimmat uudet tietokantaratkaisut tarjoavat paljon suppeamman kyselykielen kuin SQL ja ne eivät tue ACID-ominaisuuksia takaavia transaktioita. Hyvin tavanomaista uusissa tietokannoissa on se, että ne eivät yritäkään tarjota samanlaista ajantasaisuutta kuin relaatiotietokannat, eli sen sijaan, että kaikki kannan käyttäjät näkisivät tietokannan tilan koko ajan samanlaisena (ACID:in C eli consistency), on käytössä <em>eventual consistency</em> -malli, jossa periaatteena on, että jokainen tietokantaan tehty muutos näkyy kaikille käyttäjille ennemmin tai myöhemmin, mutta ei välttämättä heti, eli jonkun aikaa tilanne voi olla se, että tietokannan eri käyttäjät näkevät tietokannan tilan hieman erilaisena. Jos ajatellaan monia internetpalveluita täydellinen konsistenssi ei ole kaikkien operaatioiden suhteen välttämätöntä, ei esim. haittaa vaikka yksittäisen käyttäjän Facebook-päivitykset eivät ilmesty kaikille käyttäjolle aivan samalla hetkellä.
</p>

<p>
Toisena vahvana motivaationa uusien tietokantamallien kehittymiselle oli tarve joustavammille tavoille tallettaa erimuotoista dataa. Relaatiomalli nojaa vahvasti siihen että kannan skeema, eli taulut ja taulujen sarakkeet on ennalta määritelty. Jos syntyy usein tarve tallettaa uudenlaista dataa, esim. tauluihin tulee viikoittain uusia sarakkeita, tai jopa uudenlaisia tauluja, on relaatiomalli kankeahko. Toisaalta myös tarve tallettaa jokainen "asia" omaan tauluunsa tekee relaatiomallista kankean ja kyselyllisestikin raskaan tiettyihin käyttötarkoituksiin. Lääkkeenä näihin ongelmiin on syntynyt tietokantaratkaisuja, joissa datan skeema on huomattavasti löyhemmin määritelty kuin relaatiomallissa. Monissa uusissa tietokantatyypeissä data on tietokannan kannalta jopa täysin skeematonta, eli "tauluihin" voi tallettaa vapaamuotoista dataa, ja vastuu tiedon muodon oikeellisuudesta on siirretty täysin tietokannan käyttäjäjälle.
</p>

<h2>Erityyppiset NoSQL-tietokannat</h2>

<p>
Kaikki relaatiotietokannat ovat enemmän tai vähemmän samanlaisia ja tarjoavat standardoidun tavan eli SQL:n tietojen kyselyyn, ylläpitoon sekä tietokantaskeemojen muokkaukseen. NoSQL-tietokantojen kohdalla tilanne on täysin erilainen, ne ovat tiedon organisaatiotavoiltaan hyvinkin erilaisia ja mitään SQL:ää vastaavaa standardoitua kyselykieltä ei ole, kaikilla NoSQL-tietokannoilla on oma tapansa kyselyjen muodostamiseen.
</p>

<p>
NoSQL-tietokannat voidaan jakaa tiedon organisointitapansa perusteella neljään eri luokkaan:
</p>

<ul>
<li>avain-arvotietokantoihin (engl. key value databases),</li>
<li>dokumenttitietokantoihin (engl. document databases),</li>
<li>saraketietokantoihin (engl. columnar databases) ja</li>
<li>verkkotietokantoihin (engl. graph databases)</li>
</ul>

<p>
Tarkastellaan nyt erilaisia NoSQL-tietokantoja hieman tarkemmin.
</p>

<h3>Avain-arvotietokannat, Redis</h3>

<p>
Avain-arvotietokannat tarjoavat erittäin rajoitetun tietomallin. Kantaan talletetaan <em>arvoja</em> sekä arvon yksilöiviä <em>avaimia</em>. Tietokannan suhteen talletettavilla arvoilla ei ole (yleensä) mitään skeemaa eli rakennetta. Sovellusten on tulkittava kantaan talletettavat arvot haluamallaan tavalla esim. tietyn tyyppisenä oliona. Koska tietokanta on täysin skeematon, eivät avain-arvotietokannat tue viitteitä kantaan talletettujen arvojen välillä, eli mitään relaatiotietokantojen liitosta vastaavaa käsitettä ei avain-arvotietokannoilla ole.
</p>

<p>
Avain-arvotietokantojen tarjoamat kyselymahdollisuudet ovat erittäin rajoittuneet, yleensä on ainoastaan mahdollista hakea kannasta tiettyä avainta vastaava arvo.
</p>

<p>
Tarkastellaan nyt <a href="http://redis.io/">Redisiä</a> joka on eräs suosituimmista avain-arvotietokannoista.
</p>
<p>
Redisin perusoperaatiot ovat <code>set</code>, <code>get</code> ja <code>del</code> joiden avulla käsitellään merkkijonomuotoisena talletettavia arvoja.
</p>

<p>
Seuraavassa esimerkissä käynnistetään Redis-konsoli, asetetaan arvo avaimille <em>arto, aino</em> ja <em>olli</em>. Haetaan kannasta muutamaa avainta vastaavia tietoja ja tuhotaan avaimeen <em>arto</em> liittyvä arvo.
</p>

<pre>
melkki$ redis-cli
127.0.0.1:6379> set arto "olen arto 29 vuotta, yliopisto-opettaja"
OK
127.0.0.1:6379> set aino "olen aino 21 vuotta, pajaohjaaja"
OK
127.0.0.1:6379> set olli "olen olli 19 vuotta, fuksi"
OK
127.0.0.1:6379> get pekka
(nil)
127.0.0.1:6379> get arto
"olen arto 29 vuotta, yliopisto-opettaja"
127.0.0.1:6379> del arto
127.0.0.1:6379> get arto
(nil)
127.0.0.1:6379> get aino
"olen aino 21 vuotta, pajaohjaaja"
127.0.0.1:6379>
</pre>

<p>
Redis on siis erittäin yksinkertainen ja toimii oikeastaan hyvin samaan tapaan kuin Javan <code>HashMap</code> sillä erotuksella, että Redisiin ei voi helposti tallentaa normaaleja oliota, ja että Redisiin tallennetut arvot säilyvät vaikka ohjelma uudelleenkäynnistettäisiin.
</p>

<p>
Redis tajoaa tuen myös arvoille jotka ovat lukuja, joukkoja tai hashejä eli itsessään avain-arvo-pareja.
</p>

<p>
Mitä järkeä avain-arvotietokannoissa on? Ne vaikuttavat ominaisuuksiltaan erittäin rajoittuneilta ja relaatiotietokannoilla pystyy tekemään varmasti kaikki ne asiat, joihin avain-arvotietokannat pystyvät. Rajoituksistaan johtuen avain-arvotietokannat ovat kuitenkin suorituskyvyltään ja skaalautuvuudeltaan huomattavasti parempia kuin relaatiotietokanta, ja niiden avulla pystytään kuitenkin ratkaisemaan monia sovellusten käyttötarpeita. Viime aikoina on kuitenkin ollut nousussa trendi, jonka nimitys englanniksi on
<a href="http://martinfowler.com/bliki/PolyglotPersistence.html">polyglot persistance</a>, joka tarkoittaa suurinpiirtein sitä, että sovelluksessa on useita erityyppisiä tietokantoja ja kuhunkin käyttötarkoitukseen käytetään tarkoituksenmukaisinta ratkaisua.
</p>

<p>
Eräs hyvin yleinen käyttötarkoitus avain-arvotietokannoille on raskaiden operaatioiden tulosten väliaikainen talletus (engl. caching) mahdollisia uusia saman operaatioiden suorituksia varten.
</p>

<p>
Tarkastellaan tästä estimerkkinä internetistä <a href="http://openweathermap.org/api">Open Weather API:sta</a> eri kaupunkien säätietoja hakevaa ohjelmaa. Ohjelma toiminta näyttää seuraavalta:
</p>

<pre>
kaupunki: helsinki
few clouds, temperature 15.770000000000039 celcisus
kaupunki: turku
Sky is Clear, temperature 16.0 celcisus
kaupunki: vladivostok
scattered clouds, temperature 11.360000000000014 celcisus
kaupunki:
</pre>

<p>
Jokaisen kaupungin kohdalla ohjelma hakee kaupungin säätiedot internetistä. Tiedon haku verkosta on kuitenkin hidas ja resurssien kulutuksen suhteen "kallis" operaatio (asialla voisi olla merkitystä jos ohjelmallamme olisi satoja tai tuhansia yhtäaikaisia käyttäjiä). Koska säätiedot pysyvät suunnilleen samana useiden minuuttien ajan, ohjelmaa voi optimoida siten, että kun käydään kerran hakemassa jonkun kaupungin säätiedot, talletetaan tieto joksikin aikaa Redisiin. Jos kaupungin säätä kysytään pian uudelleen, saadaan vastaus nopeasti ilman kallista internetoperaatiota. Noudatetaan siis näytettävien säätietojen suhteen eventual consistency -mallia.
</p>

<p>
Seuraavassa sääpalvelun toteuttavan luokan <stron>WeatherService</strong> toteutus, joka hyödyntää
<a href="https://github.com/xetorthio/jedis">Jedis</a>-kirjastoa Redis-operaatioiden tekemiseen:
</p>

<pre class="sh_java">
import redis.clients.jedis.Jedis;

public class WeatherService {
    private Jedis jedis;

    public WeatherService() {
        // luodaan yhteys paikallisen koneen Redisiin
        jedis = new Jedis("localhost");
    }

    public void weatherOf(String city) throws Exception {
        // kutsutaan metodia, joka hakee tiedot joko
        // Redisistä tai internetistä
        JsonElement weatherData = getDataFor(city);

        // haetaan vastauksen sisältä oikeat osat
        double temperature = getTemperatureFrom(weatherData);
        String desc = getDescriptionFrom(weatherData);

        System.out.println(desc + ", temperature "+temperature+ " celcisus");
    }

    // metodi joka hakee tiedot joko Redisistä tai internetistä
    private JsonElement getDataFor(String city) throws Exception {
        // etsitään kaupungin city säätietoja Redisistä
        String weatherInfo = jedis.get(city);

        // jos ei löytyny
        if (weatherInfo==null) {
            // haetaan tiedot internetistä
            weatherInfo = readFromUrl("http://api.openweathermap.org/data/2.5/weather?q="+city);

            // ja talletetaan ne Redisiin
            jedis.set(city, weatherInfo);
            // määritellään tallennusajaksi 10 minuuttia eli 600 sekuntia
            jedis.expire(city, 600);
        }

        // palautetaan tuote oikein muotoiltuna
        return new JsonParser().parse(weatherInfo);
    }

    // apumetodeja...
}
</pre>

<p>
Palvelua käytetään seuraavasti:
</p>

<pre class="sh_java">
  WeatherService weather = new WeatherService();
  weather.weatherFor("Helsinki");
</pre>

<p>
Kun haemme ensimmäistä kertaa esim. Helsingin tietoja, etsitään niitä (metodissa <code>getDataFor</code>) ensin rediksestä:
</p>

<pre class="sh_java">
  // nyt city = "Helsinki"
  String weatherInfo = jedis.get(city);
</pre>

<p>
tiedot eivät löydy, joten metodi palauttaa <code>null</code>. Tämän takia mennään if-haaraan, jossa tiedot haetaan apumetodin avulla internetistä. Haetut tiedot talletetaan ensin Redisiin:
</p>

<pre class="sh_java">
  // nyt city="Helsinki" ja weatherInfo Helsingin sään 'raakadata'
  jedis.set(city, weatherInfo);
</pre>

<p>
talletetulle datalle asetetaan myös elinaika sekunteina:
</p>

<pre class="sh_java">
  jedis.expire(city, 600);
</pre>

<p>
tämän jälkeet data palautetaan kutsujalle.
</p>

<p>
Jos Helsingin säätietoja haetaan 600 sekunnin sisällä uudelleen, löytyvät tiedot suoraan Redisistä. 600 sekunnin kuluttua hakuoperaatio <code>jedis.get('Helsinki')</code> palauttaa jälleen <code>null</code> ja tuore säätilanne haetaan internetistä.
</p>

<p>
Ohjelman koodi kokonaisuudessan löytyy
<a href="https://github.com/tietokantojen-perusteet/WeatherApp">GitHubista</a>
</p>

<p>
<a href="http://db-engines.com/en/ranking/key-value+store">Lista</a> suosituimmista avain-arvotietokannoista.
</p>

<h3>Dokumenttitietokannat, MongoDB</h3>

<p>
Dokumenttitietokantojen voi ajatella sijoittuvan jonnekin relaatiotietokantojen ja avain-arvotietokantojen puolen välin tienoille. Dokumenttikannat perustuvat avain-arvotietokantojen tapaan arvojen tallettamiseen avaimen perusteella. Arvot tai <em>dokumentit</em> kuten niitä dokumenttikantojen kontekstissa nimitetään voivat kuitenkin olla itsessään hyvin monimutkaisia oliota, jotka sisältävät kenttiä, joiden arvona voi olla joko normaaleja arvoja kuten lukuja ja merkkijonoja tai muita olioita. Toisin kuin avain-arvotietokannoissa, dokumenttikannat "näkevät" tietokantaan talletettujen dokumenttien sisään, ja mahdollistavat talletettujen dokumenttien sisällön suhteen tehdyt kyselyt.
</p>

<p>
Käytetään seuraavassa esimerkkinä ylivoimaisesti suosituimman dokumenttitietokannan <a href="https://www.mongodb.org/">MongoDB:n</a> merkintöjä.
</p>

<p>
Dokumenttikannoissa käytetään tiedon loogisena esitysmuotona yleensä <a href="https://fi.wikipedia.org/wiki/JSON">JSON</a>:ia. Seuraavassa kurssia </em>Ohjelmoinnin perusteet</em> esittävä JSON-dokumentti:
</p>

<pre class="sh_jscript">
{
  "id": ObjectId("10"),
  "nimi": "Ohjelmoinnin perusteet",
  "laajuus": 5,
  "luennot": [ "Arto Vihavainen", "Matti Luukkainen" ]
}
</pre>

<p>
JSON-dokumentti koostuu avain-arvo-pareista. Avainta vastaava arvo merkitään kaksoispisteellä erotettuna avaimen yhteyteen.
</p>

<p>
Kurssi-dokumentissa on siis neljä avain-arvo-paria. Voidaankin ajatella että kurssilla on neljä kenttää. Näistä kentistä erikoisasemassa on MongoDB:n dokumentille automaattisesti generoima avainkenttä <code>id</code> jonka arvo on tyypiltään <code>ObjectId</code>.
Poikkeavaa relaatiotietokantoihin nähden on se, että kentän arvona voi olla taulukko.
</p>

<p>
Seuraavassa on opiskelijaa kuvaava dokumentti:
</p>

<pre class="sh_jscript">
{
  "id" : ObjectId("59"),
  "nimi" : "Pekka Mikkola",
  "opiskelijanumero" : 14112345,
  "osoite" : {
                "katu" : "Tehtaankatu 10 B 1",
                "postinumero" : "00120",
                "postitoimipaikka" : "Helsinki"
             }
}
</pre>

<p>
Nyt kentän osoite arvona on <em>olio</em>, jolla on itsellään omat kenttänsä.
</p>

<p>
Dokumenttitietokannassa dokumentit on lajiteltu <em>kokoelmiin</em> (engl. collection). Kokoelman merkitys on suunnilleen sama kuin taulun relaatiotietokannassa. Yhdessä kokoelmassa olevien dokumenttien ei kuitenkaa tarvitse olla kentiltään samanlaisia. Kenttiä voi olla vaihteleva määrä ja saman nimiset kentät voivat sisältää eri dokumenteilla eri tyyppisen arvon. Kokoelmille ei määritellä dokumenttikannoissa minkäänlaista skeemaa, eli on täysin sovellusten vastuulla, että kantaan talletetaan järkevää dataa, ja että kannasta luettava data tutkitaan oikein.
</p>

<p>
Kuten edellä opiskelijan kohdalla näimme, on dokumenttikannoissa mahdollista sisällyttää olioita toistensa sisään. Tilanne olisi myös voitu mallintaa "relaatiomallin tapaan" siten, että osoitteita varten olisi oma kokoelmansa, ja yksittäinen osoite mallinnettaisiin omana dokumenttina:
</p>

<pre>
{
  "id" : ObjectId("123"),
  "katu" : "Tehtaankatu 10 B 1",
  "postinumero" : "00120",
  "postitoimipaikka" : "Helsinki"
}
</pre>

Opiskelijadokumentti sisältäisi nyt ainoastaan viitteen osoitedokumenttiin:

<pre>
{
  "id" : ObjectId("59"),
  "nimi" : "Pekka Mikkola",
  "opiskelijanumero" : 14112345,
  "osoite" : ObjectId("123")
}
</pre>

<p>
Toisin kuin relaatiotietokantojen tapauksessa, dokumenttikannat <em>eivät tarjoa</em> tietokannan tasolla tapahtuvia <em>liitosoperaatiota</em>, ja edellisen esimerkin tapauksessa sovelluksen olisi itse huolehdittava siitä, että opiskelijaa haettaessa haetaan myös opiskelijan osoite tietokannasta.
</p>

<p>
Vaikka operaatio ei olekaan dokumenttikannan tasolla tuettu, on olemassa monia kirjastoja (esim. Javalle <a href="https://mongodb.github.io/morphia/">Morphia</a>), jotka toteuttavat ohjelmallisen liitosoperaation siten, että sovellusohjelman ei tarvitse siitä huolehtia.
</p>

<p>
Relaatiotietokannoissa kannan skeeman muodostaminen on sikäli helppoa, että jos pyritään normalisoituun ratkaisuun on useimmissa tilanteissa olemassa noin yksi "järkevä" ratkaisu, joka toimii lähes yhtä hyvin riippumatta siitä miten kantaa käytetään.
</p>

<p>
Dokumenttikantojen suhteen tilanne on toinen. Tarkastellaan esimerkiksi Kursseja ja Opiskelijoiden kurssisuorituksia. Relaatiotietokannassa tilanne olisi suoraviivainen, <em>Suoritus</em> olisi <em>Kurssin</em> ja <em>Opiskelijan</em> liitostaulu.
</p>

<p>
Eräs mahdollisuus olisi tehdä täsmälleen sama ratkaisu dokumenttikannassa.
</p>

<p>
Kokoelma Opiskelija:
</p>

<pre class="sh_js">
[
  {
    "id": ObjectId("10"),
    "nimi" : "Lea Kutvonen",
    "opiskelijanumero" : 13457678
  },
  {
    "id": ObjectId("11"),
    "nimi" : "Pekka Mikkola",
    "opiskelijanumero" : 14012345
  }
]
</pre>

<p>
Kokoelma kurssi:
</p>

<pre class="sh_js">
[
  {
    "id": ObjectId("34"),
    "nimi" : "Ohjelmoinnin perusteet",
    "laajuus" : 5
  },
  {
    "id": ObjectId("35"),
    "nimi" : "Tietokone työvälineenä",
    "laajuus" : 1
  }
]
</pre>

<p>
Suoritus olisi nyt "liitostaulumainen" kokoelma:
</p>

<pre class="sh_js">
[
  {
    "id": 55
    "kurssi_id" : ObjectId("34"),
    "opiskelija_id" : ObjectId("10"),
    "arvosana" : 4
  },
  {
    "id": 56
    "kurssi_id" : ObjectId("35"),
    "opiskelija_id" : ObjectId("10"),
    "arvosana" : 5
  },
  {
    "id": 57
    "kurssi_id" : ObjectId("35"),
    "opiskelija_id" : ObjectId("11"),
    "arvosana" : 2
  }
]
</pre>

<p>
Vaihtoehtoja on kuitenkin myös muita. Käyttötapauksista riippuen saattaisi olla edullista tallettaa tieto suorituksista ("liitosdokumentin" id) myös kurssin ja opiskelijan yhteyteen:
</p>

<p>
Kokoelma Opiskelija:
</p>

<pre>
[
  {
    "id": ObjectId("10")
    "nimi" : "Lea Kutvonen",
    "opiskelijanumero" : 13457678,
    "suoritukset" : [ ObjectId("55"), ObjectId("56") ]
  },
  {
    "id": ObjectId("11")
    "nimi" : "Pekka Mikkola",
    "opiskelijanumero" : 14012345,
    "suoritukset" : [ ObjectId("57") ]
  }
]
</pre>

<p>
Kokoelma kurssi:
</p>

<pre>
[
  {
    "id": ObjectId("34")
    "nimi" : "Ohjelmoinnin perusteet",
    "laajuus" : 5,
    "suorittajat" : [ObjectId("10")]
  },
  {
    "id": ObjectId("35")
    "nimi" : "Tietokone työvälineenä",
    "laajuus" : 1,
    "suorittajat" : [ObjectId("10"), ObjectId("11")]
  }
]
</pre>

<p>
Jossain tapauksessa paras ratkaisu olisi luopua liitoksena toimivista dokumenteista eli kokoelmasta suoritukset ja tallettaa suoritukset kokonaisuudessaan opiskelija-dokumentteihin:
</p>

<pre>
[
  {
    "id": ObjectId("10")
    "nimi" : "Lea Kutvonen",
    "opiskelijanumero" : 13457678,
    "suoritukset" : [
      {
        "id": 55
        "kurssi_id" : ObjectId("34"),
        "arvosana" : 4
      },
      {
        "id": 56
        "kurssi_id" : ObjectId("35"),
        "arvosana" : 5
      }
    ]
  },
  {
    "id": ObjectId("11")
    "nimi" : "Pekka Mikkola",
    "opiskelijanumero" : 14012345,
    "suoritukset" : [
      {
        "id": 57
        "kurssi_id" : ObjectId("35"),
        "arvosana" : 2
      }
    ]
  }
]
</pre>

<p>
Tämä ratkaisu vaikeuttaisi kurssin suorittajien selvittämistä, joten joissain käyttötapauksissa saattaisi olla edullista sisällyttää suoritukset <em>molempiin</em> opiskelijoihin ja kurssiin.
</p>

<p>
Yhtä "oikeaa" vastausta miten sovelluksen data kannattaa mallintaa dokumenttikannan kokoelmiksi ja dokumenteiksi ei ole olemassa. Parhaaseen tapaan vaikuttaa suuresti se minkälainen käyttöprofiili rakennettavalla sovelluksella on: datamalli kannattaa valita siten, että se tekee yleisimpien operaatioiden suorituksen nopeaksi ja helpoksi.
</p>

<p>
Kuten jo totesimme, dokumenttikannat eivät tue liitosoperaatioita, ja kyselyt kohdistuvat aina vain yhteen kokoelmaan. Dokumenttikannoilla ei ole mitään standardoitua kyselykieltä, jokaisen kannan kyselykieli on täysin omanlaisensa. Esim. MongoDB:n kyselykieli ei muistuta kovinkaan läheisesti SQLää.
</p>

<p>
Dokumenttikannat eivät myöskään tue useamman kokoelman yhtäaikaista muuttamista transaktionaalisesti. Kaikki yhteen kokoelmaan suoritettavat tapahtumat tehdään kuitenkin aina transaktionaalisesti.
</p>

<p>
Lisää MongoDB:stä ja sen käytöstä eri ohjelmointikielistä käsin löydät esim. osoitteesta <a href="https://docs.mongodb.org/manual/">https://docs.mongodb.org/manual/</a>
</p>
<p>
<a href="http://db-engines.com/en/ranking/document+store">Lista suosituimmista</a> dokumenttitietokannoista.
</p>

<h3>Saraketietokannat</h3>

<p>
Relaatiomalli sopii suhteellisen hyvin tilanteisiin, joissa tietoa käsitellään lyhyin, pääasiassa taulun yksittäisiin riveihin kohdistuvin operaatioin (englanniksi tälläisestä tiedonkäsittelystä käytetään nimitystä <em>online transaction processing, OLTP</em>). Näin tapahtuu esimerkiksi pankin asiakastietokannassa kun asiakkaat tekevät saldokyselyjä, nostavat rahaa tai tekevät tilisiirtoja.
</p>

<p>
Tietokantojen käyttö on aivan erilaista silloin kun tavoitteena on luoda raportteja tai analysoida dataa eri tavoin, esim. selvittää pankin asiakkaiden keskimääräinen saldo tietyllä aikavälillä. Tällöin kyselyt kohdistuvat lähes koko tauluun, mutta usein vain pieneen osaan taulun sarakkeissa
(englanniksi tälläisestä tiedonkäsittelystä käytetään nimitystä <em>online analytical processing, OLAP</em>).
Analyysitietokannoissa tilanne on usein se, että tieto ei ole normalisoidussa muodossa, yksittäiset taulut saattavat sisältää satojakin sarakkeita, mutta toisaalta läheskään kaikilla sarakkeilla ei ole kannassa arvoja. Näissä tilanteissa relaatiotietokantojen suorituskyky saattaa olla huono, ja <em>saraketietokannat</em> (engl. columnar databases) voivat tarjota huomattavasti paremman vaihtoehdon.
</p>

<p>
Tarkastellaan tilannetta esimerkin kautta. Oletetaan, että analyysiin käytettyyn tietokantaan on talletettu firman työntekijöitä:
</p>

<pre>
EmpId Lastname  Firstname Sex Salary  YearsEmployed
10    Smith     Joe       M   40000   1
12    Jones     Mary      F   50000   6
11    Johnson   Cathy     F   44000   3
22    Jones     Bob       M   55000   9
</pre>

<p>
Relaatiotietokannat tallettavat tiedon levylle <em>riveittäin</em>, eli taulu tallentuisi levylle seuraavasti:
</p>

<pre>
10;Smith;Joe;M;40000;1;12;Jones;Mary;F;50000;6;11;Johnson;Cathy;F;44000;3;...
</pre>

<p>Jos nyt haluttaisiin selvittää yrityksessä vähintään 5 vuotta työskennelleiden keskipalkka, tehtäisiin kysely
</p>

<pre class="sh_sql">
SELECT AVG(Salary)
  FROM Employees
  WHERE YearsEmployed &gt; 4
</pre>

<p>
Tässä olisi relaatiotietokannan tapauksessa luettava taulun <em>koko data</em> levyltä siitä huolimatta, että kysely ei tarvitse kuin pientä osaa taulun datasta. Jos taulussa olisi satoja sarakkeita (mikä on varsin tyypillistä analytiikkatietokannoissa), olisi kyselyn tekeminen erittäin hidasta johtuen juuri tarpeettoman raskaasta, kaiken datan hakevasta levyoperaatiosta.
</p>

<p>
Saraketietokannoissa tiedot talletetaan sarakkeittain, karkeasti ottaen jokainen sarake tai usein yhdessä käytettyjen sarakkeiden ryhmä omaan tiedostoonsa. Edellinen tietokanta siis talletettaisiin kutakuinkin seuraavasti
</p>

<pre>
EmpId: 10;12;11;22

Lastname:Smith;Jones;Johnson;Jones

Firstname:Joe;Mary;Cathy;Bob

Sex:M;F;F;M

Salary:40000;50000;44000;55000

YearsEmployed:1;6;3;9
</pre>

<p>
Tehtäessä sama kysely, riittäisi että levyltä luettaisiin ainoastaan kyselyn kannalta tarpeellisten sarakkeiden <em>Salary</em> ja <em>YearsEmployed</em> tieto. Jos sarakkeita olisi suuri määrä, ero riveittäin talletettuun tietokantaan olisi suorituskyvyn suhteen huomattava.
</p>

<p>
Vanhemmman sukupolven saraketietokannoissa data on organisoitu relaatiotietokantojen tapaan tauluihin ja dataa hallitaan SQL:llä. Vanhemman polven saraketietokantoja ei välttämättä edes luokitella NoSQL-kannoiksi. Uudemman polven saraketietokannat taas noudattavat enemmän yhden tai muutaman ison tai "leveän" taulun skeematonta mallia. Tauluissa on sarakkeita erittäin suuri määrä, mutta läheskään kaikilla sarakkeilla ei ole arvoa. Näiden esikuvana on Googlen vuodesta 2004 asti kehittämä <a href="https://en.wikipedia.org/wiki/BigTable">BigTable</a>. Uuden polven ratkaisut mahdollistavat massiivisten datamäärien rinnakkaiskäsittelyn.
</p>

<p>
<a href="http://db-engines.com/en/ranking/wide+column+store">Suosituimmat</a> uuden sukupolven saraketietokannat.
</p>

<h3>Verkkotietokannat</h3>

<p>
Relaatiotietokannat ja esittelemämme NoSQL-kantatyypit keskittyvät <em>dataentiteettien</em> esittämiseen. Relaatiotietokannat esittävät entiteetit taulujen riveinä, esim. Henkilö-taulussa jokainen ihminen esitettään omana rivinään. Yhteydet ja suhteet eri entiteettien välillä esitetään epäsuorasti vierasavaimien ja liitostaulujen avulla. Itse yhteys, esim. <em>missä henkilö Arto on töissä</em> saadaan selville vasta kyselyn aikana tapahtuvan liitosoperaation avulla.
</p>
<p>
Joissain tilanteissa entiteettien suhteiden selvittäminen relaatiotietokannassa saattaa olla erittäin hankalaa. Oletetaan, että meillä on Henkilöitä kuvaava taulu:
</p>

<pre class="sh_sql">
CREATE TABLE Henkilo (
  id integer not null PRIMARY KEY,
  nimi string not null
)
</pre>

<p>
sekä taulu, joka liittää vanhemmat ja lapset toisiinsa:
</p>

<pre class="sh_sql">
CREATE TABLE Vanhemmuus (
  id integer not null PRIMARY KEY,
  lapsi_id integer,
  vanhempi_id integer,
  FOREIGN KEY (lapsi_id) references Henkilo(id),
  FOREIGN KEY (vanhempi_id) references Henkilo(id)
)
</pre>

<p>Jos nyt haluaisimme selvittää henkilön "Arto Vihavainen" kaikki sukulaiset, huomaamme, että kyselyn tekeminen SQL:llä olisi erittäin hankalaa.
</p>

<p>
Tilanne mutkistuisi entisestään jos haluaisimme kuvata myös muunlaisia suhteita, esim. henkilöiden työsuhteita firmoihin, jäsenyyksiä yhdistyksiin, ystävyyttä, omistussuhteita erilaisiin asioihin sekä asioista tykkäämisiä ja vihaamisia. Yksi vaikeuttava tekijä olisi se, että kaikki erilaiset suhteet pitäisi mallintaa omina liitostauluinaan. Jos ohjelmassa käytettävät suhdetyypit lisääntyisivät, tulisi tietokantaskeemaan lisätä koko ajan uusia erityyppisiä liitostauluja. Myös kyselyt muuttuisivat koko ajan hankallimmaksi ja vaatisivat yhä monimutkaisempia, raskaita liitosoperaatioita. Esim. seuraavien asioiden selvittäminen olisi SQL:llä melko työlästä:
</p>

<ul>
<li>Arton kaikkien esivanhempien työpaikat</li>
<li>Kirjat joista Arton esivanhemmat pitivät</li>
<li>Arton ystävistä ja ystävien ystävistä, ja näiden ystävistä jne kaikki ne, jotka ovat opiskelleet samassa paikassa kun Arto</li>
</ul>

<p>
Ratkaisun tämänkaltaisiin tilanteisiin tuovat <em>verkkotietokannat</em>, jotka mallintavat eksplisiittisesti sekä entiteetit eli esim. henkilöt ja niiden ominaisuudet että entiteettien väliset suhteet kuten sukulaisuuden henkilöiden välillä. Kuten nimestä voi päätellä, on verkkotietokannan pohjalla olevana tietorakenteena verkko (engl. <em>graph</em>), joka koostuu entiteettejä kuvaavista <em>solmuista</em> (engl. <em>node</em>) ja niiden välisiä suhteita kuvaavista <em>kaarista</em> (engl. <em>edge</em>). Sekä solmuilla, että kaarilla voi olla attribuutteja. Verkko, joka kuvaa yllä olevan esimerkin mallintamista verkkotietokannan solmuiksi ja kaariksi:
</p>

<figure>
  <img src="img/viikko7/verkkokanta.png" alt="Verkkotietokanta">
</figure>

<p>
Verkkotietokannat tarjoavat kyselykielen, jonka avulla on helppo "navigoida" verkossa. Toisin kuin relaatiotietokannoissa, jotka edellyttävät yhteyden muodostamiseen laskennallisesti kallista join-operaatiota, yhteyksien navigointi verkkotietokannassa on nopeaa. Verkkotietokannoille ei ole olemassa yhtä vakiintunutta kyselykieltä. On kuitenkin tiettyjä kyselykieliä, kuten tämän hetken suosituimman verkkotietokannan <a href="http://neo4j.com">Neo4J:n</a> käyttämä
<a href="http://neo4j.com/developer/cypher-query-language/">Cypher</a>, joita jotkut muutkin verkkotietokannat tukevat.
</p>

<p>
Seuraavassa muutama esimerkki ylläolevaan verkkotietokantaan kohdistetuista Cypherillä tehdyistä kyselyistä. Haetaan ensin Arton vanhemmat
</p>

<pre>
MATCH ({ name:"Arto" }) -[:CHILD_OF]-> (parent)
RETURN parent
</pre>

<p>
MATCH-määre hakee ensin solmun, jonka nimenä on <em>Arto</em> ja sen jälkeen seurataan kaarta <em>:CHILD_OF</em> pitkin solmun vanhempiin, jotka kysely palauttaa. Kysely siis palauttaa ne solmut <em>parent</em> joille pätee ehto: solmuun johtaa kaari </em>CHILD_OF</em> sellaisesta solmusta johon liittyy attribuutti <em>nimi</em>, jonka arvo on <em>Arto</em>.
</p>

<p>
Kirjat joista Arton esivanhemmat pitävät:
</p>

<pre>
MATCH ({ name:"Arto" }) -[:CHILD_OF*1..]-> (relative) -[:LIKES]-> (book:Book)
RETURN book
</pre>

<p>
Nyt kysely palauttaa sellaiset solmut <em>book</em> joille pätee:
</p>
<ul>
<li> solmun tyyppi on Book</li>
<li>
  solmuun on <em>:LIKES-tyyppinen</em> kaari jostain solmusta johon päästään Artosta yhtä tai useampaa <em>:CHILD_OF</em> kaarta pitkin kulkemalla
</li>

</ul>
<p>
Arton ystävistä ja ystävien ystävistä, ja näiden ystävistä jne kaikki ne, jotka ovat opiskelleet samassa paikassa kun Arto:
</p>
<pre>
MATCH (arto: { name:"Arto" }) -[:FRIENDS_WITH*1..]-> (friend) -[:STUDIED_IN]-> (school)
WHERE arto -[:STUDIED_IN]-> (school)
RETURN friend
</pre>

<p>
Vielä yksi esimerkki. Miten löytäisimme lyhimmän ystävien ketjun,</em> joka yhdistää Arton ja Barack Obaman?
</p>
<pre>
MATCH (arto: { name:"Arto" }) (barack:{ name:"Barack Obama" })
p = shortestPath( (arto) -[:FRIEND*1..]-> (barack) )

RETURN p
</pre>

<p>
Eli ensin etsitään solmut joiden nimenä on Arto ja Barack, ja sen jälkeen Neo4J:n valmis funktio <em>shortestPath</em> etsii lyhimmän polun solmujen välillä. Tämä kysely olisi todennäköisesti mahdoton tehdä SQL:llä tai ainakin äärimmäisen vaikea muotoilla ja todella hidas suorittaa. Verkkotietokannat sopivatkin erittäin hyvin muutamiin sellasiiin käyttöskenaarioihin, joissa muut tietokantatyypit ovat lähes käyttökelvottomia. Verkkotietokantojen käyttö onkin yleistynyt esim. sosiaalisen median sovelluksissa ja suosittelujärjestelmissä.
</p>

<p>
<a href="http://db-engines.com/en/ranking/graph+dbms">Suosituimmat</a> verkkotietokannat.
</p>

<h2>NOSQL ja NewSQL</h2>

<p>
NoSQL-tietokannat löivät läpi suuren kohun saattamina ja erityisesti startupeissa oli muodikasta ottaa käyttöön helpommin suurille käyttäjämäärille skaalautuvia NoSQL-kantoja kuten MongoDB. Pikkuhiljaa kohu on laantunut, ja enenevissä määrin ollaan menossa jo aiemmin mainittuun
<a href="http://martinfowler.com/bliki/PolyglotPersistence.html">polyglot persistancen</a> nimellä kulkevaan suuntaan, eli valitaan oikea työkalu kuhunkin käyttötarkoitukseen, ja erittäin tyypillistä onkin että jo hieman suuremmissa sovelluksissa on käytössä dokumentti-, avain-arvo- ja relaatiotietokanta. Uusimpana kehityssuuntana on ollut myös se, että vanhat relaatiotietokannat ovat ottaneet vaikutteita muista tietokantatyypeistä. Esim. tämän hetken suosituin Open Source -relaatiotietokanta PostgeSQL sisältää paljon <a href="http://www.postgresql.org/docs/9.4/static/datatype-json.html">dokumenttitietokantoja vastaavaa toiminnallisuutta</a>. Kehitystä on tapahtunut myös toiseen suuntaan, jotkut dokumenttitietokannat ovat mahdollistaneet <a href="https://azure.microsoft.com/en-us/documentation/articles/documentdb-sql-query/">SQL:n käytön kyselykielenä.</a>
</p>

<p>
Kahtiajaon hieman liudennuttua termin NoSQL sijaan onkin alettu puhua <em>Not Only SQL</em> -tietokannoista, ja termi on muokkautunut muotoon <em>NOSQL</em>. Päätään nostaa esille myös vielä melko epämääräisesti määritelty termi <em><a href="http://www.dbta.com/Columns/DBA-Corner/What-Is-a-NewSQL-Database-System-104489.aspx">NewSQL</a></em>. Wikipedian mukaan NewSQL:llä tarkoittaa seuraavaa:
</p>

<blockquote>
<p>
NewSQL is a class of modern relational database management systems that seek to provide the same scalable performance of NoSQL systems for online transaction processing (OLTP) read-write workloads while still maintaining the ACID guarantees of a traditional database system.
</p>

<p>
Although NewSQL systems vary greatly in their internal architectures, the two distinguishing features common amongst them is that they all support the relational data model and use SQL as their primary interface.
</p>
</blockquote>

<p>
Eräs melko paljon huomiota saanut NewSQL-tietokanta on vuonna 2015 Applen ostama FoundationDB, joka sisäiseltä organisoinniltaan on avain-arvotietokanta ja tarjoaa perinteistä relaatiotietokantaa skaalautuvamman ratkaisun, mutta tarjoaa kyselykieleksi (myös) SQL:n ja ACID-ominaisuudet takaavat transaktiot eli käyttäytyy sovellusohjelmien kannalta kuten normaali relaatiotietokanta.
</p>

		<h1>SQL-tietokannanhallintajärjestelmien eroista</h1>

		<p>Olemme tällä kurssilla tähän asti käyttäneet enimmäkseen SQLite-tietokannanhallintajärjestelmää. SQLiten käyttöä kurssilla helpottavina piirteinä ovat muun muassa käyttäjähallinnan puuttuminen ja tietokannan kokoaminen yhteen tiedostoon, joten opiskelijat ovat voineet itse ladata tiedoston ja käyttää tietokantaa välittömästi. Opetuskäyttö onkin mainittu yhtenä SQLitelle <a href="http://www.sqlite.org/whentouse.html">hyvin soveltuvana käyttökohteena</a> SQLiten kotisivulla.</p>

		<p>Kuten jo aiemmin tuli ilmi, eri SQL-toteutukset noudattelevat kielen standardia vaihtelevissa määrin, eivätkä aina toimi täysin samoin. SQLite tarjoaa <a href="https://www.sqlite.org/lang.html">jotain tietoa standardin noudattamisestaan</a>, ja vielä selkeämpi tämän suhteen on <a href="http://www.postgresql.org/docs/9.4/static/features.html">Postgres</a>. Toisaalta jotkut toiset tietokannanhallintajärjestelmät eivät juurikaan tuo esille missä määrin ne noudattavat standardia.</p>

		<p>Toisin kuin SQLite, useat muut (SQL-)tietokannanhallintajärjestelmät on jaettu niin sanotun <a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">client-server -mallin</a> mukaisesti erilliseen palvelinosaan, jossa varsinainen tietokanta on, ja asiakasosaan joka tarjoaa käyttöliittymän palvelinosan tarjoamaan tietokannan. Yksi tälläisistä tietokannanhallintajärjestelmistä on jo yllä mainittu PostgreSQL, joka tulee meille vastaan seuraavassa luvussa kun siirrämme sovellusta verkkoon.</p>

		<p>Eroista huolimatta SQL-tietokannanhallintajärjestelmien SQL-toteutukset toimivat enimmäkseen toisiaan vastaavasti. Valitettavasti muutamatkin pienet erot saattavat aiheuttaa paljon vaivaa järjestelmästä toiseen siirryttäessä.</p>


		<h2>SQLite ja PostgreSQL</h2>

		<p>Siirryttäessä käyttämään SQLiten sijaan PostgreSQL-järjestelmää, joudumme mahdollisesti muokkaamaan käytettyjä SQL-kyselyitä. Varsinaisten erojen lisäksi Postgres on muutenkin tarkempi syntaksin noudattamisesta, eikä välttämättä hyväksy suunnilleen oikein muotoiltuja kyselyitä jotka SQLite saattaa joskus hyväksyä.</p>

		<p>Ongelmatilanteissa voisi tarkistaa mm seuraavia asioita:</p>
		<ul>
		<li>SQL-kielelle varatut avainsanat eivät ole <a href="http://www.postgresql.org/docs/9.4/static/sql-keywords-appendix.html" target="_blank">Postgresissa</a> täysin samat kuin <a href="https://www.sqlite.org/lang_keywords.html" target="_blank">SQLitessa</a>. (On syytä mm huomioida USER)</li>
		<li>Tarjolla olevat tietotyypit saattavat poiketa (<a href="http://www.postgresql.org/docs/9.4/static/datatype.html" target="_blank">Postgres</a>, <a href="https://www.sqlite.org/datatype3.html" target="_blank">SQLite</a>)</li>
		<li>Ajan käsittely saattaa olla hieman erilaista (<a href="http://www.postgresql.org/docs/9.4/static/functions-datetime.html" target="_blank">Postgres</a>, <a href="https://www.sqlite.org/lang_datefunc.html" target="_blank">SQLite</a>)</li>
		<li>Yksityiskohtana mainittakoon lisäksi Postgresin SERIAL, jonka tapaamme seuraavassa kappaleessa.</li>
		</ul>


		<h1>Sovelluksen siirtäminen verkkoon</h1>

		<p>Web-sovelluksemme on tähän mennessä toiminut paikallisella koneella, mikä on hieman tylsää, sillä sovellusta olisi kiva päästä näyttämään myös kavereille. Tutustutaan tässä Heroku-nimisen pilvipalvelun käyttöön, ja siirretään kehittämämme Web-sovellus verkkoon kaikkien nähtäväksi.</p>

		<aside class="info">
		  <br/>
		  <h1>Opas verkossa</h1>
		  <p>Herokulla on myös oma opas, johon kannattaa tutustua <a href="https://devcenter.heroku.com/articles/getting-started-with-java" target="_blank">täällä</a>.</p>
		</aside>

		<p>Tarvitset sovelluksen siirtoon (1) <a href="https://signup.heroku.com/dc" target="_blank">tunnuksen Heroku-palveluun</a> sekä (2) <a href="https://toolbelt.heroku.com/" target="_blank">Heroku Toolbeltin</a>.</p>


		<h2>Sovelluksen siirtäminen verkkoon: alkutoimet</h2>

		<p>Herokuun siirrettävät sovellukset tarvitsevat muutamia muutoksia:</p>

		<ol>

		  <li><p><strong>Procfile-tiedoston lisääminen</strong>. Sovelluksen juuripolkuun tulee lisätä tiedosto <code>Procfile</code>, jonka sisällä on sovelluksen käynnistämisessä käytettävä komento.</p>

<pre>
web:    java -cp target/classes:target/dependency/* tikape.Main
</pre>

		    <p>Komennon osa <code>tikape.Main</code> kuvaa pääohjelmaluokkaa, jonka kautta sovellus tulee käynnistää. Jos pääohjelmaluokkasi on toisessa pakkauksessa (ei tikape) tai pääohjelmaluokan nimi on jotain muuta (ei Main), tulee tätä muokata. Heroku käyttää tätä komentoa sovelluksen käynnistykseen.</p></li>

		  <li><p><strong>Maven-liitännäiset ohjelman kääntöprosessin automatisointiin</strong>. Sovelluksen <code>pom.xml</code>-tiedostoon tulee lisätä seuraavat rivit. Rivit lisätään esimerkiksi <code>&lt;/properties&gt;</code>-rivin jälkeen.</p>

<pre class="sh_xml">
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.5.1&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                    &lt;optimize&gt;true&lt;/optimize&gt;
                    &lt;debug&gt;true&lt;/debug&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.4&lt;/version&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;copy-dependencies&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;copy-dependencies&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
</pre></li>

		  <li><p><strong>Sovelluksen käynnistäminen Herokun määräämässä portissa</strong>. Jokainen web-sovellus käynnistettään tiettyyn porttiin, jonka se varaa käyttöönsä. Heroku pyörittää useampia sovelluksia samalla palvelinkoneella, joten sille pitää antaa mahdollisuus portin asetukseen.</p>

		    <p>Portin asetus tapahtuu <em>ympäristömuuttujan</em> avulla, jonka Heroku antaa sovellukselle sovellusta käynnistettäessä. Käytännössä pääohjelmaluokkaan, joka käynnistää web-palvelimen, tulee lisätä seuraavat rivit -- lisää ne main-metodin alkuun.</p>

<pre class="sh_java">
        // asetetaan portti jos heroku antaa PORT-ympäristömuuttujan
        if (System.getenv("PORT") != null) {
            port(Integer.valueOf(System.getenv("PORT")));
        }
</pre></li>
</ol>

		<p>Ylläolevien muutosten avulla sovelluksen siirtäminen verkkoon onnistuu.</p>


		<h2>Heroku toolbeltin asennus</h2>

		<p>Asenna <a href="https://toolbelt.heroku.com/" target="_blank">heroku toolbelt</a>. Ohjeita löytyy esimerkiksi osoitteessa <a href="https://devcenter.heroku.com/articles/heroku-command" target="_blank">https://devcenter.heroku.com/articles/heroku-command</a>.</p>

		<p>Jos sinulla ei ole koneeseen pääkäyttäjän oikeuksia (root), asennuksen pitäisi silti olla mahdollista jos koneelle on ennestään asennettu muutama Herokun vaatima ohjelmapaketti. Joudut kuitenkin tekemään <a href="http://geek.co.il/2015/06/19/fix-another-curlsh-bogus-installation-heroku">asennuksen hieman toisin</a>.</p>

		<h2>Sovelluksen luominen Herokuun</h2>

		<p>Sovelluksen luomiseen Herokuun tarvitaan kaksi askelta. Ensimmäisessä askeleessa luodaan projektista git-repositorio (tätä ei tarvitse tehdä jos sovellus on jo git-versionhallinnassa), jonka jälkeen luodaan herokuun sijainti johon sovellus kopioidaan.</p>

		<ol>
		  <li><p><strong>Projekti git-repositorioksi</strong> -- projektin luominen git-repositorioksi tapahtuu ajamalla komento <code>git init</code> projektin juurikansiossa (kansio, jossa löytyy tiedosto <code>pom.xml</code>). Jos sovellus on jo esimerkiksi githubissa, ei tätä tarvitse tehdä.</p></li>

		  <li><p><strong>Heroku-projektin luominen</strong> -- suorita juurikansiossa komento <code>heroku create</code>. Tämä luo sovellukselle sijainnin herokuun, johon sovelluksen voi lähettää.</p></li>

		</ol>

		<p>Mahdollisissa ongelmatilanteissa kannattaa ensimmäiseksi katsoa mitä viestejä Herokun <a href="https://devcenter.heroku.com/articles/logging">lokitiedostoon</a> on päätynyt.</p>

		<h2>Tietokantaa käyttämättömän sovelluksen lähetys Herokuun</h2>

		<p>Sovelluksen lähetys herokuun sisältää tyypillisesti neljä askelta. Ensin poistamme turhat käännetyt lähdekooditiedostot, jotta ne eivät häiritse herokun toimintaa. Tämän jälkeen lisäämme tiedostot versionhallintaan, sitoudumme niiden lähettämiseen, ja siirrämme ne herokuun.</p>

		<ol>
		  <li><p><strong>Turhien lähdekooditiedostojen poistaminen</strong> -- suorita projektin juurikansiossa komento <code>mvn clean</code>, joka poistaa projektista käännetyt lähdekooditiedostot (kansio target).</p></li>
		  <li><p><strong>Tiedostojen lisääminen versionhallintaan</strong> -- suorita projektin juurikansiossa komento <code>git add .</code>, joka lisää kaikki projektin tiedostot versionhallintaan.</p></li>
		  <li><p><strong>Tiedostojen lähettämiseen sitoutuminen</strong> -- suorita projektin juurikansiossa komento <code>git commit -m "viesti"</code>, joka sitouttaa lähetykseen juuri lisätyt tiedostot.</p></li>
		  <li><p><strong>Tiedostojen siirtäminen herokuun</strong> -- suorita projektin juurikansiossa komento <code>git push heroku master</code>, joka lähettää tiedostot herokuun.</p></li>
		</ol>

		<p>Nyt sovelluksesi on Herokussa.</p>

		
		<h2>Tietokannan riippuvuudet</h2>

		<p>Sovellukseen lisätään pääsy kahteen tietokantaan. Yksi on paikallisessa testauksessa ja kehitystyössä käyttämämme <a href="https://www.sqlite.org/" target="_blank"><code>SQLite</code></a>, ja toinen on Herokun käyttämä <a href="http://www.postgresql.org/" target="_blank"><code>PostgreSQL</code></a>. Niiden käyttämiseen tarvitaan JDBC-ajurit, jotka tulee lisätä sovelluksen <code>pom.xml</code>-tiedostoon.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.xerial&lt;/groupId&gt;
            &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt;
            &lt;version&gt;3.8.11.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
            &lt;version&gt;9.4-1201-jdbc4&lt;/version&gt;
        &lt;/dependency&gt;
</pre>

		
		<h2>Tietokannan osoitteen lukeminen ja käyttö Herokussa</h2>

		<p>Heroku tarjoaa sovelluksen portin lisäksi myös JDBC-osoitteen ympäristömuuttujana. Kun luomme käyttöömme Database-oliota sovelluksen alussa, tulee tietokantaosoite valita sen mukaan, että onko ympäristömuuttujaa olemassa.</p>

<pre class="sh_java">
        // käytetään oletuksena paikallista sqlite-tietokantaa
        String jdbcOsoite = "jdbc:sqlite:kanta.db";
        // jos heroku antaa käyttöömme tietokantaosoitteen, otetaan se käyttöön
        if (System.getenv("DATABASE_URL") != null) {
            jdbcOsoite = System.getenv("DATABASE_URL");
        } 

        Database db = new Database(jdbcOsoite);
</pre>

                <p>Nyt käytössämme on tietokantaosoite. Paikallisella koneella voimme jatkossakin käyttää SQLite-tietokantamoottoria, mutta Herokussa käytämme herokun määräämää tietokannanhallintajärjestelmää.</p>

		
		<h2>Tietokannan luominen sijaintikohtaisesti</h2>

                <p>Muokataan tämän jälkeen Database-luokkaa siten, että se sisältää tietokantataulujen luomiseen tarvittavat komennot, jotka suoritetaan sovelluksen käynnistyessä. PostgreSQL-komennot poikkeavat hieman SQLitestä, joten tehdään nämä erillisinä. Tiedämme, että käytössä on PostgreSQL-tietokanta, jos tietokannan osoitteessa on sana "postgre".</p>

		<p>Alla on kuvattuna tietokantaluokan toiminnallisuus, joka toimii sekä Herokussa että paikallisesti. Luokassa luodaan tasan yksi tietokantataulu.</p>

<pre class="sh_java">
package tikape.db;

import java.sql.*;
import java.util.*;
import java.net.*;

public class Database {

    private String databaseAddress;

    public Database(String databaseAddress) throws Exception {
        this.databaseAddress = databaseAddress;

        init();
    }

    private void init() {
        List&lt;String&gt; lauseet = null;
        if (this.databaseAddress.contains("postgres")) {
            lauseet = postgreLauseet();
        } else {
            lauseet = sqliteLauseet();
        }

        // "try with resources" sulkee resurssin automaattisesti lopuksi
        try (Connection conn = getConnection()) {
            Statement st = conn.createStatement();

            // suoritetaan komennot
            for (String lause : lauseet) {
                System.out.println("Running command &gt;&gt; " + lause);
                st.executeUpdate(lause);
            }

        } catch (Throwable t) {
            // jos tietokantataulu on jo olemassa, ei komentoja suoriteta
            System.out.println("Error &gt;&gt; " + t.getMessage());
        }
    }

    public Connection getConnection() throws SQLException {
        if (this.databaseAddress.contains("postgres")) {
            try {
                URI dbUri = new URI(databaseAddress);

                String username = dbUri.getUserInfo().split(":")[0];
                String password = dbUri.getUserInfo().split(":")[1];
                String dbUrl = "jdbc:postgresql://" + dbUri.getHost() + ':' + dbUri.getPort() + dbUri.getPath();

                return DriverManager.getConnection(dbUrl, username, password);
            } catch (Throwable t) {
                System.out.println("Error: " + t.getMessage());
                t.printStackTrace();
            }
        }

        return DriverManager.getConnection(databaseAddress);
    }

    private List&lt;String&gt; postgreLauseet() {
        ArrayList&lt;String&gt; lista = new ArrayList&lt;&gt;();

        // tietokantataulujen luomiseen tarvittavat komennot suoritusjärjestyksessä
        lista.add("DROP TABLE Tuote;");
        // heroku käyttää SERIAL-avainsanaa uuden tunnuksen automaattiseen luomiseen
        lista.add("CREATE TABLE Tuote (id SERIAL PRIMARY KEY, nimi varchar(255));");
        lista.add("INSERT INTO Tuote (nimi) VALUES ('postgresql-tuote');");

        return lista;
    }

    private List&lt;String&gt; sqliteLauseet() {
        ArrayList&lt;String&gt; lista = new ArrayList&lt;&gt;();

        // tietokantataulujen luomiseen tarvittavat komennot suoritusjärjestyksessä
        lista.add("CREATE TABLE Tuote (id integer PRIMARY KEY, nimi varchar(255));");
        lista.add("INSERT INTO Tuote (nimi) VALUES ('sqlite-tuote');");

        return lista;
    }
}
</pre>

                <p>Ylläolevassa esimerkissä tarjotaan yhteyden muodostaminen joko PostgreSQL-tietokantaan tai SQLite-tietokantaan riippuen yhteydestä. Tämän lisäksi komento yrittää myös luoda tietokantataulua -- sekä PostgreSQL:n tapauksessa myös poistaa sen. Metodeja <code>postgreLauseet</code> ja <code>sqliteLauseet</code> kannattanee muokata omaan tarkoitukseen sopivaksi.</p>


		<h2>Tietokanta osana DAO-toiminnallisuutta</h2>

		<p>Nyt tietokannan voi ottaa osaksi tietokantaa abstrahoivaa Dao-luokkaa.</p>

<pre class="sh_java">
// pakkausmäärittely ja importit

import java.sql.*;
import java.util.*;
import tikape.db.Database;
import tikape.dom.Tuote;

public class TuoteDao implements Dao&lt;Tuote, Integer&gt; {

    private Database database;

    public TuoteDao(Database database) {
        this.database = database;
    }

    @Override
    public Tuote findOne(Integer key) throws SQLException {
        try (Connection conn = database.getConnection()) {
            PreparedStatement s = conn.prepareStatement("SELECT * FROM Tuote WHERE id = ?");
            s.setInt(1, key);
            ResultSet rs = s.executeQuery();
            
            // tee jotain tuloslistalla
            
        }
        
        return null;
    }

    //    ....
</pre>


<p>Lopulta pääohjelmassa toiminnallisuus näyttää esimerkiksi seuraavanlaiselta:</p>

<pre class="sh_java">
        if (System.getenv("PORT") != null) {
            port(Integer.valueOf(System.getenv("PORT")));
        }

        String jdbcOsoite = "jdbc:sqlite:kanta.db";
        if (System.getenv("DATABASE_URL") != null) {
            jdbcOsoite = System.getenv("DATABASE_URL");
        }
        
        Database db = new Database(jdbcOsoite);
        TuoteDao tuoteDao = new TuoteDao(db);
        
        
        get("/tuote/:id", (req, res) -&gt; {
            HashMap map = new HashMap&lt;&gt;();
            
            map.put("tuote", tuoteDao.findOne(Integer.parseInt(req.params("id"))));

            return new ModelAndView(map, "sivu");
        }, new ThymeleafTemplateEngine());
</pre>


<h1>Koeasiaa</h1>


<p>Kurssikokeessa on kolme tehtävää, joissa jokaisessa saattaa olla yksi tai useampi alitehtävä. Kokeeseen ei tule Java-ohjelmointia tai Web-sovellusten ohjelmointia. Tästä huolimatta näistä on tärkeää ymmärtää se, että tietokannanhallintajärjestelmät ovat tyypillisesti erillisiä niitä käyttävistä sovelluksista.</p>

<p>Aiemmissa tietokantojen perusteiden kurssikokeissa ovat esiintyneet ainakin kurssilla esiintyneiden käsitteiden (ml. harjoitukset) selitystehtävät, erilaiset käsiteanalyysi- ja tietokantataulujen suunnitteluun liittyvät tehtävät, sekä sql-tehtävät.</p>

<p>Osoitteessa <a href="https://docs.google.com/document/d/1lkdEBSg9nhdFUhgnVXl6jtsZuI0ODy-Kye_cag3qmu4/edit?usp=sharing" target="_blank">https://docs.google.com/document/d/1lkdEBSg9nhdFUhgnVXl6jtsZuI0ODy-Kye_cag3qmu4/edit?usp=sharing</a> löytyy vanha kurssikoe, jota voi käyttää osana tenttiin kertausta.</p>

<p><strong>Kokeeseen saa ottaa mukaan "lunttilapun".</strong> Lunttilappu on kaksipuolinen, A4-kokoinen, itse käsin täytetty paperi. Lunttilappuun tulee merkitä nimi ja opiskelijanumero, ja se tulee jättää kokeen palautuksen yhteydessä tenttivalvojille.</p> 


<!--
		<h3><a href="#tehtavat-list">Tehtävien listaukseen</a></h3>
-->


</section>





        </article>

        <footer>
            <p>
                <a id="license" rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.0/"><img alt="Creative Commons License" style="border-width:0; float:left; padding:15px" src="http://i.creativecommons.org/l/by-nc-sa/2.0/88x31.png" /></a>
                <small>T&auml;m&auml; materiaali on lisensoitu Creative Commons BY-NC-SA-lisenssill&auml;, joten voit k&auml;ytt&auml;&auml; ja levitt&auml;&auml; sit&auml; vapaasti, kunhan alkuper&auml;isten tekij&ouml;iden nimi&auml; ei poisteta. Jos teet muutoksia materiaaliin ja haluat levitt&auml;&auml; muunneltua versiota, se t&auml;ytyy lisensoida samanlaisella vapaalla lisenssill&auml;. Materiaalien k&auml;ytt&ouml; kaupalliseen tarkoitukseen on ilman erillist&auml; lupaa kielletty. Tekij&auml;(t): <a href="http://www.cs.helsinki.fi/en/people/avihavai" target="_blank">Arto Vihavainen</a> ja <a href="http://www.cs.helsinki.fi/en/people/mluukkai" target="_blank">Matti Luukkainen</a> (<a href="http://www.cs.helsinki.fi/en/rage" target="_blank">Agile Education Research</a> -tutkimusryhm&auml;).
            </p>
        </footer>

        <div class="hidden">
            <p>the end.</p>
        </div>


        <script src="js/libs/jquery/jquery.js"></script>
        <script src="js/libs/jqueryui/jquery-ui.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
<!--
	<script src="js/libs/bootstrap.min.js"></script>
-->
        <script src="js/libs/syntaxhighlight/sh_main.min.js"></script>
        <script src="js/tikape.js"></script>



	<!-- angularjs -->
<!--	<script src="js/libs/angular.min.js"></script>
-->	<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.5/angular.min.js"></script>

	<!-- tikape sqljs -- https://github.com/mluukkai/tikape-sqljs -->
        <script src="js/libs/sql.js"></script>
        <script src="js/table.js"></script>
        <script src="js/app.js"></script>
        <script src="js/directives.js"></script>
    </body>
</html>
