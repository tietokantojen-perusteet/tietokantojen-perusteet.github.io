<!DOCTYPE html>
<html>
    <head>
        <title>Tietokantojen perusteet</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" href="js/libs/syntaxhighlight/css/sh_style.css"/>
	<link rel="stylesheet" href="css/tikape.css"/>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css"/>
    </head>
    <body ng-app='myApp'>

        <!-- BEGIN NAV -->
        <header role="navigation">
            <h1>
                <button type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>

                <a href="http://www.cs.helsinki.fi"><img src="img/header_tktl.png" alt="CS Dept. Univ. Helsinki"></a>
            </h1>
            <nav class="collapse bs-navbar-collapse" role="navigation">
                <ul>
                    <li>
                        <a href="#viikko1">Viikko 1</a>
                    </li>
                    <li>
                        <a href="#viikko2">Viikko 2</a>
                    </li>
                    <li>
                        <a href="#viikko3">Viikko 3</a>
                    </li>
                    <li>
                        <a href="#viikko4">Viikko 4</a>
                    </li>
                    <li>
                        <a href="#viikko5">Viikko 5</a>
                    </li>
                    <li>
                        <a href="#viikko6">Viikko 6</a>
                    </li>
<!--
                    <li>
                        <a href="#viikko7">Viikko 7</a>
                    </li>
-->
                </ul>
            </nav>
        </header>
        <!-- // END NAV -->
        <article>

            <!-- BEGIN INDEX -->
            <section id="intro" class="no-toc weeklimit" data-week-id="0">
                
                <header>

                    <div class="intro-header-img"></div>

                    <h1>Tietokantojen perusteet</h1>

                    <p><em>"miten tietoa sekä siihen liittyviä yhteyksiä mallinnetaan ja hallinnoidaan?" </em></p>

                </header>

                <h1 id="start">Sisältö, aikataulu, arvostelu</h1>

                <p><em>"Kurssilla tutustutaan tiedon esitysmuotoihin ja tiedon hakuun suurista tietomääristä. Erityisenä painopisteenä ovat relaatiotietokannat, joiden kohdalla perehdytään toisaalta teoreettiseen perustaan ja toisaalta tietokannan käytännön käsittelyyn SQL-kielen avulla. Kurssilla opitaan myös perustiedot relaatiotietokantojen suunnittelusta."</em></p>

		<p><strong>Huom! Sisältö, aikataulu ja arvostelu koskee Helsingin yliopiston tietojenkäsittelytieteen laitoksen syksyn 2015 kurssia.</strong></p>

                <p>Kurssi sisältää seitsemän tehtäväsarjaa, joista ensimmäinen julkaistaan heti kurssin alussa. Tehtävät tulee tehdä ennen viikoittaisia harjoitustilaisuuksia, joissa hyödynnetään tehtävien tekemisessä kertynyttä paikan päällä pohdittavissa suunnittelu- ja toteutustehtävissä.</p>

                <p>Kurssin arvostelu perustuu kurssikokeeseen, harjoitustehtäviin, sekä läsnäoloon harjoitustilaisuuksissa:</p>

                <ul>
                  <li>Kurssikokeessa on kolme tehtävää, joista jokainen on kuuden pisteen arvoinen. Kokeesta voi saada yhteensä 18 pistettä. Käytössä on myös koeleikkuri, eli kurssin hyväksytty suoritus vaatii vähintään puolia koepisteistä.</li>
		  <li>Tekemällä kaikki ennalta tehtävät harjoitustehtävät, jotka alkavat kurssin toiselta viikolta, saa kolme pistettä. Harjoitustehtävistä voi saada yhteensä 18 pistettä.</li>
		  <li>Harjoitustilaisuuksissa läsnäolosta saa kaksi pistettä. Läsnäoloista voi saada yhteensä 14 pistettä.</li>
		</ul>

		<p>Koko kurssista voi saada 50 pistettä. Alustavat arvosanarajat ovat seuraavat:</p>

		<ul>
		  <li>30p -> 1</li>
		  <li>34p -> 2</li>
		  <li>38p -> 3</li>
		  <li>42p -> 4</li>
		  <li>46p -> 5</li>
		</ul>

                <p><a class="jump" href="#viikoittaiset-teemat" role="button">Viikoittaiset teemat &raquo;</a></p>


		<h2>Lisämateriaali</h2>

		<p>Tämän materiaalin lisäksi täydentävänä materiaalina voi käyttää Harri Laineen Tietokantojen perusteet -kurssin oppimateriaalia (<a href="ext/laine-tikape-osa1.pdf" target="_blank">osa 1</a>, <a href="ext/laine-tikape-osa2.pdf" target="_blank">osa 2</a> ja <a href="ext/laine-tikape-osa3.pdf" target="_blank">osa 3</a>), sekä kirjoja "Fundamentals of database systems" (Elmasri &amp; Navathe) ja "Database management systems" (Ramakrishnan &amp; Gehrke). Molemmat löytyvät opiskelijakirjastosta.</p>

		<p>Edellä mainittujen kirjojen ostaminen ei ole tätä kurssia varten suositeltavaa.</p> 

                <h2>Esitietovaatimukset</h2>

                <p>Kurssilla ei ole virallisia esitietovaatimuksia. Jos kurssia suorittaa ilman kurssin Ohjelmoinnin perusteet käymistä, on kurssin kuitenkin todennäköisesti työläs. Myös kursseista Ohjelmoinnin jatkokurssi ja Ohjelmistotekniikan menetelmät on kurssilla hyötyä.</p>



                <h2>Muiden auttaminen ja kunniasääntö</h2>

                <p>Vaikka helpoin vastaus avunpyyntöön on usein valmiiden ratkaisujen jakaminen, on se sekä toisen että oman oppimisen kannalta erittäin huono lähestymistapa. Opit parhaiten tutkimalla apua kysyvän ongelmaa ja tarjoamalla sellaista tukea, minkä avulla toinen ymmärtää ongelman ja pystyy etenemään. <strong>Osallistumalla kurssille sitoudut siihen, että et vie oppimisen iloa muilta esimerkiksi laittamalla tehtävien mallivastauksia verkkoon tai jakamalla niitä muille.</strong> Autat muita kurssilaisia parhaiten tekemällä tehtäviä yhdessä muiden kanssa, tarjoamalla apua harjoitustilaisuuksissa sekä osallistumalla teemaan liittyviin keskusteluihin vaikkapa kurssin IRC-kanavalla.</p>

                <div class="two-column">
                    <div class="column">

                        <h1>Luennot ja harjoitustilaisuudet</h1>

                        <p>Kurssin aloitusluento pidetään tiistaina 1.9. kello 12-14 Exactumin salissa CK112, jonka lisäksi salissa C221 järjestetään ohjausta tehtävien tekemiseen tiistaisin kello 12-16.</p>

			<p>Kurssilla on viikoittaiset harjoitusryhmät, jotka järjestetään salissa B221 seuraavina aikoina.</p>

			<ul>
			  <li>Ke 9-12 -- B221, Arto Vihavainen</li>
			  <li>To 9-12 -- B221, Petri Myllys</li>
			  <li>To 14-17 -- B221, Matti Luukkainen</li>
			  <li>Pe 9-12 -- B221, Petri Myllys</li>
			</ul>

			<p>Harjoitusryhmiin ilmoittautuminen tapahtuu kurssi-ilmoittautumisen yhteydessä <a href="https://ilmo.cs.helsinki.fi/ilmo/Ilmo" target="_blank">tietojenkäsittelytieteen laitoksen ilmoittautumisjärjestelmän kautta.</a></p>

			<p>Huom! Harjoitukset alkavat heti kurssin ensimmäisellä viikolla.</p>

                    </div>

                    <div class="column">

                        <h1 id="irc-ohjeet">IRC-ohjeet</h1>

                        <p>Kurssilla on käytössä IRC-kanava #tikape -- ohjeita IRC:n käyttöön löytyy muunmuassa <a href="http://fuksiwiki.tko-aly.fi/IRC-ohjeet" target="_blank">Fuksiwikistä</a> sekä <a href="http://mooc.cs.helsinki.fi/content/irc-ohjeet" target="_blank">mooc.fi:stä</a>.</p>

                    </div>
                </div>


                <h1 id="viikoittaiset-teemat">Teemat</h1>


		<div id="week-toc" class="nav">
		  <table class="table table-striped">
		    <thead>
		      <tr>
			<th>Viikko</th>
			<th>Yleinen</th>
			<th>Suunnittelu</th>
			<th>SQL</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>1</td>
			<td>Johdanto, jäsennelty ja jäsentelemätön tieto, tiedon yhdistäminen</td>
			<td>Yhden taulun käsittely, yhdestä moneen yhteydet</td>
			<td>Relaatiot, tiedon hakeminen yhdestä taulusta</td>
		      </tr>
		      <tr>
			<td>2</td>
			<td>Käsitekaaviosta tauluiksi</td>
			<td>Monesta moneen yhteydet</td>
			<td>Tiedon hakeminen, tiedon yhdistäminen useammasta taulusta</td>
		      </tr>
		      <tr>
			<td>3</td>
			<td>Tietokantakyselyiden teko ohjelmallisesti</td>
			<td>Käsitekaavion luominen käsiteanalyysin avulla</td>
			<td>Tiedon yhdistäminen JOIN-komentojen avulla, tiedon lisääminen ja poistaminen</td>
		      </tr>
		      <tr>
			<td>4</td>
			<td>Ohjelmallinen kysely ja koosteoliot</td>
			<td></td>
			<td>Ali- ja yhteenvetokyselyt sekä tilastojen luominen</td>
		      </tr>
		      <tr>
			<td>5</td>
			<td></td>
			<td>Tiedon normalisointi, Taulujen määrittely, rajoitteet, Indeksit ja hakurakenteet</td>
			<td>Tiedon määrittely (DDL) ja tiedon muokkaaminen (DDM)</td>
		      </tr>
		      <tr>
			<td>6</td>
			<td>Tietokannat osana muita sovelluksia, Tietokanta osana web-sovellusta</td>
			<td></td>
			<td></td>
		      </tr>
		      <tr>
			<td>7</td>
			<td>Muita datan esitysmuotoja</td>
			<td>Tietokantatransaktiot ja tiedon eheys</td>
			<td></td>
		      </tr>
		    </tbody>
		  </table>
		</div>


                <h1 id="kasitteisto">Kurssin käsitteistöä</h1>


		<div id="week-toc" class="nav">
		  <table class="table table-striped">
		    <thead>
		      <tr>
			<th>Käsite</th>
			<th>Selitys</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>wip</td>
			<td>work in progress, työn alla</td>
		      </tr>
		    </tbody>
		  </table>
		</div>

                <h1>Sisällysluettelo</h1>

                <ul class="nav" id="material-toc"></ul>

<!--
                <h1>Materiaalin itseopiskelu- ja kertaustehtävät</h1>

                <ul class="nav nav-pills nav-pills-fixed-width" id="tehtavat-toc"></ul>
-->
                <h1>Kurssin tehtävät</h1>

		<p>Kurssilla on viikosta 2 lähtien kotona tehtäviä tehtäviä sisältäviä tehtäväsarjoja, jonka lisäksi laskuharjoitustilaisuuksissa tehdään paikan päällä tehtäviä. Näiden lisäksi kurssimateriaalissa on erikseen merkittyjä pohdinta- ja SQL-ohjelmointitehtäviä.</p>

		<h2>Kotona tehtävät tehtäväsarjat</h2>

		<ul>
		  <li><a href="https://docs.google.com/document/d/18PXEYZGuLOO6p1F5HfjRLAZrsgqWuKcYhgnilHVtIrY/edit?usp=sharing" target="_blank">Viikko 2</a></li>
		  <li><a href="https://docs.google.com/document/d/18bYt11F4HzWDX8RanKzl_6Vhb5rpJ1KirDWn1-dpVW4/edit" target="_blank">Viikko 3</a></li>
		  <li><a href="https://docs.google.com/document/d/1gCpBSDbjn3NqT1_jeoQl2eOvwQS1WVHVYiH7xGtL6a4/edit?usp=sharing" target="_blank">Viikko 4</a></li>
		  <li><a href="https://docs.google.com/document/d/1xeBB7QD0EpLEdr7Yd7mlZSp89Al1bhNzaJmb0vu_N-E/edit?usp=sharing" target="_blank">Viikko 5</a></li>
		  <li><a href="https://docs.google.com/document/d/1zZt2GYeoxRR3Pu82AYdBvQ1bJ0dAXbK4XpQDfo1SRkA/edit?usp=sharing" target="_blank">Viikko 6</a></li>
		  <li>Viikko 7 (julkaistaan 9.10.)</li>
		</ul>

		<h2>Paikan päällä tehtävät tehtäväsarjat</h2>
		
		<ul>
		  <li><a href="https://docs.google.com/document/d/18tYsgXU0u-6KFbuGft4yN3tkG0yxgE4DY0IdFx-C5Gg/edit?usp=sharing" target="_blank">Viikko 1</a></li>
		  <li><a href="https://docs.google.com/document/d/1DtrbKBt8ZHMZe0fILtobXMItV20z2Nt3FNxDpg2X0q0/edit" target="_blank">Viikko 2</a></li>
		  <li><a href="https://docs.google.com/document/d/1YqQlw3AhSQ1Lft0HlE5ANRewj5LsB3vpaNXjiHowj7g/edit" target="_blank">Viikko 3</a></li>
		  <li><a href="https://docs.google.com/document/d/1WfZmUGGg9YKMBEe3HAQ7mc8-QlPS8WJnza8aT4Iqe3o/edit?usp=sharing" target="_blank">Viikko 4</a></li>
		  <li><a href="https://docs.google.com/document/d/1UGQOn-e8r1C9wnkrVo_udjbfefRA1oEhjfjDKAhXC4Q/edit?usp=sharing" target="_blank">Viikko 5</a></li>
		  <li>Viikko 6 (julkaistaan 7.10.)</li>
		  <li>Viikko 7 (julkaistaan 14.10.)</li>
		</ul>

		<h2>Kurssikoe</h2>

		<p>Kurssin koe järjestetään 19.10. klo 16:00 salissa A111 (huom! kokeet alkavat aina tasalta -- tule ajoissa paikalle).</p>


            </section>
            <!-- END INDEX -->


            <section class="weeklimit" data-week-id="1">

                <header>
                    <h1 id="viikko1">Viikko 1</h1>
                </header>

                <h1>Johdanto</h1>


		<p>Kävellessäsi Helsingin keskustassa näet ihmisvilinän, kuulet puheensorinan, huomaat uutisotsikoita, mainostauluja ja erilaisia laitteita, jotka tarjoavat monipuolista tietoa sinua ympäröivästä maailmasta. Vaikka tämä toiminta voi tuntua satunnaiselta, voit havaita siitä erilaisia sääntöjä ja hahmoja. Ihmiset kulkevat paikasta toiseen tietoisten tai tiedostamattomien tavoitteiden ohjaamina. Puhe tapahtuu tietyllä kielellä, jolla on oma kielioppi. Uutisotsikoilla on tietynlainen tekstityyli. Mainostaulut hakevat näytettävän mainoksen verkon yli, ja laitteet -- esimerkiksi kännykkäsi -- seuraavat niihin ohjelmoituja sääntöjä, osittain antamiesi komentojen ohjaamana.</p>

		<p>Nämä säännöt ja hahmot kuvaavat tiedon rakennetta. Osa tiedosta on jäsentelemätöntä, eli sille ei ole tarkasti määriteltyä muotoa. Esimerkiksi puheensorina voi poukkoilla teemasta toiseen, ja vastaavasti tietoisten ja tiedostamattomien tavoitteiden tarkka kirjaaminen olisi, ainakin, hyvin haastavaa.</p>

		<p>Toisaalta, voit lukea saman uutisen lähes sanasta sanaan lehdestä, kännykästäsi tai netistä, olettaen että uutispalvelun tarjoaja on sama. Uutinen on jäsennelty otsikkoon, johdantoon, ja tekstikappaleisiin sekä niihin liittyviin väliotsikkoihin. Eri järjestelmät näyttävät tämän tiedon eri tavalla, ja samalla tarjoavat uutistietoon erilaisen pääsyn. Toimittaja muokkaa ja katsoo uutista sen kirjoittamiseen tarkoitetun sisällönhallintajärjestelmän kautta, kännykällä uutista lukeva saattaa nähdä uutisen kännykän ominaisuuksiin mukautuvan web-sivuston kautta, ja uutisia listaava uutissivusto saattaa listata uutisesta vain sen otsikon.</p>

		<p>Puhekielessä termillä tietokanta tarkoitetaan yleisesti ottaen tiedon tallentamiseen tarkoitettua paikkaa, josta tietoa voi myös hakea. Esimerkiksi kirkonkirjat voidaan nähdä eräänlaisena sukujen historiaa dokumentoivana tietokantana, jonka kautta sukututkija pääsee käsiksi sukunsa historiaan. Vaikka tietokannat ovat digitalisaation myötä siirtymässä paperisesta muodosta sähköiseen muotoon, on niiden tavoite pysynyt pitkälti samana: <em>haluamme säilöä tietoa, ja haluamme päästä tähän tietoon käsiksi</em>. Tällä kurssilla käsittelemme elektronisia tietokantoja, joiden kehittyminen on johtanut tilanteeseen, missä tietoa tallennetaan yhä enemmän ja sitä halutaan hyödyntää yhä monipuolisemmin.</p>

		<aside class="info">
		  <br/>
		  <h1>Tutustu tietokantaan!</h1>

		  <p>Tässä kohtaa on erittäin hyvä hetki käydä tutustumassa muutamaan tietokantapalveluun. Osoitteessa <a href="http://hiski.genealogia.fi/hiski/" target="_blank">http://hiski.genealogia.fi/hiski/</a> on Suomen Sukututkimusseuran ylläpitämä Historiakirjojen hakupalvelu. Käy sivulle, valitse kieli, etsi "Kaikista", ja valitse "Kastetut".</p>

		  <p>Minkälaisia tuloksia löydät omalla etunimelläsi? Entä, minkälaisia tuloksia löydät nimillä Matti ja Maija? Palvelu pyrkii muunmuassa sisällyttämään läheiset nimien muunnokset hakutuloksiin, sillä nimet muuttuvat ajan myötä. </p>
		</aside>

		<p>Nykyään tietokantoja on kaikkialla. Tämä kurssimateriaali sijaitsee tietokannassa, kurssitehtäviin liittyvät pisteet kirjataan tietokantaan, ja tehdessäsi kurssilla tarpeeksi töitä kurssiin liittyvien oppimistavoitteiden saavuttamiseksi kurssista kirjataan suoritusmerkintä tietokantaan. Jo pelkästään nykyaikaisessa kännykässäsi on kymmeniä erilaisia tietokantoja; yhteystiedot, kalenteri, herätyskello, aikavyöhykkeet, karttapalvelut, suosikkiverkkosivut, jonka lisäksi moni kännykkäsovellus hyödyntää yhtä tai useampaa tietokantaa. Tietokannat voivat olla paikallisia, eli ne voivat sijaita samalla koneella tietokantaa käyttävän ohjelmiston kautta, esimerkiksi kännykässä, tai ne voivat sijaita erillisellä palvelimella, johon otetaan tarvittaessa yhteyttä. Loppukäyttäjän näkökulmastasi tällä ei kuitenkaan ole juurikaan merkitystä. Näet tietokannasta haetun tiedon käyttämäsi sovelluksen tarjoaman näkymän kautta.</p>


		<aside class="info">
		  <br/>
		  <h1>Tieto toistuu, monistuu, ja yhdistyy</h1>

		  <p>Moni tietokantaa käyttävä palvelu käyttää henkilöihin liittyviä tietoja, kuten osoitetta, puhelinnumeroa tai sähköpostiosoitetta. Kun rekisteröidyt verkossa oleviin palveluihin, on tyypillistä, että ne pyytävät vähintään sähköpostiosoitteen. Nämä tiedot tallentuvat kuitenkin palvelu- tai yrityskohtaisiin tietokantoihin, josta niitä mahdollisesti yhdistellään.</p>

		  <p>Pohdi, kuinka moneen palveluun olet syöttänyt sähköpostiosoitteesi? Entä nimesi tai syntymäpäiväsi? Tyypillisesti moni näistä palveluista on erillinen, mutta, tulevaisuudessa tätä tietoa tullaan yhdistämään yhä enemmän ja enemmän paremman yleiskuvan saamiseksi, sekä tilastoihin perustuvien päätösten tekemiseksi.</p>
		  <p>Esimerkiksi sekä sähkö- että peliyhtiöt kummatkin hyötyvät merkittävästi saadessaan tietoa palvelun käyttöasteesta. Sähköyhtiöt voivat käyttää tätä tietoa sähkön tarpeen ennustamiseen, jonka avulla sähkön tuottoa voidaan säännöstellä -- peliyhtiöt taas voivat muunmuassa hyödyntää käyttötilastoja pelin toimivien ja ei-toimivien osa-alueiden kehittämiseen.</p>

		</aside>

		<p>Käytämme tällä kurssilla yhtenä esimerkkinä opiskelun ja oppimisen seuraamiseen tarkoitettua järjestelmää, joka kehittyy materiaalin edetessä. Järjestelmä pitää kirjaa kursseista, opiskelijoista, kurssiharjoituksista, arvosanoista, kurssipalautteista, sekä muista oleellisista asioista, joita kurssin edetessä tulee esille. Jotta tämä onnistuisi, tarvitsemme jonkinlaisen jäsentelytavan eli rakenteen tallennettavalle tiedolle, tapoja tiedon tallentamiseen tässä sovitussa muodossa, sekä tapoja erilaisten raporttien luomiseen. Katsotaan miten käy..</p>



		<h2>Tietokanta ja tiedon rakenteen kuvaaminen</h2>

		<p>Tietokanta on kokoelma tiettyyn aihepiiriin liittyviä säilytettäviä tietoja. Tietokannan luominen liittyy usein jonkinlaisen organisaation, yrityksen tai muun yhteisön tarpeeseen säilöä ja hakea tietoa. Esimerkiksi yliopisto haluaa pitää kirjaa opiskelijoistaan ja heidän opintomenestystään, hotelli haluaa pitää kirjaa hotellin huoneiden varauksista, ja kauppaketju haluaa pitää kirjaa asiakkaistaan ja asiakkaiden ostoksista.</p>

		<p>Tallennettava tieto liittyy tyypillisesti johonkin tavoitteeseen. Yliopisto haluaa seurata opintojen etenemistä esimerkiksi valtionhallinnolle raportointia varten, huoneiden varaustilannetta seuraava hotelli taas haluaa tietää milloin huoneita on paljon tarjolla, ja milloin huoneet ovat lopussa. Kauppaketjun ensisijaisena tavoitteena on asiakkaiden ostosten seuranta myynnin optimoimiseksi.</p>

		<p>Tietokantojen rakennetta ja jäsentelyä suunniteltaessa ongelmaa lähestytään tavoitteeseen liittyvien käsitteiden kautta, joiden avulla pyritään ymmärtämään mikä tiedosta on epäoleellista, ja mikä tulee säilöä. Samalla mietitään myös säilöttävien käsitteiden ominaisuuksia sekä käsitteiden suhteita. Esimerkiksi opiskelijan opintomenestyksen seurannassa oleellisia ovat ainakin käsitteet <em>Opiskelija</em> ja <em>Kurssisuoritus</em>, joilla on yhteys: opiskelijalla on kurssisuorituksia.</p>

		<p>Tällä kurssilla tiedon mallintamiseen käytetään <a href="http://www.uml.org/" target="_blank">UML</a>-kieltä, johon syvennytään tarkemmin kurssilla <em>Ohjelmistotekniikan menetelmät</em>. Käytämme <a href="https://fi.wikipedia.org/wiki/Luokkakaavio" target="_blank">luokkakaavioista</a> johdettua tapaa käsitteiden ominaisuuksien ja suhteiden mallintamiseen, mutta, emme kuitenkaan seuraa kuvaustapaa pilkuntarkasti. Esimerkiksi navigointisuuntaa sekä kooste- ja kompositiomerkintää ei käytetä lainkaan. </p>

		<figure>
		  <img src="img/johdanto/opiskelija-ja-kurssisuoritus-erilliset-kasitteet.png" alt="Teksti 'Opiskelija' suunnikkaan sisään kirjoitettuna, Teksti 'Kurssisuoritus' toisen suunnikkaan sisään kirjoitettuna.">
		  <figcaption>Käsitteet kuvataan laatikkoina, joiden sisällä on käsitteen nimi. Yllä käsitteet Opiskelija ja Kurssisuoritus.</figcaption>
		</figure>

		<p>Jos haluamme ilmaista, että käsite liittyy toiseen käsitteeseen, piirrämme käsitteiden välille viivan. Viivan kumpaankin päätyyn merkitään osallistumisrajoitteet, joilla kuvataan sitä, että kuinka monessa samantyyppisessä yhteydessä käsitteen ilmentymä voi olla. Jos ilmentymään voi liittyä tasan yksi toisen tyyppinen ilmentymä, lisäämme nuolen päähän numeron yksi. Toisaalta, jos ilmentymien määrä on rajoittamaton, lisäämme viivan päähän tähden. Alla olevassa kaaviossa on käsitteet Opiskelija ja Kurssisuoritus, sekä viiva käsitteiden välillä. Yhteen kurssisuoritukseen liittyy aina tasan yksi opiskelija, mutta yhdellä opiskelijalla voi olla useampia kurssisuorituksia.</p>

		<figure>
		  <img src="img/johdanto/opiskelija-ja-kurssisuoritus-ei-attribuutteja.png" alt="Teksti 'Opiskelija' suunnikkaan sisään kirjoitettuna, Teksti 'Kurssisuoritus' toisen suunnikkaan sisään kirjoitettuna. Suunnikkaiden välille on piirretty viiva, jonka Kurssisuoritus-käsitteen päässä on tähti.">
		  <figcaption>Opiskelijaan liittyy useita kurssisuorituksia, mutta jokaiseen kurssisuoritukseen liittyy tasan yksi opiskelija.</figcaption>
		</figure>

		<p>Käsitteisiin kuuluu tyypillisesti ominaisuuksia. Ominaisuudet merkitään laatikkoon käsitteen nimen alle. Alla olevassa kuvassa Opiskelija-käsitteeseen liittyy ominaisuudet nimi, syntymävuosi ja pääaine.</p>

		<figure>
		  <img src="img/johdanto/opiskelija-ja-ominaisuudet.png" alt="Teksti 'Opiskelija' suunnikkaan sisään kirjoitettuna, suunnikkaan alalaidassa kiinni toinen suunnikas, jossa tekstit 'nimi', 'syntymävuosi' ja 'pääaine' omilla riveillään. ">
		  <figcaption>Käsitteillä voi olla ominaisuuksia. Opiskelija-käsitteeseen liittyy nimi, syntymävuosi, ja pääaine.</figcaption>
		</figure>

		<p>Myös kurssisuoritukseen liittyy ominaisuuksia. Alla opiskelijaan liittyy useita kurssisuorituksia, jonka lisäksi käsitteisiin liittyvät ominaisuudet on myös merkitty.</p>

		<figure>
		  <img src="img/johdanto/opiskelija-ja-kurssisuoritus.png" alt="Teksti 'Opiskelija' suunnikkaan sisään kirjoitettuna, Teksti 'Kurssisuoritus' toisen suunnikkaan sisään kirjoitettuna. Suunnikkaiden välille on piirretty viiva, jonka Kurssisuoritus-käsitteen päässä on tähti. Käsitteiden alla on myös niiden ominaisuudet kuten edellisessä kuvassa.">
		  <figcaption>Opiskelijaan liittyy useita kurssisuorituksia. Käsitteille on merkitty myös ominaisuudet.</figcaption>
		</figure>

		<p>Kun piirrät kaavioita, älä käytä piirtämiseen liikaa aikaa. Oleellisinta on se, että tärkeät asiat ovat paperilla. Jos huomaat, että käytät liikaa aikaa, heitä paperi roskiin, ja aloita alusta.</p>

		<aside class="info">
		  <br/>

		  <h1>Pientä pohdintaa!</h1>

		  <p>Hahmottele paperille seuraavaan kuvaukseen liittyvä kaavio yllä esitetyllä tavalla. Mitkä ovat käsitteet, ja miten ne liittyvät toisiinsa?</p>

		  <p><em>Opettajalla on useita kursseja, joita hän opettaa. Jokaiseen kurssiin liittyy ajankohta, jolloin kurssi järjestetään, sekä kurssin käyttämä sali.</em></p>

		  <p>Mitä voimme sanoa opettajan kalenterista kuvauksen perusteella? Entä salien varaustilanteesta?</p>

		</aside>

		<p>Käsitteitä ja niiden sisältämää tietoa voidaan ajatella tauluna, jossa jokainen rivi kuvaa yksittäistä käsitteen ilmentymää.</p>
		
		<div class="data-table">
		  <h4>Opiskelija</h4>
		  <table class="table">
		    <thead>
		      <tr>
			<th>nimi</th>
			<th>syntymävuosi</th>
			<th>pääaine</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>Pihla</td>
			<td>1997</td>
			<td>Tietojenkäsittelytiede</td>
		      </tr>
		      <tr>
			<td>Joni</td>
			<td>1993</td>
			<td>Tietojenkäsittelytiede</td>
		      </tr>
		      <tr>
			<td>Anna</td>
			<td>1991</td>
			<td>Matematiikka</td>
		      </tr>
		      <tr>
			<td>Krista</td>
			<td>1990</td>
			<td>Tietojenkäsittelytiede</td>
		      </tr>
		      <tr>
			<td>Matti</td>
			<td>1970</td>
			<td>Matematiikka</td>
		      </tr>
		      <tr>
			<td>Gandhi</td>
			<td>1869</td>
			<td>Oikeustiede</td>
		      </tr>
		    </tbody>
		  </table>
		</div>

		<p>Vastaavasti myös kurssisuorituksia kuvaamaan voisi tehdä oman erillisen taulun.</p>

		<aside class="info">

		  <br/>

		  <h1>Ensiaskeleita tiedon yhdistämiseen</h1>

		  <p>Kysymykseksi nousee "<em>Miten yhdistämme Opiskelijaa kuvaavan taulun ja Kurssisuoritusta kuvaavan taulun tietoja?</em>". Olio-ohjelmoinnissa Kurssisuoritusolio sisältäisi viitteen Opiskelijaolioon, tai mahdollisesti, jokainen Opiskelijaolio sisältäisi listan viitteitä Kurssisuoritusolioon.</p>

		  <p>Olio-ohjelmoinnissa viite on oikeastaan osoite muistipaikkaan, missä olion tiedot ovat. Voisiko kurssisuoritukseen lisätä jonkinlaisen muistiviitteen opiskelijaan? Palaamme tähän relaatiomallin ja relaatiotietokantojen yhteydessä.</p>

		</aside>


		<h2>Tietokannanhallintajärjestelmä</h2>

		<p>Tietokanta sijaitsee tyypillisesti tietokannanhallintajärjestelmässä, jonka kautta tietokantaan pääsee käsiksi. Tietokannanhallintajärjestelmän vastuulla on tietokantaan kohdistuvien haku-, muokkaus- ja lisäystoimintojen toiminnan lisäksi käyttöoikeuksien valvominen. Yksittäisessä tietokannanhallintajärjestelmässä voi kustannus- ja tehokkuussyistä sijaita useisiin erilaisiin sovelluksiin ja käyttötarkoituksiin liittyviä tietokantoja, joita jokaista käyttää eri käyttäjät tai eri yritys.</p>

		<p>Yksittäinen sovellus voi käyttää myös useampaa tietokantaa, jotka sijaitsevat eri tietokannanhallintajärjestelmissä. Tyypillinen esimerkki tällaisesta sovelluksesta on analytiikkapalvelu, joka yhdistää eri palveluiden tallentamaa tietoa yhteenvetoraporttien luomiseksi.</p>


		<p>Tietokannanhallintajärjestelmän vastuulla on myös tiedon eheyteen liittyvien sääntöjen noudattamisen valvonta. Tietokannassa voi olla esimerkiksi sääntö "Opiskelijan syntymävuoden tulee sisältää neljä numeroa", jolloin uusien opiskelijoiden lisääminen ilman oikein määriteltyä syntymävuotta ei voida lisätä tietokantaan. Vastaavia sääntöjä voidaan lisätä muunmuassa varausjärjestelmiin, esimerkiksi lentokoneiden paikkavarausjärjestelmissä halutaan varmistaa, että jokaisella istuimella on korkeintaan yksi varaus. Vastaavasti, tietokannanhallintajärjestelmän vastuulla on varmistaa, että tietoa ei tuhoudu, vaikka tietokantaa käyttävä järjestelmä hajoaisi -- erilaiset varmuuskopiotoiminnallisuudet ovat tyypillisiä.</p>

		<p>Tämän lisäksi, tietokannanhallintajärjestelmät tarjoavat tyypillisesti välineitä tiedon hakemiseen liittyvien toimintojen tehokkuuden tarkastelemiseen. Vaikka opintojen seurantaan liittyvä järjestelmämme sisältäisi tiedot kaikista Helsingin yliopiston opiskelijoista (n. 35000), sekä kaikista kurssisuorituksista (rutkasti), tulisi tietokantaan tehtävien kyselyjen toimia silti mielekkäässä ajassa. Edellämainittukin tietomäärä on esimerkiksi Amazon-verkkokaupan mittakaavassa hyvin pieni.</p>

		<p>Vaikka tietokantaa käyttävän sovelluksen tehokkuuteen vaikuttaa tietokone tai palvelin, jolle sovellus on asennettu, emme tällä kurssilla ota juurikaan kantaa ns. rautatason toimintaan.</p> 


		<aside class="extra">

		  <h1>Historian siipien havinaa</h1>


		  <p>Tiedon tallentamiseen käytettiin alunperin tekstitiedostoja, joiden välillä tietoa pyrittiin yhdistämään joko manuaalisesti tai ohjelmallisesti. Ensimmäisten tietokannanhallintajärjestelmien yhteydessä siirryttiin tiedon todellisen tallennusmuodon abstrahointiin käyttäjältä, ja tietoa käsiteltiin erillisen ohjelmointirajapinnan kautta. Tiedon linkittäminen tapahtui käytännössä muistiviitteiden avulla, jolloin tiedon hakemiseen liittyi näiden muistiviitteiden kautta navigoiminen, johon tarvittiin asiaan erikoistunut ohjelmoija.</p>

		  
		  <p>Navigointiin perustuvissa järjestelmissä yhtenä ongelmana oli kuitenkin se, että ohjelmoijan tuli korjata järjestelmän navigointirakenne kun rakenne muuttui. Jos tietokannasta poistettiin yksittäinen tietue, saattoi huonoimmassa tapauksessa tietueen kautta löydettävät asiat kadota poiston yhteydessä.</p>
		  
		  <p>Koska tiedon hakeminen oli tyypillisesti hidasta, tietoa tallennettiin useampaan paikkaan navigoimisen vähentämiseksi. Kun tietokoneet kehittyivät, toistetun tiedon käyttämistä voitiin vähentää, ja samalla yksittäistä tietokannanhallintajärjestelmää pystyi käyttämään useampi ohjelmoija ja ohjelma. Suurin viimeaikainen kehitysaskel tapahtui kuitenkin relaatiotietomallin esittelyn yhteydessä, missä vastuu navigointiin liittyvien polkujen tekemisestä jätetään täysin ohjelmoijan vastuulle.</p>

		  <p>Lue osoitteessa <a href="http://www.tomandmaria.com/Tom/Writing/HowThe%20DataGotItsBase.pdf" target="_blank">http://www.tomandmaria.com/Tom/Writing/HowThe%20DataGotItsBase.pdf</a> oleva Thomas Haighin kirjoittama katsaus tietokantojen historiaan.</p>

		</aside>



		<h1>Johdanto relaatiomalliin ja relaatiotietokantoihin</h1>


		<p>Relaatiomallin perusajatus on tallennettavan tiedon jakaminen käsitteisiin sekä käsitteiden välisiin yhteyksiin. Jokaista käsitettä vastaa relaatiotietokannassa taulu, ja jokaiselle käsitteen ominaisuudelle eli attribuutille on taulussa oma sarake. Jokainen taulun rivi vastaa yhtä käsitteen ilmentymää, ja tietokantatauluja määriteltäessä taululle määritellään tyypillisesti myös <em>avain</em>, jonka perusteella kukin rivi -- eli käsitteen ilmentymä -- voidaan yksilöidä.

		<p>Kun pohdimme Opiskelija-käsitettä, jolla on nimi, syntymävuosi, ja pääaine, huomaamme, että opiskelijan yksilöinti olemassaolevien tietojen perusteella on lähes mahdotonta. Esimerkiksi vuonna 1991 syntyneitä matematiikkaa opiskelevia Anna-nimisiä opiskelijoita löytyy useampia.</p>

		<p>Luodaan Opiskelija-käsitteestä tietokantataulu. Tietokantataulussa opiskelija-käsitteelle määritellään opiskelijan yksilöivä avain, jonka lisäksi muut käsitteeseen liittyvät attribuutit lisätään tietokantataulun sarakkeiksi. Tietokantataulun voi piirtää kaaviona kuten alla -- yksilöivän avaimen voi merkitä joko alleviivaamalla käsitteen, tai merkitsemällä käsitteen eteen merkki <em>(pk)</em>, eli <em>primary key</em>.</p>

		<figure>
		  <img src="img/johdanto/opiskelija-ja-opiskelijanumero.png" alt="[Opiskelija|(pk) opiskelijanumero;nimi;syntymävuosi;pääaine]">
		  <figcaption>Opiskelija-taulua luodessa opiskelijaan on lisätty jokaisen opiskelijan yksilöivä avain, tässä tapauksessa opiskelijanumero. Avain on merkitty tekstillä (pk) sen selkeyttämiseksi.</figcaption>
		</figure>


		<p>Tietokantataulussa oleva data voi näyttää esimerkiksi seuraavalta:</p>
		
		<div class="data-table">
		  <h4>Opiskelija</h4>
		  <table class="table">
		    <thead>
		      <tr>
			<th>opiskelijanumero</th>
			<th>nimi</th>
			<th>syntymävuosi</th>
			<th>pääaine</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>9999999</td>
			<td>Pihla</td>
			<td>1997</td>
			<td>Tietojenkäsittelytiede</td>
		      </tr>
		      <tr>
 			<td>9999998</td>
			<td>Joni</td>
			<td>1993</td>
			<td>Tietojenkäsittelytiede</td>
		      </tr>
		      <tr>
			<td>...</td>
			<td></td>
			<td></td>
			<td></td>
		      </tr>
		    </tbody>
		  </table>
		</div>

		<p>Opiskelija-käsitteeseen liittyy useampi Kurssisuoritus, mikä näyttää käsitekaaviona seuraavalta -- allaolevassa käsitekaaviossa Opiskelijaan on lisätty opiskelijanumero:</p>

		<figure>
		  <img src="img/johdanto/opiskelija-opiskelijanumerolla-ja-kurssisuoritus.png" alt="Teksti 'Opiskelija' suunnikkaan sisään kirjoitettuna, Teksti 'Kurssisuoritus' toisen suunnikkaan sisään kirjoitettuna. Suunnikkaiden välille on piirretty viiva, jonka Kurssisuoritus-käsitteen päässä on tähti. Käsitteillä myös ominaisuudet. ">
		  <figcaption>Opiskelijaan liittyy yksi tai useampi kurssisuoritus.</figcaption>
		</figure>


		<p>Relaatiotietokannoissa käsitteiden yhdistäminen tapahtuu avainten avulla. Tietokantatauluun Opiskelija on määritelty jokaisen opiskelijan yksilöivä avain <em>opiskelijanumero</em>. Koska jokaiseen opiskelijaan voi liittyä useampi kurssisuoritus, mutta jokaiseen kurssisuoritukseen vain yksi opiskelija, voimme lisätä kurssisuoritustaulua luodessa siihen <em>viiteavaimen</em> (foreign key), joka viittaa opiskelijaan. Kurssisuoritus-tauluun lisätään siis sarake nimeltä opiskelija, joka sisältää aina kurssisuoritukseen liittyvän opiskelijan opiskelijanumeron. Viiteavain merkitään tekstillä <em>(fk)</em>, eli <em>foreign key</em>, ja viiteavaimen nimen jälkeen tulee Taulun nimi, johon viiteavain viittaa.</p>

		<figure>
		  <img src="img/johdanto/opiskelija-opiskelijanumerolla-ja-kurssisuoritus-taulut.png" alt="[Opiskelija|(pk) opiskelijanumero;nimi;syntymävuosi;pääaine]1-*[Kurssisuoritus|(fk) opiskelija: Opiskelija;kurssi;päivämäärä;arvosana]">
		  <figcaption>Opiskelijaan liittyy yksi tai useampi kurssisuoritus.</figcaption>
		</figure>


		<p>Tietokantataulussa Kurssisuoritus oleva data näyttää esimerkiksi seuraavalta:</p>

		<div class="data-table">
		  <h4>Kurssisuoritus</h4>
		  <table class="table">
		    <thead>
		      <tr>
			<th>opiskelija</th>
			<th>kurssi</th>
			<th>päivämäärä</th>
			<th>arvosana</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>9999999</td>
			<td>Ohjelmoinnin perusteet</td>
			<td>1.8.2014</td>
			<td>5</td>
		      </tr>
		      <tr>
			<td>9999999</td>
			<td>Ohjelmoinnin jatkokurssi</td>
			<td>1.8.2014</td>
			<td>5</td>
		      </tr>		      
		      <tr>
			<td>9999999</td>
			<td>Tietokantojen perusteet</td>
			<td>20.10.2014</td>
			<td>3</td>
		      </tr>
		      <tr>
			<td>...</td>
			<td></td>
			<td></td>
			<td></td>
		      </tr>		      
		      <tr>
 			<td>9999998</td>
			<td>Ohjelmoinnin perusteet</td>
			<td>1.8.2013</td>
			<td>4</td>
		      </tr>
		      <tr>
			<td>...</td>
			<td></td>
			<td></td>
			<td></td>
		      </tr>
		    </tbody>
		  </table>
		</div>

		<p>Ylläolevat taulut voidaan määritellä myös tekstimuodossa seuraavasti: </p>

		<ul>
		  <li>Opiskelija(<u>opiskelijanumero</u>, nimi, syntymävuosi, pääaine)</li>
		  <li>Kurssisuoritus(opiskelija->Opiskelija, kurssi, päivämäärä, arvosana)</li>
		</ul>

		<p>Opiskelijaan liittyvä opiskelijanumero on alleviivattu, sillä se on Opiskelija-taulun avain. Kurssisuoritustaulun merkintä <code>opiskelija->Opiskelija</code> taas tarkoittaa, että opiskelija on viiteavain, ja viittaa Opiskelija-taulun avaimeen.</p>


		<p>Pohditaan seuraavaksi kyselyiden tekemistä näihin tauluihin.</p>


		<h2>SQL-kyselykieli</h2>

		<p>SQL on kyselykieli relaatiotietokantojen käsittelyyn. Sen avulla voidaan hakea tietoa tietokannasta, päivittää tietokannassa olevaa tietoa, sekä muokata ja luoda tietokannan rakennetta. Käytännössä kaikki relaatiotietokantoja tukevat tietokannanhallintajärjestelmät käyttävät myös SQL-kieltä. </p>

		<p>Parhaiten kyselykieltä ymmärtää sitä harjoittelemalla. Sitä teemme paljon.</p>

		<aside class="info">

		  <br/>
		  <h1>Ohjeita SQL-tehtävien tekemiseen</h1>

		  <p>Kurssimateriaalissa on tästä kohdasta eteenpäin interaktiivisia SQL-tehtäviä, joiden avulla pääset harjoittelemaan SQL-kyselykielen käyttöä. Materiaali sisältää materiaalin edetessä täydentyvän opiskelijoiden kurssisuorituksia kuvaavan tietokannan, jota käytetään ellei toisin mainita. Lähes jokaisen esimerkkikyselyn voi suorittaa, jolloin kysely ajetaan tietokannassa ja kyselyn tulos näytetään ruudulla. Kyselyn suorittaminen tapahtuu <em>Suorita</em>-nappia painamalla.</p>

		  <p>Useimpien suoritettavien esimerkkien jälkeen avautuu muutama tehtävä, jossa pääset harjoittelemaan esimerkkiä vastaavien kyselyjen tuottamista.</p>

		</aside>

		<div ng-controller="weekOneSqlController">


		  <h4>SELECT * FROM <em>Taulu</em></h4>
		  
		  <p>Avainsanalla <code>SELECT</code> valitaan tietyt sarakkeet kyselyn kohteena olevasta taulusta. Sarakkeet määritellään <code>SELECT</code>-avainsanan jälkeen. Jos ohjelmoija haluaa valita kaikki taulussa olevat sarakkeet, käytetään sarakkeiden valinnassa tähteä (<code>*</code>). Sarakkeiden määrittelyä seuraa avainsana <code>FROM</code>, jonka jälkeen kerrotaan kyselyn kohteena oleva taulu.</p>
		  
		  <p>Alla voit kokeilla kyselyn tekemistä aiemmin määriteltyihin <code>Opiskelija</code> ja <code>Kurssisuoritus</code>-tauluihin.</p>
		  
		  
		  <query
		     db="db"
		     query="SELECT * FROM Opiskelija"
		     editable="false"
		     done="listAllStudentsDone">
		  </query>
		  
		  <div ng-show="listAllStudentsDone">
		    
		    <h4>Tehtävät</h4>
		    
		    <p>Tee nyt kysely, jolla saat listattua kaikki <code>Kurssisuoritus</code>-taulussa olevat rivit.</p>
		    
		    <togglable content="taulut" db="db">
                      <table-info></table-info>
		    </togglable>
		    
		    <query db="db"
			   valid="SELECT * FROM Kurssisuoritus"></query>
		  </div>
		  

		  
		  <h4>SELECT <em>sarake, toinen</em> FROM <em>Taulu</em></h4>
		  
		  <p>Avainsanan <code>SELECT</code> jälkeen voidaan määritellä valittavat sarakkeet. Tähteä käyttämällä valitaan kaikki sarakkeet, mutta ohjelmoija voi valita myös yksittäisiä sarakkeita. Jos tähteä ei käytetä, ja halutaan valita useampia sarakkeita, valittavat sarakkeet erotellaan pilkulla.</p>
		  
		  
		  <query
		     db="db"
		     query="SELECT nimi, syntymävuosi FROM Opiskelija"
		     editable="false"
		     done="listAllStudentsWithAttributesDone">
		  </query>
		  
		  <div ng-show="listAllStudentsWithAttributesDone">
		    
		    <h4>Tehtävät</h4>
		    
		    <p>Tee nyt kysely, jolla saat listattua <code>Kurssisuoritus</code>-taulussa olevien kurssien nimet.</p>
		    
		    <togglable content="taulut" db="db">
                      <table-info></table-info>
		    </togglable>
		    
		    <query db="db"
			   valid="SELECT kurssi FROM Kurssisuoritus"></query>
		  </div>


		  <h4>SELECT <em>DISTINCT</em> <em>sarake</em> FROM <em>Taulu</em></h4>
		  
		  <p>Kun haimme edellisessä harjoitteluosiossa Kurssisuoritus-taulussa olevien kurssien nimiä, huomasimme, että muutamat kurssien nimet näkyivät useampaan otteeseen. Tämä johtuu siitä, että kysely valitsee taulun rivit, ja taulussa yksinkertaisesti oli useampia rivejä, joilla esiintyi samat kurssit.</p>

		  <p>Avainsanalla <code>DISTINCT</code> voidaan valita vain uniikit vastausrivit. Avainsana <code>DISTINCT</code> tulee avainsanan <code>SELECT</code> jälkeen.</p>
		  
		  
		  <query
		     db="db"
		     query="SELECT DISTINCT pääaine FROM Opiskelija"
		     editable="false"
		     done="listDistinctMajorsDone">
		  </query>
		  
		  <div ng-show="listDistinctMajorsDone">
		    
		    <h4>Tehtävät</h4>
		    
		    <p>Tee nyt kysely, jolla saat listattua <code>Kurssisuoritus</code>-taulussa olevat <em>uniikit</em> kurssit.</p>
		    
		    <togglable content="taulut" db="db">
                      <table-info></table-info>
		    </togglable>
		    
		    <query db="db"
			   valid="SELECT DISTINCT kurssi FROM Kurssisuoritus"></query>
		  </div>



		  <h4>SELECT * FROM <em>Taulu</em> <em>WHERE</em>...</h4>
		  
		  <p>Emme tyypillisesti kuitenkaan halua valita kaikkea taulussa olevaa dataa, vaan vain tietyt hakuehdot täyttävän osajoukon. Avainsanan <code>WHERE</code> avulla kyselyille annetaan hakuehtoja. Hakuehtojen perusteella kyselyn tulokseen valitaan vain ne rivit, joissa hakuehdossa määritellyn sarakkeen arvot täyttävät hakuehdon. Hakuehto voi olla esimerkiksi muotoa <code>...WHERE nimi = 'Joni'</code>, jolloin valittaisiin vain ne rivit, joissa sarakkeen <code>nimi</code> arvo on <code>'Joni'</code>.</p>

		  <query
		     db="db"
		     query="SELECT * FROM Opiskelija WHERE nimi = 'Joni'"
		     editable="false"
		     done="selectJoniDone">
		  </query>
		  
		  <div ng-show="selectJoniDone">
		    
		    <h4>Tehtävät</h4>
		    
		    <p>Tee nyt kysely, jolla saat listattua <code>Opiskelija</code>-taulusta kaikki ne opiskelijat, joiden nimi on 'Anna'.</p>
		    
		    <togglable content="taulut" db="db">
                      <table-info></table-info>
		    </togglable>
		    
		    <query db="db" 
			   valid="SELECT * FROM Opiskelija WHERE nimi = 'Anna'"
			   done="selectAnnaDone"></query>


		    <div ng-show="selectAnnaDone">
		    
		      <p>Tee nyt kysely, jolla saat listattua <code>Kurssisuoritus</code>-taulusta kaikki Pihla-nimisen opiskelijan suoritukset. Voit olettaa, että Opiskelija-taulun sisältö on täsmälleen se, kuin mikä se tähän asti on ollut. Vinkki: millä Pihlan tunnistaa kummassakin taulussa?</p>
		    
		      <togglable content="taulut" db="db">
			<table-info></table-info>
		      </togglable>
		      
		      <query db="db"
			     valid="SELECT * FROM Kurssisuoritus WHERE opiskelija = '999999'"></query>

		    </div>
		  </div>

		  <aside class="info">
		    <br/>
		    <h1>SQL-kyselyiden kirjainkoko</h1>
		    
		    <p>SQL on "case insensitive", eli sillä, että onko kysely kirjoitettu isolla vai pienellä ei ole kyselyn suorituksen kannalta merkitystä. Voimme kirjoittaa komennon <code>SELECT</code> yhtä hyvin muodossa <code>select</code> tai <code>Select</code> -- sama pätee myös taulujen nimille ja attribuuteille.</p>

		    <p>Taulussa olevaa dataa tarkasteltaessa kirjainkoolla on kuitenkin merkitystä. Kun teemme esimerkiksi vertailuoperaatioita merkkijonoille, on merkkijonon kirjoitusasu tärkeä. Kysely <code>SELECT * FROM Opiskelija WHERE nimi = 'Joni'</code> palauttaa vain ne opiskelijat, joiden nimi-kentän arvo on <em>täsmälleen</em> 'Joni'. Jos rivillä olevan nimi-kentän arvo olisi vaikkapa 'joni', ei edellinen kysely valitsisi kyseistä riviä.</p>

		    <p>Noudatamme tällä kurssilla seuraavaa käytäntöä:</p>

		    <ol>
		      <li>Kaikki SQL-kielen komennot, kuten <code>SELECT</code>, <code>FROM</code> ja <code>WHERE</code>, kirjoitetaan isolla.</li>
		      <li>Taulujen nimet kirjoitetaan isolla alkukirjaimella. Esimerkiksi <code>Opiskelija</code> ja <code>Kurssisuoritus</code>.</li>
		      <li>Taulujen sarakkeet eli attribuutit kirjoitetaan pienellä. Esimerkiksi <code>nimi</code> ja <code>kurssikoodi</code>.</li>
		    </ol>

		  </aside>


		  <p>Kyselyissä toimivat myös suurempi kuin <code>&gt;</code> ja pienempi kuin <code>&lt;</code> -operaatiot.</p>

		  <p>Jos sarakkeen arvot ovat merkkijonoja, kuten kurssin nimi ja opiskelijan nimi, voi hakuehdossa käyttää myös <code>LIKE</code>-operaatiota. Tämän avulla hakutuloksia voi rajata osittaisen merkkijonon avulla. Esimerkiksi kysely <code>SELECT * FROM Opiskelija WHERE nimi LIKE '%a%'</code> hakee kaikki opiskelijat, joiden nimessä esiintyy pieni a-kirjain.</p>


		  <query
		     db="db"
		     query="SELECT * FROM Opiskelija WHERE nimi LIKE '%a%'"
		     editable="false"
		     done="listOpiskelijatWithSmallAInName">
		  </query>
		  
		  <div ng-show="listOpiskelijatWithSmallAInName">
		    
		    <h4>Tehtävät</h4>
		    
		    <p>Tee nyt kysely, jolla saat listattua kaikki Opiskelija-taulussa olevat pääaineet, joissa esiintyy sana "tiede". </p>
		    
		    <p>Huom! Tee kysely siten, että näet vain uniikit vastaukset. Kyselyn vastauksessa pitäisi olla vain 2 riviä. Kun saat kyselyn toimimaan, kokeile mitä tapahtuu jos muutat 'LIKE'-operaation muotoon 'NOT LIKE'.</p>
		    
		    <togglable content="taulut" db="db">
                      <table-info></table-info>
		    </togglable>
		    
		    <query db="db"></query>
		  </div>
		  
		</div>


		<aside class="info">
		  <br/>

		  <h1>Loogiset operaatiot 'ja' ja 'tai'</h1>

		  <p>Rajausehtoihin voi myös lisätä loogisia operaatioita kyselyjen tulosten tajaamiseksi. Operaatio 'ja', eli kahden rajausehdon yhdistäminen, toimii avainsanalla <code>AND</code>. Esimerkiksi kysely <code>SELECT * FROM Kurssisuoritus WHERE Kurssi = 'Ohjelmoinnin perusteet' AND Arvosana = 5</code> listaisi vain ne Ohjelmoinnnin perusteet -kurssin suoritukset, missä arvosana on 5.</p>

		  <p>Operaation 'tai' lisääminen on myös mahdollista. Esimerkiksi kysely <code>SELECT * FROM Kurssisuoritus WHERE Kurssi = 'Ohjelmoinnin perusteet' OR Kurssi = 'Ohjelmoinnin jatkokurssi'</code> listaisi kaikki ne kurssisuoritukset, joissa kurssi on joko ohjelmoinnin perusteet tai ohjelmoinnin jatkokurssi.</p>

		  <p>Ehtoja voi myös yhdistää, jonka lisäksi suluilla voi rajata suoritusjärjestystä. Ota selvää mitä kysely <code>SELECT * FROM Kurssisuoritus WHERE (Kurssi = 'Ohjelmoinnin perusteet' OR Kurssi = 'Ohjelmoinnin jatkokurssi') AND Arvosana = 3</code> tekee.</p>

		</aside>

		<header>
		  <h1 id="viikko2">Viikko 2</h1>
		</header>


		<h2>Erilaiset yhteystyypit</h2>

		<p>Huomaamme, että käsite Kurssisuoritus oikeastaan liittyy kahteen eri asiaan; kurssiin ja kurssin suoritukseen. Eriytetään nämä kaksi käsitettä toisistaan.</p>

		<p>Kurssiin liittyy kurssin yleiset tiedot kuten kurssin nimi, kurssikoodi, sekä kurssin kuvaus. Kurssisuoritus taas liittyy tiettyyn kurssiin, opikelijaan, päivämäärään, arvosanaan, sekä opintopistemäärään. Opintopistemäärä pidetään osana kurssisuoritusta, sillä joillain kursseilla opintopistemäärä vaihtelee työmäärästä riippuen. Käsite Opiskelija säilyy sellaisenaan.</p>

		<p>Yhteen kurssisuoritukseen liittyy aina yksi kurssi, mutta yhteen kurssiin voi liittyä monta kurssisuoritusta. Käsitekaaviona tämä näyttää seuraavalta:</p>

		<figure>
		  <img src="img/johdanto/opiskelija-kurssisuoritus-kurssi.png" alt="Opiskelija 1-* Kurssisuoritus *-1 Kurssi"/> 
		  <figcaption>Jokaisella opiskelijalla voi olla useita kurssisuorituksia, ja jokaiseen kurssisuoritukseen liittyy tasan yksi opiskelija. Jokaiseen kurssisuoritukseen liittyy myös tasan yksi kurssi, ja jokaisella kurssilla voi olla useita kurssisuorituksia.</figcaption>
		</figure>

		<p>Tutkitaan ensin ylläolevan kaavion osaa, missä kurssisuoritukseen liittyy yksi kurssi ja yhteen Kurssiin monta kurssisuoritusta. Emme hetkeen välitä Opiskelija-käsitteen olemassaolosta. Sekä kurssisuoritukselle että kurssille on määritelty niihin liittyvät attribuutit.</p>


		<figure>
		  <img src="img/johdanto/kurssisuoritus-kurssi-attrs.png" alt="[Kurssisuoritus|päivämäärä;arvosana;opintopistemäärä]*-1[Kurssi|nimi;kuvaus]"/> 
		  <figcaption>Jokaiseen kurssisuoritukseen liittyy yksi kurssi, mutta kurssilla voi olla useampia kurssisuorituksia.</figcaption>
		</figure>

		


		<aside class="info">
		  <br/>
		  <h1>Yhteystyyppi yhden suhde moneen</h1>

		  <p>Kahden käsitteen välillä on yhden suhde moneen (<code>1-N</code>) -yhteys, jos ensimmäisen käsitteen ilmentymään voi liittyä monta toisen käsitteen ilmentymää, mutta yhteen toisen käsitteen ilmentymään voi liittyä vain yksi ensimmäisen käsitteen ilmentymä.</p>

		  <p>Esimerkiksi <em>Olli Opiskelijaan</em> voi liittyä monta erilaista kurssisuoritusta, mutta tiettyyn kurssisuoritukseen voi liittyä aina vain yksi opiskelija, joka jossain tapauksessa <em>voi</em> olla Olli Opiskelija.</p>

		  <p>Saman yhteystyypin voi ajatella myös tietokantataulujen välillä. Kahden taulun välillä on yhteys yhden suhde moneen, jos yhteen ensimmäisen taulun riviin voi liittyä useita toisen taulun rivejä, mutta yhteen toisen taulun riviin voi liittyä vain yksi ensimmäisen taulun rivi.</p>

		  <p><em>Tietokantataulujen luominen</em></p>
		  
		  <figure>
		    <img src="img/viikko2/yhdesta-moneen-kasitteet.png" alt="[A]1-*[B]"/> 
		    <figcaption>Yhden suhde moneen. Yhteen A-käsitteeseen voi liittyä monta B-käsitettä, mutta yhteen B-käsitteeseen liittyy aina tasan yksi A-käsite.</figcaption>
		  </figure>
		  
		  
		  <p>Kun kahden käsitteen välillä on yhden suhde moneen -yhteys, luodaan niiden perusteella tietokantataulut seuraavasti. Luodaan ensin käsitteestä, jonka "viivan päässä" on numero 1, tietokantataulu, ja määritellään sille käsitteen ilmentymät yksilöivä pääavain. Jos käsitteeseen liittyy muita ominaisuuksia tai attribuutteja, asetetaan ne tietokantataulun sarakkeiksi.</p>
		  
		  <figure>
		    <img src="img/viikko2/kasite-a-paaavain.png" alt="[A|(pk) id]"/> 
		    <figcaption>Käsitteen A perusteella luotu tietokantataulu, jolle on määritelty pääavain <em>id</em>. </figcaption>
		  </figure>
		  
		  <p>Tämän jälkeen luodaan käsitteestä, jonka "viivan päässä" on tähti, tietokantataulu, ja määritellään sille <em>viiteavain</em>, jonka avulla voimme viitata aiemmin luotuun tauluun.</p>
		  
		  <figure>
		    <img src="img/viikko2/kasite-b-viiteavain.png" alt="[B|(fk) a_id: A]"/> 
		    <figcaption>Käsitteen B perusteella luotu tietokantataulu, jolle on määritelty viiteavain <em>a_id</em>, joka viittaa tauluun A. </figcaption>
		  </figure>
		  
		  
		  <p>Tämän jälkeen piirretään viiva tietokantataulujen välille.</p>
		  
		  
		  <figure>
		    <img src="img/viikko2/taulut-a-b.png" alt="[A|(pk) id]1-*[B|(fk) a_id: A]"/> 
		    <figcaption>Tietokantataulussa A on pääavain <em>id</em>. Tietokantataulussa B on viiteavain <code>a_id</code>, joka viittaa tietokantatauluun A.</figcaption>
		  </figure>
		  
		  <p>Yllä kuvattiin, miten yhden suhde moneen -yhteystyypin tapauksessa luodaan käsitekaaviosta tietokantataulut.</p>
		  
		</aside>
		

		<p>Luodaan seuraavaksi Kurssisuorituksesta ja Kurssista tietokantataulut.</p>


		<figure>
		  <img src="img/johdanto/kurssisuoritus-kurssi-attrs.png" alt="[Kurssisuoritus|päivämäärä;arvosana;opintopistemäärä]*-1[Kurssi|nimi;kuvaus]"/> 
		  <figcaption>Jokaiseen kurssisuoritukseen liittyy yksi kurssi, mutta kurssilla voi olla useampia kurssisuorituksia.</figcaption>
		</figure>


		<p>Ensimmäinen askel on tietokantataulun Kurssi luominen sekä sen pääavaimen määrittely. Kurssin nimi ei ole hyvä avain, sillä esimerkiksi kurssi "Tietokone työvälineenä" toistuu eri tiedekunnissa ja laitoksissa. Toisaalta, avaimen on hyvä olla sellainen, että se ei muutu -- (jos avain muuttuisi, kaikki viiteavaimet tulisi myös päivittää) -- kuvauskaan ei ole hyvä avain. Luodaan avainta varten uusi attribuutti, <em>kurssitunnus</em>, ja lisätään se tauluun muiden kurssikäsitteeseen liittyvien attribuuttien kanssa.</p>


		<figure>
		  <img src="img/viikko2/kurssi-paaavaimella.png" alt="[Kurssi|(pk) kurssitunnus;nimi;kuvaus]"/> 
		</figure>

		<p>Luodaan tämän jälkeen taulu Kurssisuoritus. Koska jokaiseen kurssisuoritukseen liittyy yksi kurssi, luodaan tauluun viiteavain <em>kurssi</em>, joka viittaa Kurssi-tauluun. Muut attribuutit lisätään tauluun viiteavaimen lisäksi.</p>


		<figure>
		  <img src="img/viikko2/kurssisuoritus-viiteavaimella.png" alt="[Kurssi|(pk) kurssitunnus;nimi;kuvaus]"/> 
		</figure>

		<p>Yhdistetään tietokantataulut vielä viivalla.</p>


		<figure>
		  <img src="img/viikko2/kurssisuoritus-ja-kurssi-tietokantataulut.png" alt="[Kurssisuoritus|(fk) kurssi: Kurssi;päivämäärä;arvosana;opintopistemäärä]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]"/> 
		</figure>		

		<p>&nbsp;</p>

		<p><em><strong>Kolmannen tietokantakaulun lisääminen tietokantakaavioon</strong></em></p>

		<p>Tarkastellaan seuraavaa käsitekaaviota, ja tehdään siitä seuraavaksi tietokantakaavio.</p>

		<figure>
		  <img src="img/viikko2/opiskelija-kurssisuoritus-kurssi-luokkakaavio.png" alt="[Opiskelija|opiskelijanumero;nimi;syntymävuosi;pääaine] 1-* [Kurssisuoritus|päivämäärä;arvosana;opintopistemäärä]
[Kurssisuoritus] *-1 [Kurssi|nimi;kuvaus]"/> 
		</figure>		

		<p>Teimme edellä jo käsitteistä Kurssi ja Kurssisuoritus tietokantakaavion, joten voimme keskittyä nyt käsitteiden Opiskelija ja Kurssisuoritus väliseen suhteeseen.</p>


		<p>Aloitamme taas käsitteestä, jonka viivan päässä on 1, eli tässä tapauksessa opiskelijasta. Kuten aiemmin, käytämme tietokantataululle Opiskelija avaimena opiskelijanumeroa, sillä se yksilöi jokaisen opiskelijan.</p>

		<figure>
		  <img src="img/johdanto/opiskelija-ja-opiskelijanumero.png" alt="[Opiskelija|(pk) opiskelijanumero;nimi;syntymävuosi;pääaine]">
		</figure>

		<p>Keskitytään tämän jälkeen viivan toiseen päähän, eli tässä tapauksessa käsitteeseen Kurssisuoritus. Koska yhteen kurssisuoritukseen liittyy tasan yksi opiskelija, lisätään Tauluun Kurssisuoritus viiteavain <em>opiskelija</em>, joka viittaa opiskelijaan. Muuten taulu pysyy samana kuten aiemminkin.</p>

		<p>Voimme nyt yhdistää kaikki taulut yhteen, jolloin tietokantakaavio on seuraavanlainen:</p>

		<figure>
		  <img src="img/viikko2/opiskelija-kurssisuoritus-kurssi-tietokantakaavio.png" alt="[Opiskelija|(pk) opiskelijanumero;nimi;syntymävuosi;pääaine]1-*[Kurssisuoritus|(fk) opiskelija: Opiskelija;(fk) kurssi: Kurssi;päivämäärä;arvosana;opintopistemäärä]
[Kurssisuoritus]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]"/> 
		</figure>

		
		
		<aside class="info">
		  <br/>
		  <h1>Yhdistelyharjoittelua SQL:llä</h1>

		  <p>Käytössämme on nyt edellä luodut tietokantataulut sekä muutamia muita tauluja, mitä luomme kohta. Harjoitellaan tässä välissä hieman kyselyiden tekemistä edellä luotuihin kolmeen tauluun.</p>

		  <p>Useamman taulun yhdistäminen tapahtuu <code>WHERE</code>-ehdon avulla esimerkiksi seuraavasti: <code>SELECT * FROM Opiskelija, Kurssisuoritus WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija</code>, eli "Anna kaikki riviyhdistelmät tauluista Opiskelija ja Kurssisuoritus, joissa attribuuttien opiskelijanumero ja opiskelija arvot ovat samat".</p>

		  <p>Edellä ehto <code>WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija</code> luo ehdon, missä kyselyn tulokseen valitaan mukaan vain ne rivit, missä Opiskelija-taulun opiskelijanumero on sama kuin Kurssisuoritus-taulun opiskelija. Käytännössä tämä kysely kytkee Opiskelija-taulun pääavaimen ja Kurssisuoritustaulun Opiskelija-tauluun viittaavan viiteavaimen.</p>

		  <div ng-controller="weekTwoSqlController">
		    <query
		       db="db"
		       query="SELECT * FROM Opiskelija, Kurssisuoritus WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija"
		       editable="false"
		       done="listOpiskelijatAndKurssisuoritukset">
		    </query>
		    
		    <div ng-show="listOpiskelijatAndKurssisuoritukset">
		      
		      <h4>Tehtävät</h4>
		      
		      <p>Tee nyt kysely, jolla saat listattua kaikki Kurssit ja niihin liittyvät kurssisuoritukset. Valitse näytettäviksi sarakkeiksi vain kurssin <code>nimi</code> ja kurssisuorituksen <code>päivämäärä</code> ja <code>arvosana</code>.</p>

		      <p>Kyselyn tuloksessa pitäisi olla 4 riviä ja 3 saraketta.</p>
		      
		      <togglable content="taulut" db="db">
			<table-info></table-info>
		      </togglable>
		      
		      <query db="db"></query>
		    </div>
		  </div>

		</aside>
		



		<p><strong><em>Yhteystyypit jatkuu: kursseihin liittyy tehtäviä</em></strong></p>
		

		<p>Haluamme, että järjestelmämme voi pitää kirjaa myös kursseihin liittyvistä tehtävistä, joita opiskelija voi suorittaa. Koska kurssiin liittyvien tehtävien määrä voi vaihdella, määritellään yhteys siten, että yhteen kurssiin voi liittyä useita tehtäviä. Toisaalta, koska sama tehtävä voi esiintyä useammalla kurssilla, määritellään yhteys siten, että yhteen tehtävään liittyä useampi kurssi.</p>


		<figure>
		  <img src="img/johdanto/tehtava-kurssi.png" alt="[Tehtävä] *-* [Kurssi]"/> 
		  <figcaption>Tehtävä voi liittyä useampaan kurssiin, ja kurssi voi liittyä useampaan tehtävään.</figcaption>
		</figure>

		<p>Yllä kuvattu yhteystyyppi on <em>monen suhde moneen</em>.</p>


		<aside class="info">
		  <br/>
		  <h1>Yhteystyyppi monen suhden moneen</h1>

		  <p>Kahden käsitteen välillä on monen suhde moneen (<code>N-N</code>) -yhteys, jos ensimmäisen käsitteen ilmentymään voi liittyä monta toisen käsitteen ilmentymää, ja toisen käsitteen ilmentymään voi liittyä monta ensimmäisen käsitteen ilmentymä.</p>

		  <p>Esimerkiksi yhteen kurssiin voi liittyä monta tehtävää, ja yksi tehtävä voi liittyä useampaan kurssiin.</p>

		  <p>Saman yhteystyypin voi ajatella myös tietokantataulujen välillä. Kahden taulun välillä on yhteys monen suhde moneen, jos yhteen ensimmäisen taulun riviin voi liittyä useita toisen taulun rivejä, ja yhteen toisen taulun riviin voi liittyä useita ensimmäisen taulun rivejä.</p>
		  

		  <p><em>Tietokantataulujen luominen</em></p>

		  <figure>
		    <img src="img/viikko2/monesta-moneen-a-b.png" alt="[A]*-*[B]"/> 
		    <figcaption>Monen suhde moneen. Yhteen A-käsitteeseen voi liittyä monta B-käsitettä, ja yhteen B-käsitteeseen voi liittyä monta A-käsitettä.</figcaption>
		  </figure>


		  <p>Jos käsitteiden välillä on monen suhde moneen -yhteys, luodaan niistä tietokantataulut seuraavasti. Määritellään ensin kummallekin käsitteelle <em>pääavain</em>.

		  <figure>
		    <img src="img/viikko2/monesta-moneen-a-b-paaavaimilla.png" alt="[A|(pk) id]
[B|(pk) id]"/> 
		    <figcaption>Tietokantataulut A ja B. Kummallekin tietokantataululle on määritelty oma taulussa olevan tiedon yksilöivä avain.</figcaption>
		  </figure>
		 
		  <p>Kun tietokantatauluille on määritelty pääavaimet, luodaan uusi tietokantataulu, jonka jokainen rivi yhdistää yhden rivin taulusta A yhden taulun B rivin kanssa. Tällaista taulua kutsutaan nimellä <em>liitostaulu</em>, ja se sisältää kaksi viiteavainta: yhden kumpaankin viitattavaan tauluun.</p>

		  <figure>
		    <img src="img/viikko2/monesta-moneen-liitostaulu.png" alt="[Liitostaulu|(fk) a_id: A;(fk) b_id: B]"/> 
		    <figcaption>Liitostaulu sisältää kaksi viiteavainta. Yhden, joka viittaa tauluun A, ja toisen, joka viittaa tauluun B.</figcaption>
		  </figure>

		  <p>Yhdistetään seuraavaksi taulut liitostaululla. Liitostaulun jokainen rivi voi viitata vain yhteen taulun A riviin ja yhteen taulun B riviin, joten liitostaulusta lähtevässä yhteydessä taulujen A ja B päätyihin tulee numerot yksi. Toisaalta, liitostaulussa voi olla monta riviä, missä esiintyy viite tiettyyn taulun A riviin -- samoin myös taulun B riviin, joten liitostaulun päähän tulee tähti.</p>



		  <figure>
		    <img src="img/viikko2/monesta-moneen-liitostaulu-yhteydet.png" alt="[A|(pk) id]1-*[Liitostaulu|(fk) a_id: A;(fk) b_id: B]
[Liitostaulu]*-1[B|(pk) id]"/> 
		    <figcaption>Liitostaulun avulla monesta moneen suhde saadaan muutettua kahdeksi yhdestä moneen suhteeksi.</figcaption>
		  </figure>

		</aside>
		
		<p>Tarkastellaan uudestaan käsitteiden tehtävä ja kurssi yhteyttä, ja muunnetaan käsitekaavio tietokantakaavioksi.</p> 

		<figure>
		  <img src="img/johdanto/tehtava-kurssi.png" alt="[Tehtävä] *-* [Kurssi]"/> 
		</figure>


		<p>Ensimmäinen askel on taulujen luominen sekä niihin liittyvien avainten määrittely. Olemme aiemmin luoneet taulun käsitteestä kurssi, sekä määritelleet sille pääavaimen, joten keskitymme vain taulun Tehtävä luomiseen.</p>

		<p>Määritellään, että tehtävään liittyy <em>nimi</em> ja <em>kuvaus</em>. Kumpikaan niistä ei sovellu tehtävän avaimeksi, joten luodaan tehtävälle avain <em>tunnus</em>, joka yksilöi jokaisen tehtävän. Käsitteestä Tehtävä luotu tietokantataulu on seuraavanlainen:</p>

		<figure>
		  <img src="img/viikko2/tehtava-tietokantataulu.png" alt="[Tehtävä|(pk) tunnus;nimi;kuvaus]"/> 
		  <figcaption>Tehtävä-taulussa on pääavaimena tunnus, jonka lisäksi sillä on attribuutit nimi ja kuvaus.</figcaption>
		</figure>


		<p>Luodaan seuraavaksi liitostaulu, jonka tehtävänä on yhdistää taulut Tehtävä ja Kurssi. Kutsutaan liitostaulua nimellä Kurssitehtävä. Kurssitehtävä-taululla on kaksi viiteavainta, joista toinen osoittaa tauluun Tehtävä, ja toinen tauluun Kurssi.</p>

		<figure>
		  <img src="img/viikko2/kurssitehtava-liitostaulu.png" alt="[Kurssitehtävä|(fk) tehtävä: Tehtävä; (fk) kurssi: Kurssi]"/> 
		  <figcaption>Kurssitehtävä-liitostaulussa on kaksi viiteavainta, jotka osoittavat tauluihin Tehtävä ja Kurssi.</figcaption>
		</figure>

		<p>Lisätään seuraavaksi yhteydet käsitteiden välille -- tämä tapahtuu lähinnä visualisoinnin takia, viitteet ovat todellisuudessa olemassa jo viiteavainten muodossa. Yhteen Kurssitehtävä-taulun riviin liittyy tasan yksi Kurssi-taulun rivi ja Tehtävä-taulun rivi, mutta yksi Kurssi-taulun rivi voi liittyä moneen Kurssitehtävä-taulun riviin -- samoin kuin yksi Tehtävä-taulun rivi voi liittyä moneen Kurssitehtävä-taulun riviin.</p>

		<p>Tietokantakaavio on lopulta seuraavanlainen:</p>

		<figure>
		  <img src="img/viikko2/monesta-moneen-tehtava-kurssitehtava-kurssi.png" alt="[Tehtävä|(pk) tunnus;nimi;kuvaus]1-*[Kurssitehtävä|(fk) tehtävä: Tehtävä; (fk) kurssi: Kurssi]
[Kurssitehtävä]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]"/> 
		  <figcaption>Nyt jos tehtävä on tietyllä kurssilla, on taulussa kurssitehtävä rivi, missä on tehtävän ja kurssin yksilöivä tunnus.</figcaption>
		</figure>


		<aside class="info">
		  <br/>
		  <h1>Yhteystyyppi yhden suhde yhteen</h1>

		  <p>Yhteystyyppien yhden suhde moneen ja monen suhde moneen lisäksi on myös yhteystyyppi yhden suhde yhteen. Kahden käsitteen välillä on yhden suhde yhteen (<code>1-1</code>) -yhteys, jos ensimmäisen käsitteen ilmentymään voi liittyä vain yksi toisen käsitteen ilmentymä, ja toisen käsitteen ilmentymään voi liittyä vain yksi ensimmäisen käsitteen ilmentymä.</p>

		  <p>Esimerkiksi yhdellä opiskelijalla voi olla vain yksi laite lainassa ylläpidolta, ja ylläpito voi lainata tietyn laitteen vain yhdelle opiskelijalle.</p>

		  <p>Tämänkin yhteystyypin voi ajatella myös tietokantataulujen välillä. Kahden taulun välillä on yhteys yhden suhde yhteen, jos yhteen ensimmäisen taulun riviin voi liittyä vain yksi toisen taulun rivi, ja yhteen toisen taulun riviin voi liittyä vain yksi ensimmäisen taulun rivi.</p>

		  <p><em>Tietokantataulujen luominen</em></p>

		  <figure>
		    <img src="img/viikko2/yhden-suhde-yhteen-a-b.png" alt="[A]1-1[B]"/> 
		    <figcaption>Yhden suhde yhteen. Yhteen A-käsitteeseen voi liittyä vain yksi B-käsite, ja yhteen B-käsitteeseen voi liittyä vain yksi A-käsite.</figcaption>
		  </figure>


		  <p>Jos käsitteiden välillä on yhden suhde yhteen -yhteys, tyypillisin tapa tietokantataulujen luomiseen on se, että yhdelle käsitteistä määritellään pääavain, ja toiselle viiteavain, jolla viitataan toiseen käsitteeseen.</p>



		  <figure>
		    <img src="img/viikko2/yhden-suhde-yhteen-viitteet.png" alt="[A|(pk) id]1-*[B|(fk) a_id: A]"/> 
		    <figcaption>Yhden suhde yhteen tietokantakaaviona. Käsitteestä B viitataan käsitteeseen A. </figcaption>
		  </figure>

		  <p>Kun pohdimme ylläolevaa tarkemmin, huomaamme, että yllä suoritettiin käytännössä samat askeleet kuin yhden suhde moneen -tapauksessa. Tämä on täysin totta -- käytännössä tietokantaan tulee määritellä viittaavan taulun määrittelyn yhteydessä lisäksi <em>uniikkiusrajoite</em> viiteavaimelle. Palaamme erilaisiin rajoitteisiin myöhemmin kurssilla.</p>

		</aside>


		<h2>Useammassa taulussa olevan tiedon yhdistäminen</h2>


		<p>Hahmottelimme edellisessä luvussa opiskelun ja oppimisen seuraamiseen tarkoitetun järjestelmämme tietokantaa. Päädyimme yhteystyyppien käsittelyssä kahteen tietokantakaavioon, jotka ovat seuraavat:</p>


		<figure>
		  <img src="img/viikko2/opiskelija-kurssisuoritus-kurssi-tietokantakaavio.png" alt="[Opiskelija|(pk) opiskelijanumero;nimi;syntymävuosi;pääaine]1-*[Kurssisuoritus|(fk) opiskelija: Opiskelija;(fk) kurssi: Kurssi;päivämäärä;arvosana;opintopistemäärä]
[Kurssisuoritus]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]"/> 
		</figure>


		<figure>
		  <img src="img/viikko2/monesta-moneen-tehtava-kurssitehtava-kurssi.png" alt="[Tehtävä|(pk) tunnus;nimi;kuvaus]1-*[Kurssitehtävä|(fk) tehtävä: Tehtävä; (fk) kurssi: Kurssi]
[Kurssitehtävä]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]"/> 
		</figure>


		<p>Voimme yhdistää tietokantakaaviot suoraan, sillä kumpikin kaavio sisältää taulun Kurssi. Tietokantakaavio, missä kaikki taulut ovat yhdessä, näyttää seuraavalta:</p>


		<figure>
		  <img src="img/viikko2/tietokantakaavio.png" alt="[Opiskelija|(pk) opiskelijanumero;nimi;syntymävuosi;pääaine]1-*[Kurssisuoritus|(fk) opiskelija: Opiskelija;(fk) kurssi: Kurssi;päivämäärä;arvosana;opintopistemäärä]
[Kurssisuoritus]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]
[Tehtävä|(pk) tunnus;nimi;kuvaus]1-*[Kurssitehtävä|(fk) tehtävä: Tehtävä; (fk) kurssi: Kurssi]
[Kurssitehtävä]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]"/> 

		</figure>

		<p>Voit tutkia uudessa esimerkkitietokannassa olevaa tietoa allaolevan SQL-komentotulkin avulla.</p>

		
		<div ng-controller="weekTwoSqlController">
		  
		    <togglable content="taulut" db="db">
                      <table-info></table-info>
		    </togglable>
		    
		    <query db="db"></query>		    
		</div>



		<p>Tutustuimme aiemmin SQL-kyselyihin, joiden avulla teimme erilaisia kyselyitä yksittäisiin tietokantatauluihin. Tutustutaan seuraavaksi erääseen tapaan useammassa taulussa olevan tiedon yhdistämiseen.</p>

		<p>Aiempaa materiaalia kertaamalla muistamme, että avainsanaa <code>FROM</code> seuraa taulu, josta tietoa haetaan. Voimme määritellä haun kohteeksi useampia tauluja listaamalla ne FROM-avainsanan jälkeen pilkulla eroteltuna seuraavasti <code>SELECT * FROM Opiskelija, Kurssisuoritus</code>. Jos emme kerro miten taulujen rivit yhdistetään, on lopputuloksessa kaikki rivit yhdistettynä kaikkiin riveihin -- esimerkiksi jokainen taulun Opiskelija rivi yhdistettynä jokaiseen taulun Kurssisuoritus riviin.</p>


		<div ng-controller="weekTwoSqlController">
		  <query
		     db="db"
		     query="SELECT * FROM Opiskelija, Kurssisuoritus"
		     editable="false">
		  </query>
		</div>

		<p>Yllä esitetyn kyselyn tuottama lopputulos ei ole tyypillisesti tavoiteltu -- jokaiseen opiskelijaan on kytketty jokainen kurssisuoritus, eli kaikilla on kaikki kurssisuoritukset.</p>

		<p>Taulujen yhdistäminen tapahtuu kyselyä rajaavan <code>WHERE</code>-ehdon avulla siten, että taulun pääavainta verrataan siihen viittaavan taulun viiteavaimeen. Esimerkiksi, jos haluamme vain kurssisuoritukset ja niihin liittyvät opiskelijat, hyödynnämme Opiskelija-taulun avainta opiskelijanumero sekä Kurssisuoritus-taulun viiteavainta opiskelija, joka viittaa Opiskelija-taulun pääavaimeen. Käytännössä tämä tapahtuu ehdolla <code>WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija</code>.</p>
		
		<p>Kokonaisuudessaan lause "Anna kaikki riviyhdistelmät tauluista Opiskelija ja Kurssisuoritus, joissa attribuuttien opiskelijanumero ja opiskelija arvot ovat samat" kirjoitetaan seuraavasti: <code>SELECT * FROM Opiskelija, Kurssisuoritus WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija</code>.</p>
		
		<div ng-controller="weekTwoSqlController">
		  
		  <query
		     db="db"
		     query="SELECT * FROM Opiskelija, Kurssisuoritus WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija"
		     editable="false"
		     done="listOpiskelijatJaKurssisuoritukset">
		  </query>
		  
		  <div ng-show="listOpiskelijatJaKurssisuoritukset">
		    
		    <h4>Tehtävät</h4>
		    
		    <p>Tee nyt kysely, joka tulostaa jokaisen opiskelijan nimen, kurssisuorituksen päivämäärän, ja kurssisuorituksen arvosanan.</p>
		    
		    
		    <togglable content="taulut" db="db">
                      <table-info></table-info>
		    </togglable>
		    
		    <query db="db"></query>
		  </div>
		</div>


		<p><strong><em>Useamman taulun yhdistäminen</em></strong></p>

		<p>Useamman taulun yhdistäminen onnistuu samalla tavalla. Kaikki taulut, jotka haluamme lisätä kyselyyn, tulevat FROM-avainsanan jälkeen. Jos tauluja on useampi, on hyvä varmistaa, että kaikki taulut yhdistetään avainkenttien perusteella, sillä muuten haun vastaus voi olla iso.</p>

		<p>Kun yhdistämme useampia tauluja, päädymme helposti tilanteeseen, missä tuloksessa on myös useampia samannimisiä kenttiä. Esimerkiksi omassa tietokantamäärittelyssämme kenttä nimi löytyy tauluista Tehtävä, Kurssi ja Opiskelija. Voimme määritellä taulun, mihin haettava kenttä liittyy, pisteoperaattorin avulla. Kyselyn <code>SELECT nimi FROM Opiskelija</code> voi siis kirjoittaa myös muodossa <code>SELECT Opiskelija.nimi FROM Opiskelija</code>.</p>

		<p>Voimme toisaalta myös nimetä kentän tulostusmuodon seuraavasti <code>SELECT Opiskelija.nimi AS opiskelija FROM Opiskelija</code>. Edelläoleva kysely hakee Opiskelija-taulusta opiskelijan nimen, mutta tulostaa nimet otsikolla 'opiskelija'. </p>

		<p>Allaoleva kysely listaa jokaiselta opiskelijalta opiskelijan nimen sekä opiskelijan suorittamat kurssit.</p>

		<div ng-controller="weekTwoSqlController">
		  
		  <query
		     db="db"
		     query="SELECT Opiskelija.nimi AS opiskelija, Kurssi.nimi AS kurssi 
    FROM Opiskelija, Kurssisuoritus, Kurssi 
    WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija 
        AND Kurssisuoritus.kurssi = Kurssi.kurssitunnus"
		     editable="false"
		     done="listOpiskelijanSuorittamatKurssit">
		  </query>
		  
		  <div ng-show="listOpiskelijanSuorittamatKurssit">
		    
		    <h4>Tehtävät</h4>
		    
		    <p>Tee nyt kysely, joka tulostaa jokaiseen kurssiin liittyvän tehtävän. Tulostuksen otsikoiden nimien tulee olla 'kurssi' ja 'tehtävä'.</p>
		    
		    
		    <togglable content="taulut" db="db">
                      <table-info></table-info>
		    </togglable>
		    
		    <query db="db"></query>
		  </div>
		</div>


		<aside class="info">

		  <br/>
		  <h1>Taulujen yhdistämisestä</h1>

		  <p>Yksi tapa taulujen yhdistämiseen tarvittujen kyselyjen hahmottamiseen on tietokantakaavion katsominen. Jos tavoitteena olisi esimerkiksi etsiä kaikki tehtävät, mitä Joni-niminen opiskelija on saattanut tehdä, ensimmäinen askel on etsiä polku taulusta <code>Tehtävä</code> tauluun <code>Opiskelija</code>.</p>

		  <p>Aloitamme siis taulusta <code>Tehtävä</code>, ja etsimme polun tauluun <code>Opiskelija</code>. Jotta pääsemme taulusta Tehtävä tauluun Opiskelija, tulee meidän vierailla tauluissa <code>Kurssitehtävä</code>, <code>Kurssi</code> ja <code>Kurssisuoritus</code>, jota seuraa taulu <code>Opiskelija</code>.</p>
		  <p>Kyselyä muodostaessa on hyvä yhdistää taulu kerrallaan toisiinsa.</p>

		  <ol>
		    <li>Yhdistämme ensin taulut Tehtävä ja Kurssitehtävä:
		      <pre class="sh_sql">
SELECT Tehtävä.nimi AS tehtävä 
    FROM Tehtävä, Kurssitehtävä 
    WHERE Tehtävä.tunnus = Kurssitehtava.tehtävä</pre></li>
		    
		    <li>Yhdistämme seuraavaksi edellisiin tauluihin taulun Kurssi:
		      <pre class="sh_sql">
SELECT Tehtävä.nimi AS tehtävä 
    FROM Tehtävä, Kurssitehtävä, Kurssi 
    WHERE Tehtävä.tunnus = Kurssitehtävä.tehtävä
        AND Kurssitehtävä.kurssi = Kurssi.kurssitunnus</pre></li>

		    <li>Seuraavaksi, yhdistämme kurssin kurssisuoritukseen:
		      <pre class="sh_sql">
SELECT Tehtävä.nimi as tehtävä 
    FROM Tehtävä, Kurssitehtävä, Kurssi, Kurssisuoritus
    WHERE Tehtävä.tunnus = Kurssitehtävä.tehtävä
        AND Kurssitehtävä.kurssi = Kurssi.kurssitunnus
        AND Kurssi.kurssitunnus = Kurssisuoritus.kurssi</pre></li>

		    <li>Ja viimeinkin, saamme yhdistettyä polun opiskelijaan:
		      <pre class="sh_sql">
SELECT Tehtävä.nimi AS tehtävä 
    FROM Tehtävä, Kurssitehtävä, Kurssi, Kurssisuoritus, Opiskelija
    WHERE Tehtävä.tunnus = Kurssitehtävä.tehtävä
        AND Kurssitehtävä.kurssi = Kurssi.kurssitunnus
        AND Kurssi.kurssitunnus = Kurssisuoritus.kurssi
        AND Kurssisuoritus.opiskelija = Opiskelija.opiskelijanumero</pre></li>

		    <li>Koska halusimme saada Joniin mahdollisesti liittyvät tehtävät, lisätään haettaviin kenttiin vielä opiskelijan nimi:
		      <pre class="sh_sql">
SELECT Tehtävä.nimi AS tehtävä
    FROM Tehtävä, Kurssitehtävä, Kurssi, Kurssisuoritus, Opiskelija
    WHERE Tehtävä.tunnus = Kurssitehtävä.tehtävä
        AND Kurssitehtävä.kurssi = Kurssi.kurssitunnus
        AND Kurssi.kurssitunnus = Kurssisuoritus.kurssi
        AND Kurssisuoritus.opiskelija = Opiskelija.opiskelijanumero
        AND Opiskelija.nimi = 'Joni'</pre></li>

		  </ol>

		
		</aside>

		<p>Voit kokeilla juuri rakennettua kyselyä alla.</p>

		<div ng-controller="weekTwoSqlController">
		  <query
		     db="db"
		     query="SELECT Tehtävä.nimi AS Tehtävä
    FROM Tehtävä, Kurssitehtävä, Kurssi, Kurssisuoritus, Opiskelija
    WHERE Tehtävä.tunnus = Kurssitehtävä.tehtävä
        AND Kurssitehtävä.kurssi = Kurssi.kurssitunnus
        AND Kurssi.kurssitunnus = Kurssisuoritus.kurssi
        AND Kurssisuoritus.opiskelija = Opiskelija.opiskelijanumero
        AND Opiskelija.nimi = 'Joni'">
		  </query>

		</div>

		<div ng-controller="weekThreeSqlController">

		<header>
		  <h1 id="viikko3">Viikko 3</h1>
		</header>


		<p><strong><em>Opiskelijan tekemät tehtävät</em></strong></p>

		<p>Voimme hakea kurssiin liittyvät tehtävät, kurssiin liittyvät opiskelijat, sekä opiskelijan <em>mahdollisesti</em> tekemät tehtävät, jotka saadaan hakemalla kaikkiin opiskelijan kursseihin liittyvät tehtävät. Emme kuitenkaan saa selville yksittäisen opiskelijen tekemiä tai tekemättä jättämiä tehtäviä. </p>

		<p>Jotta tuleva opintojen seurantaan liittyvä järjestelmämme toimisi mielekkäästi, lisätään tietokantaan mahdollisuus opiskelijan ja tehtyjen tehtävien yhdistämiseen. Voimme yhdistää opiskelijan joko tehtävään tai kurssiin liittyvään tehtävään.</p>

		<p>Jos opiskelija yhdistetään tehtävään, opiskelijan tekemä tehtävä näkyy merkittynä kaikilla tehtävää käyttävillä kursseilla. Tämä ei kuitenkaan ole aina toivottua, sillä tehtäviä käytetään myös kertaamistarkoituksessa. Linkitetään siis opiskelija kurssitehtävään: <em>yksi opiskelija voi suorittaa monta kurssitehtävää, ja yhden kurssitehtävän voi suorittaa monta opiskelijaa</em> -- yhteys on monen suhde moneen -tyyppinen.</p>

		<p>Tiedämme miten toimia. Koska Opiskelija-taulussa on pääavain, avainta ei tarvitse määritellä siihen. Kurssitehtävä-taulussa pääavainta ei ole, joten määritellään sille pääavain -- kutsutaan avainta nimellä <em>tunnus</em>. Luodaan tämän jälkeen liitostaulu, jonka tehtävänä on kytkeä Opiskelija-taulun ja Kurssitehtävä-taulun rivejä, ja sitä kautta pitää kirjaa suorituksista. Kutsutaan liitostaulua nimellä <em>Tehtäväsuoritus</em>, ja määritellään sille viiteavaimet tauluun Opiskelija ja tauluun Kurssitehtävä. Lisätään tämän lisäksi tauluun myös kenttä <em>suoritusaika</em>, johon merkitään tehtävän suoritusaika.</p>

		<p>Taulu Tehtäväsuoritus näyttää seuraavanlaiselta:</p>

		<figure>
		  <img src="img/viikko3/taulu-tehtavasuoritus.png" alt="[Tehtäväsuoritus|(fk) opiskelija: Opiskelija; (fk) tehtävä: Kurssitehtävä; suoritusaika]"/> 
		</figure>

		<p>Yhteen tehtäväsuoritukseen liittyy yksi opiskelija, mutta opiskelijalla voi olla monta tehtäväsuoritusta. Samoin, yhteen tehtäväsuoritukseen liittyy yksi kurssitehtävä, mutta yhteen kurssitehtävään voi liittyä monta tehtäväsuoritusta. Kokonaisuudessaan tietokantakaaviomme on nyt seuraavanlainen:</p>

		<figure>
		  <img src="img/viikko3/tietokantakaavio-tehtavasuorituksella.png" alt="[Opiskelija|(pk) opiskelijanumero;nimi;syntymävuosi;pääaine]1-*[Kurssisuoritus|(fk) opiskelija: Opiskelija;(fk) kurssi: Kurssi;päivämäärä;arvosana;opintopistemäärä]
[Kurssisuoritus]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]
[Tehtävä|(pk) tunnus;nimi;kuvaus]1-*[Kurssitehtävä|(pk) tunnus; (fk) tehtävä: Tehtävä; (fk) kurssi: Kurssi]
[Kurssitehtävä]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]
[Tehtäväsuoritus|(fk) opiskelija: Opiskelija; (fk) tehtävä: Kurssitehtävä; suoritusaika]
[Tehtäväsuoritus]*-1[Opiskelija]
[Tehtäväsuoritus]*-1[Kurssitehtävä]"/> 
		</figure>

		<p>&nbsp;</p>

		<p><strong><em>Opiskelijan tekemien tehtävien hakeminen</em></strong></p>

		<p>Nyt opiskelijan tekemien tehtävien hakeminen on suoraviivaisempaa. Hahmotellaan kysely, joka hakee kaikki opiskelijat, jotka ovat tehneet tietokantojen perusteet -kurssin tehtäviä, sekä näiden opiskelijoiden tekemät tehtävät. Muotoillaan tulostus siten, että tuloksessa on opiskelijan nimi ja opiskelijan tekemän tehtävän nimi.</p>

		<p>Aloitetaan hakemalla Kurssi-taulusta kurssi Tietokantojen perusteet.</p>

<pre class="sh_sql">
SELECT * FROM Kurssi WHERE nimi = 'Tietokantojen perusteet';
</pre>

		<p>Kytketään seuraavaksi kyselyn tulos tauluun Kurssitehtävä, eli haetaan kaikki kurssitehtävät, joissa kurssina on Tietokantojen perusteet.</p>

<pre class="sh_sql">
SELECT * FROM Kurssi, Kurssitehtävä 
    WHERE Kurssi.nimi = 'Tietokantojen perusteet' 
        AND Kurssi.kurssitunnus = Kurssitehtävä.kurssi;
</pre>

		<p>Liitetään kyselyyn tämän jälkeen taulu Tehtävä, jonka kautta saamme tehtävien nimet.</p>

<pre class="sh_sql">
SELECT * FROM Kurssi, Kurssitehtävä, Tehtävä 
    WHERE Kurssi.nimi = 'Tietokantojen perusteet' 
        AND Kurssi.kurssitunnus = Kurssitehtävä.kurssi
        AND Tehtävä.tunnus = Kurssitehtävä.tehtävä;
</pre>

		<p>Tulostetaan välitarkastuksena tehtävien nimet:</p>

<pre class="sh_sql">
SELECT Tehtävä.nimi AS Tehtävä
    FROM Kurssi, Kurssitehtävä, Tehtävä 
    WHERE Kurssi.nimi = 'Tietokantojen perusteet' 
        AND Kurssi.kurssitunnus = Kurssitehtävä.kurssi
        AND Tehtävä.tunnus = Kurssitehtävä.tehtävä;
</pre>


		<p>Kyselyn tulos on seuraava -- tuntuu toimivan.</p>


		<div class="data-table">
		  <table class="table">
		    <thead>
		      <tr>
			<th>Tehtävä</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>Onko tässä rekursio?</td>
		      </tr>
		      <tr>
			<td>Keksi tehtävä</td>
		      </tr>		      
		      <tr>
			<td>Koetus</td>
		      </tr>
		    </tbody>
		  </table>
		</div>



		<p>Lisätään kyselyyn tämän jälkeen taulu Tehtäväsuoritus, jonka kautta pääsemme kohta Opiskelija-tauluun.</p> 


<pre class="sh_sql">
SELECT Tehtävä.nimi AS Tehtävä
    FROM Kurssi, Kurssitehtävä, Tehtävä, Tehtäväsuoritus
    WHERE Kurssi.nimi = 'Tietokantojen perusteet' 
        AND Kurssi.kurssitunnus = Kurssitehtävä.kurssi
        AND Tehtävä.tunnus = Kurssitehtävä.tehtävä
        AND Tehtäväsuoritus.tehtävä = Kurssitehtävä.tunnus;
</pre>

		<p>Lisätään lopulta kyselyyn vielä Opiskelija-taulu, ja haetaan sieltä opiskelijan nimi. Voit kokeilla tuloksena olevaa kyselyä alla.</p>


		<query
		   db="db"
		   editable="false"
		   done="listTikapeTehtavat"
		   query="SELECT Opiskelija.nimi AS Opiskelija, Tehtävä.nimi AS Tehtävä
    FROM Kurssi, Kurssitehtävä, Tehtävä, Tehtäväsuoritus, Opiskelija
    WHERE Kurssi.nimi = 'Tietokantojen perusteet' 
        AND Kurssi.kurssitunnus = Kurssitehtävä.kurssi
        AND Tehtävä.tunnus = Kurssitehtävä.tehtävä
        AND Tehtäväsuoritus.tehtävä = Kurssitehtävä.tunnus
        AND Tehtäväsuoritus.opiskelija = Opiskelija.opiskelijanumero">
		</query>
		  
		<div ng-show="listTikapeTehtavat">
		  
		  <h4>Tehtävät</h4>
		  
		  <p>Tee nyt kysely, joka tulostaa kaikki tehtävät, jotka opiskelija 'Anna' on suorittanut. Tee tulostuksesta sellainen, että yksi sarake sisältää kurssin nimen, ja toinen sarake tehtävän nimen.</p>
		  
		  
		  <togglable content="taulut" db="db">
                    <table-info></table-info>
		  </togglable>
		  
		  <query db="db"></query>
		</div>
		

		<aside class="info">
		  <br/>
		  <h1>Pohdi</h1>
		  
		  <p>Alla on kaksi vaihetta edellisessä esimerkissä rakennetusta kyselystä.</p>
		  
		  <pre class="sh_sql">
SELECT Tehtävä.nimi AS Tehtävä
    FROM Kurssi, Kurssitehtävä, Tehtävä 
    WHERE Kurssi.nimi = 'Tietokantojen perusteet' 
        AND Kurssi.kurssitunnus = Kurssitehtävä.kurssi
        AND Tehtävä.tunnus = Kurssitehtävä.tehtävä;</pre>
	
		  <pre class="sh_sql">
SELECT Opiskelija.nimi AS Opiskelija, Tehtävä.nimi AS Tehtävä
    FROM Kurssi, Kurssitehtävä, Tehtävä, Tehtäväsuoritus, Opiskelija
    WHERE Kurssi.nimi = 'Tietokantojen perusteet' 
        AND Kurssi.kurssitunnus = Kurssitehtävä.kurssi
        AND Tehtävä.tunnus = Kurssitehtävä.tehtävä
        AND Tehtäväsuoritus.tehtävä = Kurssitehtävä.tunnus
        AND Tehtäväsuoritus.opiskelija = Opiskelija.opiskelijanumero;</pre>

		  <p>Ensimmäisen kyselyn tuloksena on kolme riviä, ja se listaa kaikki tehtävät jotka liittyvät kurssiin 'Tietokantojen perusteet'. Miksi kuitenkin toisen kyselyn tuloksena on neljä riviä? Jos kurssiin liittyviä tehtäviä on vain kolme, mistä tuo neljäs rivi tulee, ja miksi?</p> 

		  
		</aside>
		

		<h2>Useammassa taulussa olevan tiedon yhdistäminen JOIN-kyselyillä</h2>
		
		<p>Kyselyssä, missä taulujen rivit yhdistetään WHERE-ehdon ja avainten perusteella, valitaan näytettäväksi vain ne rivit, jotka täyttävät annetun ehdon. Esimerkiksi, voimme hakea kaikki kurssit ja ne tehneet opiskelijat seuraavasti:</p>
		
		<query
		   db="db"
                   editable="false"
		   query="SELECT Kurssi.nimi AS Kurssi, Opiskelija.nimi AS Opiskelija
    FROM Kurssi, Kurssisuoritus, Opiskelija
    WHERE Kurssi.kurssitunnus = Kurssisuoritus.kurssi
        AND Kurssisuoritus.opiskelija = Opiskelija.opiskelijanumero">
		</query>


		<p>Entä jos haluaisimme nähdä myös ne kurssit, joita kukaan ei ole suorittanut? Tämä ei ratkea, ainakaan suoraviivaisesti.</p>

		<p>Vuonna 1992 julkaistu SQL-standardin versio toi mukanaan JOIN-kyselyt, joiden avulla edellä määritelty ongelma ratkeaa -- pienen harjoittelun kautta. Tutustutaan seuraavaksi aiemmin oppimaamme taulujen yhdistämistapaa tukeviin erityyppisiin JOIN-kyselyihin.</p>

		<p><strong><em>INNER JOIN</em></strong></p>
		
		<p>Aiemmin tutuksi tullut kysely <code>SELECT * FROM Opiskelija, Kurssisuoritus WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija</code> valitsee vastaukseen vain ne rivit, joiden kohdalla ehto <em>Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija</em> pätee, eli missä Opiskelija-taulun opiskelijanumero-sarakkeen arvo on sama kuin Kurssisuoritus-taulun opiskelija-sarakkeen arvo.</p>
		
		<p>Edellinen kysely voidaan kirjoittaa myös muodossa <code>SELECT * FROM Opiskelija INNER JOIN Kurssisuoritus ON Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija</code>.</p>

		<query
		   db="db"
                   editable="false"
		   query="SELECT * FROM Opiskelija
    INNER JOIN Kurssisuoritus
        ON Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija">
		</query>

		<p>Jos haluamme kyselyyn useampia tauluja, lisätään ne INNER JOIN -komennon avulla kyselyn jatkoksi. Esimerkiksi kaksi seuraavaa kyselyä ovat toiminnallisuudeltaan samankaltaiset.</p>

		<pre class="sh_sql">
SELECT Kurssi.nimi AS Kurssi, Opiskelija.nimi AS Opiskelija
    FROM Kurssi, Kurssisuoritus, Opiskelija
    WHERE Kurssi.kurssitunnus = Kurssisuoritus.kurssi
        AND Kurssisuoritus.opiskelija = Opiskelija.opiskelijanumero;</pre>

		<query
		   db="db"
                   editable="false"
		   query="SELECT Kurssi.nimi AS Kurssi, Opiskelija.nimi AS Opiskelija
    FROM Kurssi
    INNER JOIN Kurssisuoritus
        ON Kurssi.kurssitunnus = Kurssisuoritus.kurssi
    INNER JOIN Opiskelija
        ON Kurssisuoritus.opiskelija = Opiskelija.opiskelijanumero">
		</query>

		<p>Kyselyn <em>INNER JOIN</em> avulla voimme siis tehdä kutakuinkin saman työn kuin aiemman WHERE-ehdon avulla, eli valita mukaan vain ne rivit, joiden kohdalla ehto pätee.</p>

		<p><strong><em>LEFT JOIN</em></strong></p>
		
		<p>Mikä tekee taulujen liitoksesta JOIN-kyselyn avulla WHERE-ehtoa monipuolisemman, on se, että JOIN-kyselyn avulla voidaan määritellä kyselyehtoa täyttämättömille riveille toiminnallisuutta. Avainsanalla <code>LEFT JOIN</code> voidaan määritellä kyselyn tulos sellaiseksi, että ehdon täyttävien rivien lisäksi vastaukseen sisällytetään kaikki FROM-avainsanaa seuraavan taulun rivit, joille liitosehto ei täyttynyt.</p>

		<p>Allaoleva kysely listaa kurssisuorituksia keränneiden opiskelijoiden lisäksi myös opiskelijat, joilla ei ole kurssisuorituksia. Tällöin kurssisuoritukseen liittyvä vastauksen osa jää tyhjäksi.</p>

		<query
		   db="db"
                   editable="false"
		   query="SELECT * FROM Opiskelija
    LEFT JOIN Kurssisuoritus
        ON Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija">
		</query>

		<p>Niiden kurssien listaus, joilla on kävijöitä, tai joilla ei ole kävijöitä onnistuu myös esimerkiksi seuraavasti.</p>


		<query
		   db="db"
		   editable="false"
		   query="SELECT * FROM Kurssi
    LEFT JOIN Kurssisuoritus
        ON Kurssi.kurssitunnus = Kurssisuoritus.kurssi">
		</query>


		<p><strong><em>Liitostyypit lyhyesti</em></strong></p>

		<p>Kyselyn JOIN-tyypin voi muotoilla usealla eri tavalla:</p>
		
		<ul>
		  <li><code>INNER JOIN</code> -- palauta vain ne rivit, joihin valintaehto kohdistuu.</li>
		  <li><code>LEFT JOIN</code> -- palauta kaikki FROM-komentoa seuraavan taulun rivit, ja liitä niihin LEFT JOIN-komentoa seuraavan taulun rivit niiltä kohdin, kuin se on ON-liitosehdossa määritellyn ehdon mukaan mahdollista</li>
		  <li><code>RIGHT JOIN</code> -- palauta kaikki RIGHT JOIN-komentoa seuraavan taulun rivit, ja liitä niihin FROM-komentoa seuraavan taulun rivit niiltä kohdin, kuin se on ON-liitosehdossa määritellyn ehdon mukaan mahdollista</li>
		  <li><code>FULL JOIN</code> -- palauta kaikki FROM-komentoa seuraavan taulun rivit sekä kaikki RIGHT JOIN-komentoa seuraavan taulun rivit, ja liitä ne toisiinsa niiltä kohdin, kuin se on ON-liitosehdossa määritellyn ehdon mukaan mahdollista</li>
		</ul>

		<p><em>Valitettavasti tällä sivulla käytössä oleva kyselyiden harjoitteluun tarkoitettu apuväline ei tue RIGHT JOIN ja FULL JOIN -tyyppisiä kyselyitä.</em></p>


		<aside class="info">

		  <br/>

		  <h1>Visuaalinen opas JOIN-kyselyihin</h1>

		  <p>C.L. Moffatt on kirjoittanut hyvän yhteenvedon erilaisista JOIN-tyypeistä. Tutustu yhteenvetoon osoitteessa <a href="http://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins" target="_blank">http://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins</a>.</p>

		<figure>
		  <img src="img/viikko3/moffatt-visual_joins.png" alt="pyydä piirtämään seuraavassa miitissä :)"/> 
		  <p>&nbsp;</p>
		  <figcaption>Yhteenveto erilaisista JOIN-kyselyistä ja niiden merkityksistä joukkojen kautta visualisoituna.</figcaption>
		</figure>


		</aside>

		
		<h2>Tietokantarivien lisääminen ja poistaminen</h2>
		
		<p>Kyselyiden lisäksi on tärkeää pystyä sekä lisäämään rivejä tauluihin, että poistamaan rivejä tauluista.</p>

		<p><strong><em>Rivien poistaminen taulusta</em></strong></p> 

		<p>Rivien poistaminen tietokantataulusta tapahtuu komennon <code>DELETE FROM</code> avulla, mitä seuraa taulun nimi, mistä poistetaan tietoa, sekä <code>WHERE</code>-ehto, millä määritellään ehdot, joihin osuvat rivit poistetaan.</p>

		<p>Esimerkiksi, opiskelija nimeltä 'Gandhi' voidaan poistaa seuraavalla komennolla.</p>

<pre class="sh_sql">
DELETE FROM Opiskelija WHERE nimi = 'Gandhi'
</pre>


		<p><strong><em>Rivien lisääminen tauluun</em></strong></p> 

		<p>Rivien lisääminen tietokantatauluun tapahtuu komennon <code>INSERT INTO</code> avulla, mitä seuraa kohdetaulun nimi. Taulun jälkeen määritellään sarakkeet, joihin arvot asetetaan, jota seuraa uudelle riville lisättävät arvot.</p>

		<p>Esimerkiksi, uusi Kurssi nimeltä 'Web-selainohjelmointi', jonka kurssitunnus on 582354 lisätään tauluun seuraavalla komennolla. Lisäyksen </p>

<pre class="sh_sql">
INSERT INTO Kurssi (kurssitunnus, nimi, kuvaus) 
    VALUES (582354, 
            'Web-selainohjelmointi', 
            'Web-sovellusten selainpuolen toiminnallisuuden toteuttamisen perustekniikoita');
</pre>


                <p>Toisaalta, uuden opiskelijan -- Jack Bowerin -- lisääminen tapahtuu seuraavasti:</p>

		<query
		   db="db"
		   query="INSERT INTO Opiskelija (opiskelijanumero, nimi, syntymävuosi, pääaine) 
    VALUES (123456, 'Jack Bower', 1962, 'e-Spinach')">
		</query>

		<p>Uusien rivien lisäämiseen on myös toinen merkintätapa. Jos jokaiseen taulun sarakkeeseen ollaan lisäämässä arvo, ei sarakkeiden nimiä tarvitse erikseen kertoa.</p>

		<query
		   db="db"
		   query="INSERT INTO Opiskelija VALUES (123458, 'Maggie Simpson', 1988, 'Genetiikka')">
		</query>


		<query
		   db="db"
		   editable="false"
		   query="SELECT * FROM Opiskelija">
		</query>



		<aside class="info">
		  <br/>

		  <h1>Rivien poistamisesta ja lisäämisestä</h1>

		  <p>Tietokannan käyttämiseen tarkoitetut rajapinnat -- kuten tällä sivulla käytettävä <a href="https://github.com/kripken/sql.js/" target="_blank">sql.js</a> -- tyypillisesti rajoittavat tietokantaan tehtäviä kyselyitä. Suoran kyselyn tekeminen muodossa <code>DELETE FROM Opiskelija WHERE nimi = 'Gandhi'</code> ei ole aina mahdollista, vaan kysely määritellään parametrin avulla -- esimerkiksi <code>DELETE FROM Opiskelija WHERE nimi = '?'</code>, missä parametri annetaan kyselylle erikseen.</p>
		 
		  <p>Tutustutaan toisenlaiseen tapaan näiden kyselyiden tekemiseen.</p>

		</aside>

		</div>




		<h1>Tietokantakyselyiden tekeminen ohjelmallisesti</h1>
		
		<p>Vaikka edelliset esimerkit tehtiin osana kurssimateriaalia, tehdään tietokantakyselyjä usein ohjelmallisesti tai suoraan tietokannanhallintajärjestelmässä, esimerkiksi konsolin kautta.</p>



		<p>Lähes jokainen ohjelmointikieli tarjoaa jonkinlaisen rajapinnan tietokantakyselyiden tekemiseen. Esimerkiksi Java-kielelle on määritelty yhtenäinen standardi tietokantakyselyiden tekemiseen, minkä avulla lähes sama koodi käy useamman tietokannan käyttöön.</p>


		<h2>Java ja JDBC</h2>

		<p>Java-kielessä on määritelty standardi (JDBC, <a href="https://en.wikipedia.org/wiki/Java_Database_Connectivity" target="_blank">Java Database Connectivity API</a>) tietokantayhteyden luomiseen, tietoa hakevien kyselyjen muodolle, sekä tietoa muokkaavien kyselyjen muodolle. Käytännössä tietokannanhallintajärjestelmän toteuttajan tulee toteuttaa kyseinen rajapinta, ja tarjota sille kirjasto, mitä ohjelmoija voi käyttää projektissaan. Jotta JDBCn avulla voidaan ottaa yhteys tietokantaan, tulee käytössä siis olla tietokantakohtainen JDBC-ajuri, jonka vastuulla on tietokantayhteyden luomiseen liittyvät yksityiskohdat sekä kyselytulosten muuntaminen JDBC-standardin mukaiseen muotoon.</p>

		<p>Oletetaan, että käytössämme on aiemmin näkemämme tietokantataulu Opiskelija:</p>

				
		<div class="data-table">
		  <h4>Opiskelija</h4>
		  <table class="table">
		    <thead>
		      <tr>
			<th>opiskelijanumero</th>
			<th>nimi</th>
			<th>syntymävuosi</th>
			<th>pääaine</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>9999999</td>
			<td>Pihla</td>
			<td>1997</td>
			<td>Tietojenkäsittelytiede</td>
		      </tr>
		      <tr>
 			<td>9999998</td>
			<td>Joni</td>
			<td>1993</td>
			<td>Tietojenkäsittelytiede</td>
		      </tr>
		      <tr>
			<td>...</td>
			<td></td>
			<td></td>
			<td></td>
		      </tr>
		    </tbody>
		  </table>
		</div>

		<p>JDBCn avulla kyselyn tekeminen tietokantatauluun tapahtuu seuraavasti -- olettaen, että käytössämme on sekä tietokanta, että tietokannan ajuri:</p>


<pre class="sh_java">

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

public class Main {
    public static void main(String[] args) throws Exception {
        // ladataan käyttöön SQLite:n JDBC-ajuri
        Class.forName("org.sqlite.JDBC");
        // luodaan yhteys sqlite-tietokantaan nimeltä "tietokanta.db"
        Connection connection = DriverManager.getConnection("jdbc:sqlite:tietokanta.db");

        // luodaan olio, jonka avulla voidaan tehdä kyselyitä tietokantaan
        Statement statement = connection.createStatement();
        // tehdään tietokantaan SQL-kysely "SELECT * FROM Opiskelija", jolla haetaan 
        // kaikki tiedot Opiskelija-taulusta -- tuloksena resultSet-olio
        ResultSet resultSet = statement.executeQuery("SELECT * FROM Opiskelija");
        
        // käydään tuloksena saadussa oliossa olevat rivit läpi -- next-komento hakee
        // aina seuraavan rivin, ja palauttaa true jos rivi löytyi
        while(resultSet.next()) {
            // haetaan nykyiseltä riviltä opiskelijanumero int-muodossa
            Integer opNro = resultSet.getInt("opiskelijanumero");
            // haetaan nykyiseltä riviltä nimi String-muodossa
            String nimi = resultSet.getString("nimi"); 
            // haetaan nykyiseltä riviltä syntymävuosi int-muodossa
            Integer syntVuosi = resultSet.getInt("syntymävuosi");
            // haetaan nykyiseltä riviltä pääaine String-muodossa
            String paaAine = resultSet.getString("pääaine");
            
            // tulostetaan tiedot
            System.out.println(opNro + "\t" + nimi + "\t" + syntVuosi + "\t" + paaAine);
        }
        
        // suljetaan lopulta yhteys tietokantaan
        connection.close();
    }   
}
</pre>

		<p>Ohjelman suoritus tuottaa (esimerkiksi) seuraavanlaisen tulostuksen:</p>

<pre>
999999	Pihla	1997	Tietojenkäsittelytiede
999998	Joni	1993	Tietojenkäsittelytiede
999997	Anna	1991	Matematiikka
999996	Krista	1990	Tietojenkäsittelytiede
...
</pre>

		<aside class="info">
		  <br/>
		  
		  <h1>SQL-injektiot</h1>

		  <p>Suurin osa olemassaolevista sovelluksista liittyy tietoon: tiedon hakemiseen tietokannasta, tiedon muokkaamiseen ja näyttämiseen, ja tiedon tallentamiseen tietokantaan. Jos ulkopuolinen henkilö voi vaikuttaa tietokoneelle annettavien SQL-kyselyiden sisältöön, on myös mahdollista, että hän pääsee vaikuttamaan näytettävään tietoon sekä tietokannassa suoritettuihin kyselyihin.</p>

		  <p>SQL-injektio on tekniikka, millä sovellukselle annetaan komentoja, joita sille ei pitäisi pystyä antamaan. Oletetaan esimerkiksi että seuraava sovellus suorittaa kirjautumisen tarkistamalla onko suoritettavan tietokantakyselyn tulos tyhjä:</p>

<pre class="sh_java">
// ...
String nimi = "nimi";
String salasana = "salasana";

String kysely = "SELECT * FROM User WHERE username = '"
                           + nimi + "' AND password = '" + salasana + "'";
// ...</pre>

		  <p>Vaikka kysely toimii siinä mielessä oikein, että se ei palauta yhtäkään riviä, jos tietokannasta ei löydy annetulla käyttäjätunnuksella ja salasanalla tunnettua henkilöä, on se kuitenkin hieman ongelmallinen. Jos käyttäjä antaa käyttäjänimen <code>' OR '1' = '1' OR '1' = '1</code>, tulee tietokannassa suoritettava kysely olemaan <code>SELECT * FROM User WHERE username = 'nimi' OR '1' = '1' OR '1' = '1' AND password = 'salasana'</code>. Koska '1' on '1', palautuu vastauksessa kaikki rivit.</p>

		  <p>SQL-injektioita voi luonnollisesti tehdä myös muunlaisiin kyselyihin. Web-sarjakuva <a href="http://xkcd.com/" target="_blank">xkcd</a> kuvastaa tätä ilmiötä hyvin <em>Exploits of a Mom</em>-sarjakuvallaan.</p>

		  <figure>
		    <img src="http://imgs.xkcd.com/comics/exploits_of_a_mom.png" alt="School: Hi, this is your son's school. We're having some computer trouble.

Mom: Oh, dear -- Did he break something?

School: In a way. Did you really name your son Robert'); DROP TABLE Students;--?

Mom: Oh. Yes. Little Bobby Tables we call him.

School: Well, we've lost this year's student records. I hope you're happy.

Mom: And I hope you've learned to sanitize your database inputs."/> 
		    <figcaption>http://xkcd.com/327/ -- Exploits of a Mom. </figcaption>
		  </figure>

		</aside>

		<h2>Java-projekti ja JDBC-ajurin noutaminen</h2>

		<p>Jotta Javalla tehtävään projektiin saa tietokannan käyttöön, tulee ohjelmoijan noutaa tietokanta-ajuri. Ajurien noutaminen kannattaa hoitaa ns. riippuvuuksia hallinnoivan projektinhallintatyökalun, kuten Mavenin, avulla.</p>

		<p>Oletamme tässä, että käytössäsi on <a href="http://www.oracle.com/technetwork/articles/javase/jdk-netbeans-jsp-142931.html" target="_blank">NetBeans-ohjelmointiympäristö sekä Java 8</a>  (tietojenkäsittelytieteen laitoksella käytössä oleva TMCBeans käy myös mainiosti).</p>

		<p><strong><em>Maven-projektin luominen NetBeansissa</em></strong></p>
		
		<p>Uuden Mavenia käyttävän projektin luominen NetBeansissa tapahtuu valitsemalla <em>File</em> -> <em>New Project</em> -> Kategoriaksi <em>Maven</em> ja projektiksi <em>Java Application</em>. Tämän jälkeen valitaan <em>Next</em>, ja täytetään projektin tiedot. Alla on esimerkki projektin tiedoista, projektin sijainti (Project location) on konekohtainen.</p>

		  <figure>
		    <img src="img/viikko3/nb-maven.png" alt="Project Name: tikape

Project Location: (omasta koneesta riippuva)

Group Id: tikape

Version: (saa olla kuten on aluksi)

Package: tikape"
/>
		    <figcaption>Maven-projektin asetukset</figcaption>
		  </figure>

		  <p>Tämän jälkeen painetaan Finish, ja projekti ilmestyy NetBeansin vasemmassa laidassa olevalle listalle. Etsi nyt projektin <em>Project Files</em> sisältä <code>pom.xml</code>-tiedosto -- se näyttää esimerkiksi seuraavalta:</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;tikape&lt;/groupId&gt;
    &lt;artifactId&gt;tikape&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
&lt;/project&gt;
</pre>


		<p>Koska käytössämme on Java 8, vaihdetaan sekä <code>maven.compiler.source</code> että <code>maven.compiler.source</code> -arvot muotoon <code>1.8</code>.</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;tikape&lt;/groupId&gt;
    &lt;artifactId&gt;tikape&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;<strong>1.8</strong>&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;<strong>1.8</strong>&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
&lt;/project&gt;
</pre>

		<p><strong><em>SQLite-ajurin lisäämien Maven-projektin riippuvuuksiin</em></strong></p>

		<p>Lisätään <em>riippuvuus</em> (dependency) SQLite-ajuriin osaksi sovellusta.</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;tikape&lt;/groupId&gt;
    &lt;artifactId&gt;tikape&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;<strong>1.8</strong>&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;<strong>1.8</strong>&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.xerial&lt;/groupId&gt;
            &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt;
            &lt;version&gt;3.8.11.1&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</pre>		

		<p>Nyt kun NetBeans-projektista valitsee oikealla hiirennapilla <em>Dependencies</em> ja klikkaa <em>Download Declared Dependencies</em>, latautuu JDBC-ajuri projektin käyttöön.</p>


		<p><strong><em>Ensimmäinen tietokantaa käyttävä Maven-ohjelma</em></strong></p>

		<p>Avaa projektiin liittyvä <em>Source Packages</em>, ja klikkaa <em>tikape</em>-pakkausta oikealle hiirennapilla. Valitse tämän jälkeen <em>New</em> -> <em>Java Class</em>, jonka jälkeen avautuu valikko, missä voit antaa luokalle nimen. Anna luokan nimeksi <code>Main</code>.</p>
		
		<p>Avaa tiedosto tuplaklikkaamalla sitä. Muokkaa tiedostoa vielä siten, että se on seuraavan näköinen:</p>

<pre class="sh_java">
package tikape;

public class Main {

    public static void main(String[] args) throws Exception {
        
    }
}</pre>



		<figure>
		  <img src="img/viikko3/nb-main.png" alt="Projektin lähdekooditiedosto Main.java on avattuna."/>
		  <figcaption>Avattu projekti NetBeansissa</figcaption>
		</figure>


		<p>Lisää projektiin <em>import</em>-komento <code>import java.sql.*;</code>, joka hakee kaikki SQL-kyselyihin liittyvät Javan kirjastot.</p>


<pre class="sh_java">
package tikape;

import java.sql.*;

public class Main {

    public static void main(String[] args) throws Exception {
        
    }
}</pre>


		<p>Avataan seuraavaksi tietokantayhteys tietokantaan <em>testi.db</em>, ja tehdään siellä kysely "SELECT 1", jolla pyydetään tietokantaa palauttamaan luku 1 -- käytämme tätä yhteyden testaamiseksi. Jos yhteyden luominen onnistuu, tulostetaan "Hei tietokantamaailma!", muulloin "Yhteyden muodostaminen epäonnistui".</p>

<pre class="sh_java">
package tikape;

import java.sql.*;

public class Main {

    public static void main(String[] args) throws Exception {
        Class.forName("org.sqlite.JDBC");
        Connection connection = DriverManager.getConnection("jdbc:sqlite:testi.db");
        
        Statement statement = connection.createStatement();

        ResultSet resultSet = statement.executeQuery("SELECT 1");
        
        if(resultSet.next()) {
            System.out.println("Hei tietokantamaailma!");
        } else {
            System.out.println("Yhteyden muodostaminen epäonnistui.");
        }
    }
}</pre>

<pre>
Hei tietokantamaailma!</pre>

		<p>Kun suoritamme ohjelman ensimmäistä kertaa valitsemalla <em>Run</em> -> <em>Run Project</em>, SQLite luo puuttuvan tietokannan paikalle uuden tietokannan. Projektin kansiossa on nyt tiedosto <code>testi.db</code>, joka on tietokantamme.</p>


		<figure>
		  <img src="img/viikko3/nb-testidb.png" alt="Kun ohjelma on suoritettu ensimmäistä kertaa, tiedosto testi.db luodaan projektiin."/>
		  <figcaption>Tietokantatiedosto <em>testi.db</em> löytyy projektin kansiosta. Tiedostot löytyvät <em>Files</em>-välilehdeltä.</figcaption>
		</figure>
		

		<p><strong><em>Tietokantakyselyiden tekeminen</em></strong></p>
	
		<p>Osoitteessa <a href="dbs/vuokraamo.db">vuokraamo.db</a> löytyy kuvitteellisen moottoripyörävuokraamon tietokanta. Lataa se edellä tehdyn projektin juureen ja kokeile kyselyn tekemistä kyseiseen tietokantaan.</p>

		<p>Tietokannassa on tietokantataulu <code>Pyora</code>, jolla on sarakkeet <code>rekisterinumero</code> ja <code>merkki</code>. Jokaisen pyörän rekisterinumeron ja merkin tulostaminen tapahtuu seuraavasti -- huomaa myös, että olemme vaihtaneet käytössä olevaa tietokantaa.<p>

<pre class="sh_java">
Class.forName("org.sqlite.JDBC");
Connection connection = DriverManager.getConnection("jdbc:sqlite:vuokraamo.db");

Statement stmt = connection.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM Pyora;");

while (rs.next()) {
    String rekisterinumero = rs.getString("rekisterinumero");
    String merkki = rs.getString("merkki");

    System.out.println(rekisterinumero + " " + merkki);
}

stmt.close();
rs.close();

connection.close();</pre>

		<p>Käydään ylläoleva ohjelmakoodi läpi askeleittain.</p>
		
		<ol>
		  <li><p>Haemme ensin käyttöömme tietokanta-ajurin komennolla <code>Class.forName("org.sqlite.JDBC");</code>, jonka jälkeen otamme SQLiten avulla JDBC-yhteyden tietokantaan <em>vuokraamo.db</em>.
<pre class="sh_java">
Class.forName("org.sqlite.JDBC");
Connection connection = DriverManager.getConnection("jdbc:sqlite:vuokraamo.db");</pre>
</p>
		  </li>

		  <li><p>Kyselyn tekeminen tapahtuu pyytämällä yhteydeltä <em>Statement</em>-oliota, jota käytetään kyselyn tekemiseen ja tulosten pyytämiseen. Metodi <em>executeQuery</em> suorittaa parametrina annettavan SQL-kyselyn, ja palauttaa tulokset sisältävän <em>ResultSet</em>-olion.

<pre class="sh_java">
Statement statement = connection.createStatement();
ResultSet resultSet = statement.executeQuery("SELECT * FROM Pyora;");</pre>
</p></li>
		    <li><p>Tämän jälkeen ResultSet-oliossa olevat tulokset käydään läpi. Metodia next() kutsumalla siirrytään kyselyn palauttamissa tulosriveissä eteenpäin. Kultakin riviltä voi kysyä sarakeotsikon perusteella solun arvoa. Esimerkiksi kutsu getString("rekisterinumero") palauttaa kyseisellä rivillä olevan sarakkeen "rekisterinumero" arvon String-tyyppisenä.

<pre class="sh_java">
while(resultSet.next()) {
    String rekisterinumero = rs.getString("rekisterinumero");
    String merkki = rs.getString("merkki");

    System.out.println(rekisterinumero + " " + merkki);
}</pre>
</p></li>
		    <li><p>Kun kyselyn vastauksena saadut rivit on käyty läpi, eikä niitä enää tarvita, vapautetaan niihin liittyvät resurssit.

<pre class="sh_java">
stmt.close();
rs.close();
</pre></p></li>


		    <li><p>Lopulta tietokantayhteys suljetaan.

<pre class="sh_java">
connection.close();</pre>
</p></li>
		</ol>


		<p><strong><em>Päivityskyselyiden tekeminen</em></strong></p>

		<p>Kyselyt kuten rivien lisääminen ja poistaminen onnistuu myös ohjelmallisesti. Tällöin tuloksessa ei kuitenkaan ole erillistä ResultSet-oliota, vaan luku, joka kertoo kyselyn muuttaneiden rivien määrän. Allaoleva ohjelmakoodi lisää tietokantaan uuden pyörän.</p>

<pre class="sh_java">
Class.forName("org.sqlite.JDBC");
Connection connection = DriverManager.getConnection("jdbc:sqlite:vuokraamo.db");

Statement stmt = connection.createStatement();
int changes = stmt.executeUpdate("INSERT INTO Pyora (rekisterinumero, merkki) VALUES ('RIP-34', 'Jopo');");

System.out.println("Kyselyn vaikuttamia rivejä: " + changes);
stmt.close();

connection.close();</pre>



		<h2>Vastuiden eriyttäminen ja debug-viestien tulostaminen</h2>

		<p>Käytännössä tietokantaa käytettäessä on hyvä eriyttää osa tietokantalogiikasta ja sovelluslogiikasta toisistaan. Esimerkiksi tietokanta-ajurin hakeminen ja yhteyden luominen sopii hyvin erillisen tietokantaluokan vastuulle, ja sovelluskehittäjän työtä helpottaa, jos ohjelma mahdollistaa viestien tulostuksen. Samalla myös tietokannassa olevia käsitteitä on kätevä esittää luokkien avulla.</p>

		<p><strong><em>Luodaan käsitteelle luokka</em></strong></p>

		<p>Hahmotellaan ensin luokka käsitteelle <code>Pyora</code>, jolla on rekisterinumero ja merkki.</p>

<pre class="sh_java">
package tikape;

public class Pyora {

    private String rekisterinumero;
    private String merkki;

    public Pyora(String rekisterinumero, String merkki) {
        this.rekisterinumero = rekisterinumero;
        this.merkki = merkki;
    }

    public String getRekisterinumero() {
        return rekisterinumero;
    }

    public void setRekisterinumero(String rekisterinumero) {
        this.rekisterinumero = rekisterinumero;
    }

    public String getMerkki() {
        return merkki;
    }

    public void setMerkki(String merkki) {
        this.merkki = merkki;
    }
}</pre>

		<p>Luokasta <em>Pyora</em> voi tehdä uusia ilmentymiä konstruktorin avulla, joka saa ensimmäiseksi parametrikseen rekisterinumeron, ja toiseksi parametriksi merkin.</p>

		<p><strong><em>Luodaan mahdollisuus olioiden luomiselle ResultSetissä olevista riveistä</em></strong></p>

		<p>Luodaan rajapinta <em>Collector</em>, jonka tehtävänä on muuttaa tulosrivi olioksi. Teemme rajapinnasta geneerisen, eli sille voi määritellä rajapinnan luovan tyypin rajapinnan toteuttavan olion luonnin yhteydessä.</p>

<pre class="sh_java">
package tikape;

import java.sql.*;

public interface Collector&lt;T&gt; {

    T collect(ResultSet rs) throws SQLException;

}</pre>

		<p>Esimerkiksi pyörien luominen kyselyrivistä onnistuisi nyt seuraavanlaisen <em>Collector</em>-rajapinnan toteuttavan olion avulla.</p>

<pre class="sh_java">
package tikape;

import java.sql.*;

public class Pyorakeraaja implements Collector&lt;Pyora&gt; {

    @Override
    public Pyora collect(ResultSet rs) throws SQLException {
        String reknro = rs.getString("rekisterinumero");
        String merkki = rs.getString("merkki");

        return new Pyora(reknro, merkki);
    }
}</pre>




		<p><strong><em>Tietokantaluokan luominen</em></strong></p>

		<p>Luodaan seuraavaksi konkreettinen tietokantaluokka, joka ottaa yhteyden tietokantaan, sekä käyttää aiemmin luomaamme Collector-rajapintaa kyselyn tulosten hakemiseksi.</p>

<pre class="sh_java">
package tikape;

import java.sql.*;
import java.util.*;

public class Database {

    private boolean debug;
    private Connection connection;

    public Database(String driver, String address) throws Exception {
        Class.forName(driver);
        this.connection = DriverManager.getConnection(address);
    }

    public void setDebugMode(boolean d) {
        debug = d;
    }

    public &lt;T&gt; List&lt;T&gt; queryAndCollect(String query, Collector&lt;T&gt; col) throws SQLException {
        List&lt;T&gt; rows = new ArrayList&lt;&gt;();
        Statement stmt = connection.createStatement();
        ResultSet rs = stmt.executeQuery(query);
        
        while (rs.next()) {
            if (debug) {
                System.out.println("---");
                System.out.println(query);
                debug(rs);
                System.out.println("---");
            }
            
            rows.add(col.collect(rs));
        }
        
        rs.close();
        stmt.close();
        return rows;
    }

    private void debug(ResultSet rs) throws SQLException {
        int columns = rs.getMetaData().getColumnCount();
        for (int i = 0; i &lt; columns; i++) {
            System.out.print(
                    rs.getObject(i + 1) + ":"
                    + rs.getMetaData().getColumnName(i + 1) + "  ");
        }

        System.out.println();
    }
}</pre>

		<p>Tietokannan konkreettinen käyttö tapahtuu seuraavasti:</p>

<pre class="sh_java">
Database database = new Database("org.sqlite.JDBC", "jdbc:sqlite:vuokraamo.db");
List&lt;Pyora&gt; pyorat = database.queryAndCollect("SELECT * FROM Pyora", new Pyorakeraaja());

for (Pyora pyora : pyorat) {
    System.out.println(pyora.getMerkki());
}</pre>


		<p>Tärkeää on myös debug-viestien hyödyntäminen ongelmatapauksissa sekä sovellusta kehitettäessä. Debug-viestit saa tietokantaan päälle metodilla <code>database.setDebugMode(true);</code>.</p>
<pre class="sh_java">
Database database = new Database("org.sqlite.JDBC", "jdbc:sqlite:vuokraamo.db");
database.setDebugMode(true);

List&lt;Pyora&gt; pyorat = database.queryAndCollect("SELECT * FROM Pyora", new Pyorakeraaja());

for (Pyora pyora : pyorat) {
    System.out.println(pyora.getMerkki());
}</pre>

		<p><strong><em>Päivityskyselyiden lisääminen</em></strong></p>

		<p>Edellä luotu tietokantaluokkamme ei vielä kuitenkaan osaa thedä päivityskyselyitä. Lisätään mahdollisuus päivityskyselyiden tekemiseen.</p>

<pre class="sh_java">
package tikape;

import java.sql.*;
import java.util.*;

public class Database {

// ...

    public int update(String updateQuery) throws SQLException {
        Statement stmt = connection.createStatement();
        int changes = stmt.executeUpdate(updateQuery);

        if(debug) {
            System.out.println("---");
            System.out.println(updateQuery);
            System.out.println("Changed rows: " + changes);
            System.out.println("---");
        }
        stmt.close();

        return changes;
    }

// ... 
}</pre>


		<p>Nyt myös päivityskyselyt onnistuvat.</p>

<pre class="sh_java">
Database database = new Database("org.sqlite.JDBC", "jdbc:sqlite:vuokraamo.db");
database.setDebugMode(true);

database.update("INSERT INTO Pyora (rekisterinumero, merkki) VALUES ('AKU-313', 'Belchfire Runabout')");

List&lt;Pyora&gt; pyorat = database.queryAndCollect("SELECT * FROM Pyora", new Pyorakeraaja());

for (Pyora pyora : pyorat) {
    System.out.println(pyora.getMerkki());
}</pre>



                <aside class="info">
		  <br/>
		  <h1>Esimerkkiprojekti Githubissa</h1>

		  <p>Juuri rakennettu esimerkkiprojekti löytyy Githubista osoitteessa <a href="https://github.com/tietokantojen-perusteet/Vuokraamo" target="_blank">https://github.com/tietokantojen-perusteet/Vuokraamo</a></p>

		</aside>


		<h2>Prepared Statement -kyselyt</h2>

		<p>Prepared Statement-kyselyt ovat valmiiksi määriteltyjä kyselyitä, joissa kyselyissä käytettävät arvot annetaan parametreina. Valmiita kyselyitä käyttämällä estetään merkittävä osa SQL-injektioista, sillä parametreja käytettäessä varmistetaan että parametrien arvot käsitellään tiettyyn kenttään liittyvänä datana -- parametrit eivät siis "vuoda yli".</p>

		<p>Valmiit kyselyt määritellään Connection-olion prepareStatement-metodin avulla. Metodi palauttaa PreparedStatement-olion, johon kyselyn käyttämät arvot määritellään parametreina. Esimerkiksi SQL-injektioesimerkissä oleva kysely luodaan valmiiden kyselyiden avulla seuraavasti:</p>

<pre class="sh_java">
// ...
String name = "nimi";
String password = "kala";

PreparedStatement statement = 
    connection.prepareStatement("SELECT * FROM User WHERE username = ? AND password = ?");

statement.setString(1, name);
statement.setString(2, password);

ResultSet resultSet = statement.executeQuery();
// ...</pre>

		<p>Vastaavasti tietokantaa muokkaavan kyselyn voi tehdä seuraavasti (alla oletetaan että taulussa User on vain kaksi saraketta):</p>


<pre class="sh_java">
// ...
String name = "nimi";
String password = "kala";

PreparedStatement statement = 
    connection.prepareStatement("INSERT INTO User VALUES (?, ?)");

statement.setString(1, name);
statement.setString(2, password);

statement.execute();
// ...</pre>


                <aside class="info">
		  <br/>
		  <h1>Prepared Statement ja indeksien numerointi</h1>

		  <p>Tietojenkäsittelytieteilijöille epätyypillisesti kyselyissä käytettävien parametrien indeksointi alkaa numerosta 1.</p>
		  
		</aside>

		<p>Prepared Statement-kyselyiden käyttäminen edellisessä luvussa toteutetun tietokanta-abstraktion kautta on myös mahdollista. Toteutetaan tällöin päivitys- ja kyselymetodit sellaisina, että niille annetaan kysely merkkijonona sekä ennalta määrittelemätön määrä parametreja, jotka lisätään kyselyyn kyselyä muodostettaessa.</p>

<pre class="sh_java">
    public int update(String updateQuery, Object... params) throws SQLException {
        PreparedStatement stmt = connection.prepareStatement(updateQuery);

        for (int i = 0; i &lt; params.length; i++) {
            stmt.setObject(i + 1, params[i]);
        }

        int changes = stmt.executeUpdate();

        if (debug) {
            System.out.println("---");
            System.out.println(updateQuery);
            System.out.println("Changed rows: " + changes);
            System.out.println("---");
        }
        stmt.close();

        return changes;
    }</pre>

		<p>Vastaavasti myös olioita kyselystä muodostava olio voidaan toteuttaa PreparedStatement-kyselyn kautta.</p>

<pre class="sh_java">
    public &lt;T&gt; List&lt;T&gt; queryAndCollect(String query, Collector&lt;T&gt; col, Object... params) throws SQLException {
        if (debug) {
            System.out.println("---");
            System.out.println("Executing: " + query);
            System.out.println("---");
        }

        List&lt;T&gt; rows = new ArrayList&lt;&gt;();
        PreparedStatement stmt = connection.prepareStatement(query);
        for (int i = 0; i &lt; params.length; i++) {
            stmt.setObject(i + 1, params[i]);
        }

        ResultSet rs = stmt.executeQuery();

        while (rs.next()) {
            if (debug) {
                System.out.println("---");
                System.out.println(query);
                debug(rs);
                System.out.println("---");
            }

            rows.add(col.collect(rs));
        }

        rs.close();
        stmt.close();
        return rows;
    }</pre>


                <aside class="info">
		  <br/>
		  <h1>Viiteavainten käsittely ja koosteoliot</h1>

		  <p>Edellä näkemämme esimerkki, missä tietokannasta haettu rivi muutetaan olioiksi on näppärää tilanteissa, missä yksittäinen tulosrivi voidaan käsitellä yhtenä oliona. Kohtaamme kuitenkin usein tilanteen, missä tietokantataulussa on viite toiseen tauluun. Miten tällainen tilanne kannattaisi käsitellä?</p>

		  <p>Palaamme tähän myöhemmin kurssilla.</p>

		</aside>

		<h1>Käsiteanalyysi</h1>


		<p>Käsiteanalyysia (conceptual modeling) käytetään tutkittavaan aihepiiriin tai ongelma-alueeseen liittyvien käsitteiden sekä niiden välisten yhteyksien selvittämiseen. Käsite voidaan määritellä löyhästi jonkinlaisena asiana, jonka nykyinen olemassaolo ei vaadi jonkun muun asian olemassaoloa -- jos asia on olemassaoloriippuvainen, se on mahdollisesti hyvä attribuuttiehdokas. Esimerkiksi <em>Henkilön nimi</em> ei ole tässä mielessä käsite, sillä henkilön nimi on riippuvainen henkilön olemassaolosta. Toisaalta, Henkilö taas on käsite, sillä sen olemassaolo ei vaadi jonkun muun asian olemassaoloa. Käsitteet voidaan tyypillisesti myös erottaa toisistaan jollain tavalla, tai niille tulee olla vähintäänkin mahdollista määritellä jonkunlainen yksilöivä tunnus.</p>

		<p>Käsitteiden välisillä yhteyksillä taas tarkoitetaan esimerkiksi käsitteiden välisiä suhteita, esimerkiksi Henkilöllä voi olla sisaruksia sekä vanhemmat, ja henkilö voi vaikkapa opiskella jossain opinahjossa.</p>

		<p>Seuraamme tällä kurssilla kurssin <em>Ohjelmistotekniikan menetelmät</em> <a href="http://www.cs.helsinki.fi/u/mluukkai/otm2012/otm.pdf" target="_blank">luentomonisteessa</a> esitettyä menetelmää käsiteanalyysiin. Siinä missä kurssilla ohjelmistotekniikan menetelmät puhutaan luokkaehdokkaista, puhumme tällä kurssilla käsitteistä. Kurssi ohjelmistotekniikan menetelmät linjaa seuraavat askeleet käsitteiden eriyttämiseen:</p>

		<ol>
		  <li><em>Kartoita käsite-ehdokkaita</em>

		    <p>Laadi luettelo tarkasteltavan ilmiön kannalta keskeisistä kohteista tai ilmiöistä, jotka voisivat tulla kyseeseen käsitteinä. Tällaisia voisivat olla toimintaan osallistujat, toiminnan kohteet, toimintaan liittyvät tapahtumat, materiaalit, tuotteet ja välituotteet, toiminnalle edellytyksiä luovat asiat.</p>

		    <p>Kartoituksen pohjana voi käyttää vapaamuotoista tekstikuvausta tarkasteltavasta ilmiöstä, jota kutsutaan jatkossa kohdealueeksi (engl. problem domain). Tästä kuvauksesta alleviivataan käsite-ehdokkaita ja kerätään ne luetteloon. Käsite-ehdokkaat esiintyvät kuvauksessa usein substantiiveina. Alustavaa karsintaa voi tehdä sen perusteella, onko asia lainkaan oleellinen mallinnettavan ilmiön kannalta.</p>

		  </li>

		  <li><em>Karsi ehdokkaita</em>

		    <p>Luetteloon saadut ehdokkaat käydään läpi ja arvioidaan voisiko ehdokas tulla kyseeseen käsitteenä. Arvioinnissa tulisi tarkastella:</p>
		      
		      <ul>
			<li>Liittyykö ilmiöön tietosisältöä, joka on välttämätöntä järjestelmän kannalta.</li>
			<li>Onko asia riittävän tärkeä kohdealueen kannalta.</li>
		      </ul>

		      <p>Karsintaa ja ehdokkaiden kartoitusta joudutaan usein tekemään iteratiivisesti. Ensimmäinen karsintakierros ei välttämättä tuota lopullista tulosta.</p>

		  </li>

		  <li><em>Tunnista käsitteiden väliset yhteydet</em>

		    <p>Yhteyksiä voi etsiä vapaamuotoisesta kuvauksesta. Yhteyttä ilmaisevat usein verbit, genetiivit, muut kytkentää kuvaavat ilmaukset. Yhteyksienkin suhteen tulisi miettiä onko yhteys oleellinen tarkasteltavan ilmiön kannalta sekä onko se rakenteellinen eli jollain lailla pysyvä ilmiöiden välinen suhde. Yhteyksiksi otetaan ainoastaan merkitykselliset, pysyvämpiluonteiset suhteet ilmiöiden välillä.</p>

		  </li>

		  <li><em>Määrittele yhteyksiin liittyvät osallistumisrajoitteet</em>

		    <p>Osallistumisrajoitteiden avulla ilmaistaan rakenteellisia sääntöjä. Ne eivät välttämättä tule esiin vapaamuotoisessa kuvauksessa vaan edellyttävät tarkempaa kohdealueen analysointia.</p>

		  </li>


		  <li><em>Täsmennä käsitteitä määrittelemällä attribuutit</em>
		    
		    <p>Attribuutteja saattaa löytyä vapaamuotoisesta kuvauksesta, mutta yleensä niiden löytäminen edellyttää lisäselvityksiä kohdealueesta, esimerkiksi toiminnan osapuolten haastatteluja. Attribuuttien kohdalla tulee myös selvittää mihin niitä tarvitaan.</p>

		  </li>

		</ol>


		<p>Sovelletaan edellisiä askeleita jo nyt tuttuun Uimari-esimerkkiin:</p>
		
		<aside class="info">
		  <br/>
		  
		  <p>Uimaseuramme Loch Nessin hirviöt on tähän päivään asti käyttänyt paperia uimareidensa tulosten seuraamiseen ja ylläpitoon. Uimaseuraamme juuri liittynyt valmennuspäällikkö vaatii kirjanpidon nykyaikaistamista, ja haluaa että tulokset tallennetaan tietokoneelle.</p>
		  
		  <p>Valmennuspäällikkömme antoi minulle tehtäväksi välittää tietoa seurastamme, eli tässäpä sitä: Meillä on noin sata mies- ja naispuolista uimaria. Uimarit kilpailevat yleensä yhdessä lajissa, esimerkiksi selkäuinnissa, mutta jotkut uimarit kilpailevat useammassakin lajissa. Tuloksia kirjataan sekä kuukausittain järjestettävistä seuran sisäisistä "kuukauden vesihiisi"-kisoista, että jokaisesta seuran ulkopuolella järjestettävästä kilpailusta. Valmentajien tulee pystyä käyttämään tietokoneelle tallennettuja tietoja myös kotoa esimerkiksi internetin välityksellä.</p>
		  
		  <p>Mitä mieltä olette edeltävästä järjestelmätarpeesta, olisiko sellainen mahdollista toteuttaa? Pahoittelut kirjoitusvirheistä!</p>
		  
		</aside>


		<h2>Käsite-ehdokkaiden kartoitus</h2>

		<p>Eristetään tekstistä keskeiset kohteet, ilmiöt ja käsitteet alleviivaamalla ne tekstistä. Aloitetaan valitsemalla lähes kaikki substantiivit tarkasteltavaksi.</p>

		<aside class="info">
		  <br/>
		  
		  <p><u>Uimaseuramme</u> Loch Nessin hirviöt on tähän päivään asti käyttänyt <u>paperia</u> <u>uimareidensa</u> <u>tulosten</u> seuraamiseen ja ylläpitoon. <u>Uimaseuraamme</u> juuri liittynyt <u>valmennuspäällikkö</u> vaatii <u>kirjanpidon</u> nykyaikaistamista, ja haluaa että <u>tulokset</u> tallennetaan <u>tietokoneelle</u>.</p>
		  
		  <p><u>Valmennuspäällikkömme</u> antoi minulle tehtäväksi välittää tietoa <u>seurastamme</u>, eli tässäpä sitä: Meillä on noin sata <u>mies- ja naispuolista</u> <u>uimaria</u>. <u>Uimarit</u> kilpailevat yleensä yhdessä <u>lajissa</u>, esimerkiksi <u>selkäuinnissa</u>, mutta jotkut uimarit kilpailevat useammassakin <u>lajissa</u>. Tuloksia kirjataan sekä kuukausittain järjestettävistä seuran sisäisistä "kuukauden vesihiisi"-<u>kisoista</u>, että jokaisesta seuran ulkopuolella järjestettävästä <u>kilpailusta</u>. Valmentajien tulee pystyä käyttämään tietokoneelle tallennettuja tietoja myös kotoa esimerkiksi internetin välityksellä.</p>
		  
		</aside>

		<p>Listataan seuraavaksi alleviivatut termit, ja muunnetaan ne samalla yksikkömuotoon.</p>

		<ul>
		  <li>Uimaseura</li>
		  <li>Paperi</li>
		  <li>Uimari</li>
		  <li>Tulos</li>
		  <li>Valmennuspäällikkö</li>
		  <li>Kirjanpito</li>
		  <li>Tietokone</li>
		  <li>Seura</li>
		  <li>Miesuimari</li>
		  <li>Naisuimari</li>
		  <li>Selkäuinti</li>
		  <li>Laji</li>
		  <li>Kilpailu</li>
		</ul>
				
		  
		<h2>Ehdokkaiden karsinta</h2>

		<p>Karsitaan seuraavaksi ehdokkaita.</p>


		<ul>
		  <li><s>Uimaseura</s> -- seuralle tehdään järjestelmää, voidaan jättää pois ainakin toistaiseksi.</li>
		  <li><s>Paperi</s> -- tästä haluttiin päästä eroon, tulokset kirjattiin aiemmin paperille.</li>
		  <li>Uimari</li>
		  <li>Tulos</li>
		  <li><s>Valmennuspäällikkö</s> -- valmennuspäällikkö haluaa uuden järjestelmän, mutta ei oleellinen käsite tietomallin kannalta.</li>
		  <li><s>Kirjanpito</s> -- järjestelmä tulee sisältämään kirjanpidon, mutta kirjanpito ei käsite järjestelmässä.</li>
		  <li><s>Tietokone</s> -- kts. edellinen</li>
		  <li><s>Seura</s> -- kts. uimaseura.</li>
		  <li><s>Miesuimari</s> -- Uimari on valittuna käsitteeksi, sukupuoli voi esim. olla uimarin attribuuttina.</li>
		  <li><s>Naisuimari</s> -- kts. edellinen</li>
		  <li><s>Selkäuinti</s> -- Laji on valittuna käsitteeksi.</li>
		  <li>Laji</li>
		  <li>Kilpailu</li>
		</ul>

		<p>Ehdokkaiden karsinnan jälkeen seuraavat käsitteet ovat jäljellä:</p>

		<ul>
		  <li>Kilpailu</li>
		  <li>Laji</li>
		  <li>Uimari</li>
		  <li>Tulos</li>
		</ul>

		<h2>Käsitteiden välisten yhteyksien tunnistaminen</h2>

		<p>Yhteydet tunnistetaan joko tekstistä tai "rivien välistä" aiempaa tietoa käyttämällä. Esimerkiksi lause "Uimarit kilpailevat yleensä yhdessä lajissa.." vihjaavat että (1) uimarit liittyvät lajiin, (2) uimarit liittyvät kilpailuun, ja (3) lajit liittyvät kilpailuun.</p>

		<p>Tämän lisäksi, tulokset liittynevät myös uimariin, kilpailuun ja lajiin. Hahmotellaan käsitekaaviota olemassaolevien käsitteiden perusteella.</p>

		<figure>
		  <img src="img/viikko3/uimari-kasitteet.png" alt="[Uimari]-[Laji]
[Laji]-[Kilpailu]
[Kilpailu]-[Uimari]
[Tulos]-[Uimari]
[Tulos]-[Laji]
[Tulos]-[Kilpailu]"/> 
		  <p>&nbsp;</p>
		  <figcaption>Kun käsitteet on tunnistettu, hahmotellaan niiden välisiä yhteyksiä. Yllä pohdittu erästä mahdollisuutta ongelma-alueen käsitteiden yhteyksiksi.</figcaption>
		</figure>


		<h2>Yhteyksiin liittyvien osallistumisrajoitteiden määrittely</h2>

		<p>Kun yhteydet on määritelty, määritellään niille seuraavaksi osallistumisrajoitteet. Osallistumisrajoitteilla tarkoitetaan "viivojen päissä" olevia rajoitteita, joilla kerrotaan esimerkiksi tieto, että yhteen tietyn käsitteen ilmentymään liittyy korkeintaan yksi toinen tietyn käsitteen ilmentymä.</p>

		<p>Uimari voi osallistua yhteen tai useampaan lajiin, eli uimariin voi liittyä monta lajia. Toisaalta, yhtä lajia voi harrastaa useampi uuimari. Kilpailussa voi olla monta lajia, ja lajia voidaan todennäköisesti uida monessa kilpailussa. Kilpailussa voi olla monta uimaria, ja uimari voi uida useammassa kilpailussa. Yksittäiseen tulokseen taas liittyy yksi uimari, yksi laji, ja yksi kilpailu -- mutta, yhteen uimariin voi liittyä monta tulosta, yhteen lajiin voi liittyä monta tulosta, ja yhteen kilpailuun voi liittyä monta tulosta.</p>

		<p>Ehdotus käsitekaavioksi osallistumisrajoitteiden kanssa on seuraavanlainen:</p>

		<figure>
		  <img src="img/viikko3/uimari-kasitteet-rajoitteilla.png" alt="[Uimari]*-*[Laji]
[Laji]*-*[Kilpailu]
[Kilpailu]*-*[Uimari]
[Tulos]*-1[Uimari]
[Tulos]*-1[Laji]
[Tulos]*-1[Kilpailu]"/> 
		  <p>&nbsp;</p>
		  <figcaption>Kun käsitteiden väliset yhteydet on tunnistettu, lisätään yhteyksiin osallistumisrajoitteet. Yllä pohdittu erästä mahdollisuutta osallistumisrajoitteiksi.</figcaption>
		</figure>


		<h2>Attribuuttien määrittely käsitteisiin</h2>

		<p>Käsitteisiin liittyvien attribuuttien määrittely tapahtuu sekä haastatteluiden että ongelma-alueen analyysin kautta. Ongelma-alueen tekstimuotoisesta kuvauksesta tiedämme esimerkiksi, että kilpailuilla on paikka ("paikalliset kilpailut", "seuran ulkopuoliset kilpailut"), mutta toisaalta tekstimuotoinen kuvaus ei esimerkiksi kerro kilpailujen järjestämisajankohdasta. Tieto kilpailun ajankohdasta -- ja sitä kautta tulosten ajankohdasta -- on oleellinen uimareiden kehittymisen seurantaan.</p>



		<header>
		  <h1 id="viikko4">Viikko 4</h1>
		</header>

		<h1>Ali- ja yhteenvetokyselyt sekä tilastojen luominen</h1>


		<p>Osaamme hakea yhdestä tai useammasta tietokantataulusta tietoa, sekä rajata kyselyiden palauttamia tuloksia erilaisilla ehdoilla. On kuitenkin kysymyksiä, joihin vastaaminen nykyisillä työvälineillämme on melko hankalaa. Miten esimerkiksi ratkaisisit seuraavat ongelmat?</p>

		<ul>
		  <li>Mitkä tehtävät ovat sellaisia, joita kursseilla heikommin menestyneet opiskelijat -- esimerkiksi hylätyn arvosanan tai ykkösen saaneet -- eivät ole saaneet tehtyä?</li>
		  <li>Miten haen opiskelijat, jotka eivät ole vielä osallistuneet yhdellekään kurssille?</li>
		  <li>Kuinka monta opiskelijaa pääsi tietyn kurssin läpi?</li>
		  <li>Mikä on jokaisen kurssin keskiarvo?</li>
		</ul>

		<p>Yhteistä edellä olevilla kysymyksillä on se, että lähes kaikki niistä ovat oikeastaan yhteenvetokyselyjä. Tutustutaan kohta näiden käsittelyyn liittyviin menetelmiin.</p>

		<aside class="info">
		  <br/>
		  <h1>SQL-kyselyt lyhyemmiksi</h1>

		  <p>Olemme -- tarkoituksella -- käyttäneet SQL-kyselykielestä verboosia kirjoitusasua, missä myös ei-pakollisia komentoja on kirjoitettu kyselyihin niiden selkeyttämiseksi. Jos olet tykästynyt aiemmin käytettyyn verboosiin kirjoitusasuun, ei siitä tarvitse vaihtaa pois. Alla on kuitenkin esitelty vinkkejä SQL-kyselyiden lyhentämiseksi:</p>

		  <ul>
		    <li><p>Taulujen nimeäminen SQL-kyselyissä.</p> <p>Kirjoittaessamme tauluja yhdisteleviä kysejä kuten <code>SELECT * FROM Opiskelija, Kurssisuoritus WHERE Opiskelija.opiskelijanumero = Kurssisuoritus.opiskelija</code> taulujen nimet toistuvat. Tauluja voidaan uudelleennimetä SQL-kyselyissä asettamalla taulun nimen jälkeen kyselyn aikana käytettävän nimi. Seuraavassa esimerkissä taulu Opiskelija on uudelleennimetty <code>o</code>:ksi, ja taulu Kurssisuoritus on uudelleennimetty <code>k</code>:ksi.</p>

<pre class="sh_sql">
SELECT * FROM Opiskelija o, Kurssisuoritus k WHERE o.opiskelijanumero = k.opiskelija</pre></li>

		    <li><p>Sarakkeiden nimeäminen SQL-kyselyissä.</p><p>Olemme käyttäneet avainsanaa <code>AS</code> taulun sarakkeiden uudelleennimennässä. Kysely <code>SELECT nimi FROM Opiskelija</code> palauttaa sarakkeen, jonka nimi on 'nimi', ja jossa on kaikkien Opiskelija-taulussa olevien opiskelijoiden nimet. Toisaalta, kysely <code>SELECT nimi AS opiskelija FROM Opiskelija</code> nimeää sarakkeen 'nimi' tulostuksessa uudestaan, jolloin sarakkeen 'nimi' otsikoksi tulee 'opiskelija' -- rivit sisältävät opiskelijoiden nimet. Avainsanan <code>AS</code> voi myös jättää pois. Alla oleva kysely tulostaa Opiskelija-taulun nimi-sarakkeen sisällön, mutta siten, että sarakkeen otsikkona on 'opiskelija'.</p><br/>

<pre class="sh_sql">
SELECT nimi opiskelija FROM Opiskelija</pre>

		      <p>Sarakkeet erotellaan pilkulla kuten aiemminkin.</p>

<pre class="sh_sql">
SELECT nimi opiskelija, syntymävuosi vuosi FROM Opiskelija</pre>

		      <p>Kyselyssä voi luonnollisesti sekä lyhentää taulun nimeä, että jättää <code>AS</code> avainsanan pois:</p>

<pre class="sh_sql">
SELECT o.nimi opiskelija, k.arvosana 
    FROM Opiskelija o, Kurssisuoritus k 
    WHERE o.opiskelijanumero = k.opiskelija</pre></li>
		    
		    <li><p>INNER JOIN ja JOIN</p>
		      
		      <p>Liitoskyselyn INNER JOIN voi kirjoittaa muodossa JOIN.</p></li>
		  </ul>
		</aside>
		

		<h2>Alikyselyt</h2>
		
		<p>Alikyselyt ovat nimensä mukaan kyselyn osana suoritettavia alikyselyitä, joiden tuloksia käytetään osana pääkyselyä. Pohditaan kysymystä <em>Miten haen opiskelijat, jotka eivät ole vielä osallistuneet yhdellekään kurssille?</em>, ja käytetään siihen ensin aiemmin tutuksi tullutta tapaa, eli LEFT JOIN -kyselyä. Yhdistetään opiskelijaa ja kurssisuoritusta kuvaavat taulut LEFT JOIN-kyselyllä siten, että myös opiskelijat, joilla ei ole suorituksia tulevat mukaan vastaukseen. Tämän jälkeen, jätetään vastaukseen vain ne rivit, joilla kurssisuoritukseen liittyvät tiedot ovat tyhjiä -- tämä onnistuu katsomalla mitä tahansa kurssisuoritus-taulun saraketta, ja tarkistamalla onko se tyhjä, eli <em>null</em>. Tämä onnistuu seuraavasti:</p>


		<div ng-controller="weekThreeSqlController">

		  <query
		     db="db"
		     editable="false"
		     query="SELECT opiskelijanumero FROM Opiskelija o
    LEFT JOIN Kurssisuoritus k
    ON o.opiskelijanumero = k.opiskelija
    WHERE k.kurssi IS null">
		  </query>

		</div>

		<p>Toinen vaihehtoehto edellisen kyselyn toteuttamiseen on toteuttaa kysely, joka hakee kaikki ne opiskelijat, jotka eivät ole kurssisuorituksia saaneiden opiskelijoiden joukossa. Tässä on oleellisesti kaksi kyselyä: (1) hae opiskelijat, joilla on kurssisuoritus, ja (2) hae opiskelijat, jotka eivät ole edellisen kyselyn palauttamassa joukossa.</p>

		<p><strong><em>Alikyselyn toteuttaminen</em></strong></p>

		<p>Alikyselyn toteuttamiseksi voimme määritellä kyselyn WHERE-osaan sarakkeen nimen, jota seuraa avainsana <em>NOT IN</em>, jota taas seuraa suluissa oleva kysely.</p>

		
		<div ng-controller="weekThreeSqlController">

		  <query
		     db="db"
		     editable="false"
		     query="SELECT opiskelijanumero FROM Opiskelija o
    WHERE o.opiskelijanumero 
        NOT IN (SELECT opiskelija FROM Kurssisuoritus)"
		     done="unlockListCoursesWithNoAssignments">
		  </query>

		  <div ng-show="unlockListCoursesWithNoAssignments">

		    <p>Tee nyt kysely, joka listaa kaikki kurssit, joilla ei ole yhtään tehtävää.</p>

		    <query
		       db="db"
		       query="">
		    </query>
		  </div>

		</div>

		<p>Käytännössä alikyselyt tuottavat kyselyn tuloksena taulun, josta pääkyselyssä tehtävä kysely tehdään. Ylläolevassa esimerkissä alikyselyn tuottamassa taulussa on vain yksi sarake, jossa on kurssisuorituksen saaneiden opiskelijoiden opiskelijanumerot.</p>

		<p>Määreen <code>NOT IN</code>, joka tarkastaa että valitut arvot eivät ole alikyselyn tuottamassa taulussa, lisäksi käytössä on määre <code>IN</code>. Määreen <code>IN</code> avulla voidaan luoda ehto, jolla tarkastetaan, että valitut arvot ovat annetussa joukossa tai taulussa. Esimerkiksi alla haetaan kaikki kurssisuoritukset, joissa arvosana on kolme tai viisi.</p>
		
		<div ng-controller="weekThreeSqlController">
		  
		  <query
		     db="db"
		     editable="false"
		     query="SELECT * FROM Kurssisuoritus WHERE arvosana IN (5, 3)">
		  </query>
		</div>
		
		<aside class="info">
		  <br/>

		  <h1>EXISTS ja NOT EXISTS</h1>
		  
		  <p>Määreiden IN ja NOT IN lisäksi alikyselyissä voidaan käyttää määreitä EXISTS ja NOT EXISTS, joiden avulla voidaan rajata hakujoukkoa alikyselyssä olevan ehdon perusteella. Voimme esimerkiksi kirjoittaa aiemmin kirjoitetun kursseja suorittamattomia opiskelijoita etsivän kyselyn siten, että jokaisen Opiskelija-taulussa olevan opiskelijanumeron kohdalla tarkistetaan, että sitä ei löydy taulusta Kurssisuoritus.</p>
		  
		  <div ng-controller="weekThreeSqlController">
		    
		    <query
		       db="db"
		       editable="false"
		       query="SELECT opiskelijanumero FROM Opiskelija o
    WHERE NOT EXISTS
        (SELECT opiskelija FROM Kurssisuoritus k 
        WHERE k.opiskelija = o.opiskelijanumero)">
		    </query>
                  </div>

		  <p>Edellä oleva kysely tarkistaa jokaisen Opiskelija-taulussa olevan opiskelijanumeron kohdalla ettei sitä löydy Kurssisuoritus-taulun opiskelija-sarakkeesta. Käytännössä -- jos tietokantamoottori ei optimoi kyselyä -- jokainen opiskelija-taulun rivi aiheuttaa uuden kyselyn kurssisuoritus-tauluun, mikä tekee kyselystä tehottoman.</p>
		  
		</aside>


		<h2>Yhteenvetokyselyt</h2>

		<p>Yhteenvetokyselyiden avulla kyselyiden tuloksia ryhmitellään sarakkeissa olevien arvojen perusteella, jonka jälkeen luoduille ryhmille tehdään erilaisia yhteenvetokyselyitä. Voimme esimerkiksi haluta selvittää opiskelijoiden määrän pääaineittain ryhmiteltynä -- toisin sanoen, listata pääaineet ja opiskelijalukumäärät. Kyselyn vastauksessa olevan rivien lukumäärän saa komennolla <code>COUNT(<em>sarake</em>)</code>, missä <em>sarake</em> on laskettavan sarakkeen nimi. Ryhmittely tapahtuu komennon <code>GROUP BY</code>-perusteella, jota seuraa sarakkeen nimi, jonka perusteella tulokset ryhmitellään.</p>

		
		<div ng-controller="weekThreeSqlController">
		  
		  <query
		     db="db"
		     editable="false"
		     query="SELECT pääaine, COUNT(*) AS lukumäärä
    FROM Opiskelija GROUP BY pääaine"
                     done="unlockListCountKurssisuorituksetByKurssi">
		  </query>

		  <div ng-show="unlockListCountKurssisuorituksetByKurssi">
		    <p>Tee nyt kysely, jolla lasket kurssisuoritus-taulussa olevat kurssisuoritukset kurssin koodin perusteella. Käytä tulostuksessa sarekkeiden nimiä "kurssikoodi" ja "lukumäärä".</p>
		    <query
		       db="db"
		       query=""
		       valid="SELECT kurssi AS kurssikoodi, COUNT(*) lukumäärä FROM Kurssisuoritus GROUP BY kurssi">
		    </query>
		  </div>

		  <p>Useampien taulujen yhdistäminen toimii kuten ennen -- valittavat kurssit kerrotaan joko FROM -avainsanan jälkeen tai JOIN -avainsanan jälkeen, riippuen kyselytavasta. Ryhmittelykomento tulee mahdollisten WHERE-ehtojen jälkeen. Alla olevassa esimerkissä lasketaan tehtävien määrä eri kursseilla siten, että kurssin nimi haetaan taulusta Kurssi, ja tehtävät haetaan kurssitehtävistä.</p>
		  
		  <query
		     db="db"
		     editable="false"
		     query="SELECT k.nimi AS kurssi, COUNT(kt.tunnus) AS tehtäviä FROM Kurssi k, Kurssitehtävä kt
    WHERE k.kurssitunnus = kt.kurssi GROUP BY k.nimi"
		     done="unlockListCountKurssisuorituksetByKurssiWithName">
		  </query>
		 

		  
		  <div ng-show="unlockListCountKurssisuorituksetByKurssiWithName">

		    <p>Tee nyt kysely, jossa lasket kurssisuoritus-taulussa olevien kurssien suoritukset -- taas koodin perusteella. Tällä kertaa tulostuksessa tulee kuitenkn tulostaa kurssikoodin sijaan kurssin nimi. Käytä sarakkeiden niminä "kurssi" ja "lukumäärä". (Huomaa, että edellisessä osassa katsotaan kurssitehtäviä, tässä kurssisuorituksia!)</p>

		    
		    <query
		       db="db"
		       query=""
		       valid="SELECT Kurssi.nimi AS kurssi, COUNT(*) lukumäärä FROM Kurssisuoritus, Kurssi WHERE Kurssisuoritus.kurssi = Kurssi.kurssitunnus GROUP BY kurssi">
		    </query>
		  </div>


		  <p>Edellä olevia tuloksia tarkasteltaessamme, huomaamme, että luku nolla ei esiinny yhdelläkään rivillä. Tämä selittyy kyselyillämme -- olemme valinneet mukaan vain rivit, joilla hakuehdot täyttyvät. Hups. Kirjoitetaan edellinen kysely siten, että otamme huomioon kurssit vaikka niihin ei liittyisikään yhtäkään toisen taulun riviä -- käytämme siis <code>LEFT JOIN</code>-liitosoperaatiota.</p>
		  
		  <query
		     db="db"
		     editable="false"
		     query="SELECT k.nimi AS kurssi, COUNT(ks.kurssi) as tehtäviä FROM Kurssi k LEFT JOIN Kurssisuoritus ks
    ON k.kurssitunnus = ks.kurssi GROUP BY k.nimi"
		     done="unlockLeftJoinKurssiAndKurssisuoritus">
		  </query>
		  
		  
		  <div ng-show="unlockLeftJoinKurssiAndKurssisuoritus">
		    
		    <p>Tee nyt LEFT JOIN -operaatiota käyttäen kysely, jolla listaat kurssikohtaiset suorituslukumäärät siten, että myös ne kurssit, joilla ei ole yhtäkään suoritusta otetaan huomioon. Käytä sarakkeiden niminä nimiä "kurssi" ja "lukumäärä".</p>
		    
		    <query
		       db="db"
		       query=""
		       valid="SELECT Kurssi.nimi AS kurssi, COUNT(Kurssisuoritus.kurssi) lukumäärä FROM Kurssi LEFT JOIN Kurssisuoritus ON Kurssi.kurssitunnus = Kurssisuoritus.kurssi GROUP BY kurssi">
		    </query>
		    
		  </div>
		  
		</div>

		<p><strong><em>Ryhmittely useamman sarakkeen perusteella</em></strong></p>
		
		<p>Komennolle <code>GROUP BY</code> voi antaa myös useampia sarakkeita, jolloin se ryhmittelee ne annetussa järjestyksessä. Esimerkiksi ryhmittely <code>GROUP BY kurssi, arvosana</code> ryhmittelisi taulussa olevat rivit ensin kurssin perusteella, jonka jälkeen ne vielä ryhmiteltäisiin arvosanan perusteella. Tällöin jokaiselle kurssille tulisi erilliset arvosanaryhmät. Esimerkiksi kurssikohtaiset arvosanat saisi tulostettua seuraavalla kyselyllä:</p>

		
		<div ng-controller="weekThreeSqlController">
		  
		  <query
		     db="db"
		     editable="false"
		     query="SELECT k.nimi AS kurssi, ks.arvosana AS arvosana, COUNT (ks.opiskelija) AS lukumäärä 
    FROM Kurssi k, Kurssisuoritus ks WHERE k.kurssitunnus = ks.kurssi 
        GROUP BY k.nimi, ks.arvosana">
		  </query>
		</div>

		<p>Edellisessä kyselyssä on hieman tylsää se, että kurssien nimet ja arvosanat eivät ole järjestyksessä.</p>

		<p><strong><em>Tulosten järjestäminen</em></strong></p>
		
		<p>Kyselyn tulokset voi järjestää komennolla <code>ORDER BY</code>, jota seuraa järjestettävät sarakkeet. Sarakkeelle voi antaa myös lisämääreen <code>ASC</code> (<em>ascending</em>), joka kertoo että tulokset tulee järjestää nousevaan järjestykseen, ja <code>DESC</code> (<em>descending</em>), joka kertoo että tulokset tulee järjestää laskevaan järjestykseen. Oletuksena järjestys on laskeva.</p>

		<p>Komento <code>ORDER BY</code> tulee kyselyn loppuun. Järjestetään edellisen kyselyn tulokset.</p>

		<div ng-controller="weekThreeSqlController">
		  
		  <query
		     db="db"
		     editable="false"
		     query="SELECT k.nimi AS kurssi, ks.arvosana AS arvosana, COUNT (ks.opiskelija) AS lukumäärä 
    FROM Kurssi k, Kurssisuoritus ks WHERE k.kurssitunnus = ks.kurssi 
        GROUP BY k.nimi, ks.arvosana ORDER BY k.nimi, ks.arvosana DESC">
		  </query>
		</div>
		

		<p><strong><em>Yhteenvetokyselyissä käytettäviä funktioita</em></strong></p>
		
		<p>Komento <code>COUNT(<em>sarake</em>)</code> on funktio, jolle annetaan joukko arvoja, ja joka palauttaa niiden pohjalta luodun arvon -- annetun joukon koon eli arvojen lukumäärän. Yhteenvetokyselyiden käytössä on myös nippu muita funktioita, joista seuraavassa listataan muutamia.</p>


		<ul>
		  <li><p>Keskiarvon laskeminen <code>AVG</code></p>
		    
		    <p>Funktio <code>AVG</code> laskee sille annettujen arvojen keskiarvon. Esimerkiksi kurssikohtaiset arvosanojen keskiarvot saa laskettua seuraavalla kyselyllä:</p>

		    <div ng-controller="weekThreeSqlController">
		      
		      <query
			 db="db"
			 editable="false"
			 query="SELECT kurssi, AVG(arvosana) AS keskiarvo 
    FROM Kurssisuoritus GROUP BY kurssi">
		      </query>
		    </div>

		  </li>

		  <li><p>Summan laskeminen <code>SUM</code></p>
		    
		    <p>Funktio <code>SUM</code> laskee sille annettujen arvojen summan. Esimerkiksi kysely seuraava kysely laskee opiskelijakohtaisen opintopistemäärän.</p>

		    <div ng-controller="weekThreeSqlController">
		      
		      <query
			 db="db"
			 editable="false"
			 query="SELECT o.nimi AS nimi, SUM(ks.opintopistemäärä) AS opintopisteitä 
    FROM Opiskelija o LEFT JOIN Kurssisuoritus ks 
        ON o.opiskelijanumero = ks.opiskelija 
    WHERE ks.arvosana > 0 GROUP BY o.nimi">
		      </query>
		    </div>
		    
		    
		    <p>Kuten ehkä huomaat, kysely ei toimi tapauksissa, missä opiskelija on korottanut kurssin arvosanaa, sillä hänellä on tällöin useampia hyväksyttyjä merkintöjä samasta kurssista.</p></li>
		  
		  <li><p>Pienimmän arvon valitseminen <code>MIN</code></p>
		    
		    <p>Funktio <code>MIN</code> valitsee sille annettujen arvojen joukosta pienimmän arvon.</p></li>
		  
		  <li><p>Suurimman arvon valitseminen <code>MAX</code></p>
		    
		    <p>Funktio <code>MAX</code> valitsee sille annettujen arvojen joukosta suurimman arvon.</p></li>
		</ul>
		
		<aside class="info">
		  <br/>
		  
		  <h1>Funktiot osana kyselyitä, joissa ryhmittelyä ei tehdä</h1>
		  
		  <p>Edellämainittuja funktioita voi käyttää osana käytännössä minkälaista kyselyä tahansa, jos kyselyn vastauksessa on selkeä yksittäinen sarake, jonka arvoja funktio käsittelee. Esimerkiksi kaikkien kurssien keskiarvon voi laskea seuraavasti:</p>

		  <div ng-controller="weekThreeSqlController">
		    
		    <query
		       db="db"
		       editable="false"
		       query="SELECT AVG(arvosana) FROM Kurssisuoritus">
		    </query>
		  </div>
		  
		  <p>Tässä on kuitenkin huomioitava se, että jos kyselyssä on useampia sarakkeita, tulee funktion pystyä laskemaan sarakekohtaisia tuloksia -- esimerkiksi ryhmittelyn kautta. Alla oleva kysely on esimerkki kyselystä, joka ei palauta oikeaa tulosta.</p>
		  
		  <div ng-controller="weekThreeSqlController">
		    
		    <query
		       db="db"
		       editable="false"
		       query="SELECT kurssi, AVG(arvosana) FROM Kurssisuoritus">
		    </query>
		  </div>
		  
		</aside>
		
		
		
		<h2>Kyselyn tulos on taulu</h2>
		
		<p>Kaikki SQL-kyselyt tuottavat tuloksena taulun. Taulussa voi olla tasan yksi sarake ja rivi, tai vaikkapa tuhansia rivejä ja kymmeniä sarakkeita. Silloinkin, kun suoritamme yksinkertaisen haun, kuten vaikkapa "Hae kaikki kurssilla 'Tietokantojen perusteet' olevat opiskelijat", on haun tuloksena taulu.</p>
		
		<p>Kaikki tekemämme SQL-kyselyt ovat liittyneet tauluihin. Emmekö siis voisi tehdä kyselyjä myös vastauksiin? Vastaus on kyllä.</p>
		
		<p>Esimerkiksi vanhimman (tai vanhimmat, jos tämä ei ole yksikäsitteistä) opiskelijat löytää -- muunmuassa -- etsimällä kaikista pienimmän mahdollisimman syntymävuoden (kyselyn tulos on taulu), jonka jälkeen vastaustaulussa olevaa tulosta kaikkien opiskelijoiden syntymävuosiin.</p>

		<div ng-controller="weekThreeSqlController">
		  <query
		     db="db"
		     editable="false"
		     query="SELECT * FROM Opiskelija 
    WHERE syntymävuosi 
        IN (SELECT MIN(syntymävuosi) FROM Opiskelija)">
		  </query>
		</div>
		
	
		<p>Tätä harjoitellaan lisää kurssin tehtävissä.</p>

		
		<h1>Ohjelmalliset tietokantakyselyt ja viitteet taulujen välillä</h1>
		
		<p>Aiemmat, luvussa kolme näkemämme tietokantakyselyiden ohjelmalliseen suorittamiseen liittyvät esimerkit ovat olleet melko yksinkertaisia, sillä niissä on ladattu tietoa yhdestä taulusta kerrallaan. Todellisuudessa tietokannoissa on usein viitteitä taulujen välillä, ja ohjelmallista tietokanta-abstraktiota käyttävän ohjelmoijan näkökulmasta olisi hyvin kätevää, jos nämä viitteet toimisivat myös olioina.</p>

		<p>Tässä luvussa tutustumme viitteiden käsittelyyn taulujen välillä, sekä tutustumme olemassaolevaan kirjastoon, joka automatisoi osan tästä työstä.</p>

		<p>Oletamme, että tietokantakaaviomme on luvussa 3 käyttämämme kuvitteellisen pyörävuokraamon tietokannan osa. Tietokantakaaviomme on seuraavanlainen:</p>


		<figure>
		  <img src="img/viikko4/vuokraamokaavio.png" alt="[Pyora|(pk) rekisterinumero; merkki]
[Varaaja|(pk) asiakasnumero; etunimi; sukunimi]
[Varaus|(pk) varaustunnus; (fk) varaaja: Varaaja; (fk) pyora: Pyora; varaus_alkaa; varaus_loppuu]
[Pyora]1-*[Varaus]
[Varaus]*-1[Varaaja]"/>
		</figure>
		
		<p>Kun ylläoleva tietokantakaavio luodaan Java-ohjelmakoodina siten, että taulujen väliset viitteet on otettu huomioon, luomme käytännössä kolme luokkaa: <em>Pyora</em>, <em>Varaaja</em> ja <em>Varaus</em>. Yhteen pyörään voi liittyä monta varausta, eli jokaiseen pyöräolioon liittyy lista varauksia. Vastaavasti, jokaiseen varaajaan voi liittyä monta varausta, eli jokaiseen varaajaolioon liittyy lista varauksia. Jokaiseen varausolioon liittyy yksi pyöräolio ja yksi varaajaolio.</p>

		<pre class="sh_java">
import java.util.*;

public class Pyora {

    private String rekisterinumero;
    private String merkki;
    private List&lt;Varaus&gt; varaukset;

// konstruktorit, getterit ja setterit</pre>

		<pre class="sh_java">
import java.util.*;

public class Varaaja {

    private Integer asiakasnumero;
    private String etunimi;
    private String sukunimi;
    private List&lt;Varaus&gt; varaukset;

// konstruktorit, getterit ja setterit</pre>


		<pre class="sh_java">
import java.util.*;
import java.sql.*;

public class Varaus {

    private Integer varaustunnus;
    private Pyora pyora;
    private Varaaja varaaja;
    private Timestamp varausAlkaa;
    private Timestamp varausLoppuu;

// konstruktorit, getterit ja setterit</pre>

		<p>Luokassa Varaus käytetty muuttujan tyyppi <code><a href="https://docs.oracle.com/javase/8/docs/api/java/sql/Timestamp.html" target="_blank">Timestamp</a></code> on eräs tietokannoissa käytetty muuttujatyyppi ajan tallentamiseen.</p>

		<p>Ohjelmallisia tietokantakyselyitä suorittaessa -- esimerkiksi varauksen noutamisen yhteydessä -- tulee nyt hakea (1) varaustaulusta rivi, (2) haetun varausrivin pyora-kentästä löytyvällä viiteavaimella rivi pyörätaulusta, (3) haetun varausrivin varaaja-kentästä löytyvällä viiteavaimella rivi varaaja-taulusta, ja (4) luoda haettujen rivien perusteella oliot -- varaaja- ja pyörä-oliot tulee lisäksi asettaa varaukseen kuuluvaksi. Kokonaisuudessaan, ilman toiminnallisuuden jakamista erillisiin osiin, tietyn varauksen ja siihen liittyvän pyörän hakemiseen tarvittava kysely voisi olla vaikkapa seuraavanlainen.</p>

<pre class="sh_java">
String driver = "org.sqlite.JDBC";
String databaseAddress = "jdbc:sqlite:vuokraamo.db";

// haetaan tietokanta-ajuri ja avataan tietokantayhteys
Class.forName(driver);
Connection conn = DriverManager.getConnection(databaseAddress);

// haetaan yksittäinen varaus, jonka tunnus on 42
PreparedStatement stmt = conn.prepareStatement("SELECT * FROM Varaus WHERE varaustunnus = ?");
stmt.setObject(1, 42);

// suoritetaan kysely ja siirrytään ensimmäiseen vastausriviin
ResultSet rs = stmt.executeQuery();
rs.next();

// haetaan vastausriviltä oleelliset kentät
Integer varaustunnus = rs.getInt("varaustunnus");
Timestamp alku = rs.getTimestamp("varaus_alkaa");
Timestamp loppu = rs.getTimestamp("varaus_loppuu");
String pyora = rs.getString("pyora");

// luodaan varaus varaustunnuksen, sekä alun ja lopun perusteella
Varaus v = new Varaus(varaustunnus, alku, loppu);

// vapautetaan varaus-tauluun kohdistuneeseen kyselyyn liittyvät resurssin
rs.close();
stmt.close();

// haetaan yksittäinen pyörä, jonka rekisterinumero oli varaustaulusta haetussa rivissä
stmt = conn.prepareStatement("SELECT * FROM Pyora WHERE rekisterinumero = ?");
stmt.setObject(1, pyora);

// suoritetaan kysely ja siirrytään ensimmäiseen vastausriviin
rs = stmt.executeQuery();
rs.next();

// haetaan vastausriviltä oleelliset kentät
String rekisterinumero = rs.getString("rekisterinumero");
String merkki = rs.getString("merkki");

// luodaan pyörä vastauksen perusteella
Pyora p = new Pyora(rekisterinumero, merkki);

// asetetaan pyörä varaukseen liittyväksi pyöräksi
v.setPyora(p);

// vapautetaan kyselyyn liittyvät resurssit ja suljetaan tietokantayhteys
rs.close();
stmt.close();
conn.close();

// nyt käytössämme on varaus-olio, sekä varaukseen liittyvä pyörä-olio
</pre>

                <p>Käytännössä toiminnallisuutta kuitenkin jaetaan osiin.</p>


		<h2>Data Access Object -suunnittelumalli</h2>

		<p>Tietokantasovelluksia toteuttaessa on hyvin tyypillistä abstrahoida, eli piilottaa, konkreettinen tiedon hakemis- ja tallennustoiminnallisuus siten, että ohjelmoijan ei tarvitse nähdä sitä jatkuvasti. Ideana on, että sovelluskehittäjä käyttää <em>DAO</em>-rajapinnan toteuttamia olioita, ja se, että mistä tai miten tiedot konkreettisesti haetaan ei ole sovelluksen muiden osien tiedossa.</p>

		<p>Hahmotellaan hakemiseen ja poistamiseen liittyvää rajapintaa, joka tarjoaa metodit <code>findOne</code>, <code>findAll</code> ja <code>delete</code>, eli toiminnallisuudet hakemiseen ja poistamiseen. Tehdään rajapinnasta <em>geneerinen</em>, eli toteuttava luokka määrittelee palautettavien olioiden tyypin sekä avaimen.</p>

<pre class="sh_java">
import java.sql.*;
import java.util.*;

public interface Dao&lt;T, K&gt; {

    T findOne(K key) throws SQLException;

    List&lt;T&gt; findAll() throws SQLException;

    void delete(K key) throws SQLException;
}</pre>

                <p>Metodi findOne hakee tietyllä avaimella haettavan olion, jonka tyyppi voi olla mikä tahansa. Alustava hahmotelma konkreettisesta varausten hakemiseen tarkoitetusta <code>VarausDao</code>-luokasta on seuraavanlainen. </p>

<pre class="sh_java">
import java.util.*;
import java.sql.*;

public class VarausDao implements Dao&lt;Varaus, Integer&gt; {

    @Override
    public Varaus findOne(Integer key) throws SQLException {
        // ei toteutettu
        return null;
    }

    @Override
    public List&lt;Varaus&gt; findAll() throws SQLException {
	// ei toteutettu
	return null;
    }

    @Override
    public void delete(Integer key) throws SQLException {
        // ei toteutettu 
    }
}</pre>

                <p>Käytännössä tyyppiparametrit annetaan rajapinnan toteuttamisesta kertovan avainsanan <code>implements</code>-yhteyteen. Ylläolevassa esimerkissä haettavan olion tyyppi on <code>Varaus</code>, ja sen avain on tyyppiä <code>Integer</code>.</p>

		<p>Koska varausten hakemiseen tarvitaan myös pyörien hakemista, hahmotellaan myös pyörien hakemiseen liittyvää toiminnallisuutta. Luokan rakenne on hyvin samankaltainen kuin edellä.</p>


<pre class="sh_java">
import java.util.*;
import java.sql.*;

public class PyoraDao implements Dao&lt;Pyora, String&gt; {

    @Override
    public Pyora findOne(String key) throws SQLException {
        // ei toteutettu
        return null;
    }

    @Override
    public List&lt;Pyora&gt; findAll() throws SQLException {
	// ei toteutettu
	return null;
    }

    @Override
    public void delete(String key) throws SQLException {
        // ei toteutettu 
    }
}</pre>

		<p>Jatketaan luokan <code>PyoraDao</code>-toteuttamista. Lisätään luokalle pääsy tietokanta-abstraktioon, jolta voi pyytää tietokantayhteyden, ja hahmotellaan yksittäisen pyörän hakemista aiemman ohjelmakoodin perusteella. Emme tässä esimerkissä lisää pyörään siihen liittyviä varauksia.</p>


<pre class="sh_java">
import java.util.*;
import java.sql.*;

public class PyoraDao implements Dao&lt;Pyora, String&gt; {

    private Database database;

    @Override
    public Pyora findOne(String key) throws SQLException {
        Connection connection = database.getConnection();
        PreparedStatement stmt = connection.prepareStatement("SELECT * FROM Pyora WHERE rekisterinumero = ?");
        stmt.setObject(1, key);

        ResultSet rs = stmt.executeQuery();
        boolean hasOne = rs.next();
        if (!hasOne) {
            return null;
        }

        String rekisterinumero = rs.getString("rekisterinumero");
        String merkki = rs.getString("merkki");

        Pyora p = new Pyora(rekisterinumero, merkki);

        rs.close();
        stmt.close();
        connection.close();

        return p;
    }

    @Override
    public List&lt;Pyora&gt; findAll() throws SQLException {
	// ei toteutettu
	return null;
    }

    @Override
    public void delete(String key) throws SQLException {
        // ei toteutettu 
    }
}</pre>

		<p>Luokka <code>Database</code> on esimerkiksi seuraavanlainen -- huomaa, että jaamme tietokantakyselyiden tekemisen vastuuta jokaiselle Dao-rajapinnan toteuttavalle luokalle erikseen -- kyselyt eivät siis ole enää <code>Database</code>-luokassa.</p>

<pre class="sh_java">
import java.sql.*;

public class Database {

    private String databaseAddress;

    public Database(String driver, String databaseAddress) throws ClassNotFoundException {
        Class.forName(driver);
        this.databaseAddress = databaseAddress;
    }

    public Connection getConnection() throws SQLException {
        return DriverManager.getConnection(databaseAddress);
    }
}</pre>

		<p>Hahmotellaan nyt yksittäisen varaus-olion hakemista. Toteutetaan luokka siten, että se saa konstruktorissaan sekä viitteen tietokanta-olioon, että viitteen pyörien hakemiseen tarkoitettuun Dao-rajapintaan.</p>

<pre class="sh_java">
import java.util.*;
import java.sql.*;

public class VarausDao implements Dao&lt;Varaus, Integer&gt; {


    private Database database;
    private Dao&lt;Pyora, String&gt; pyoraDao;

    public VarausDao(Database database, Dao&lt;Pyora, String&gt; pyoraDao) {
        this.database = database;
        this.pyoraDao = pyoraDao;
    }

    @Override
    public Varaus findOne(Integer key) throws SQLException {
        Connection connection = database.getConnection();
        PreparedStatement stmt = connection.prepareStatement("SELECT * FROM Varaus WHERE varaustunnus = ?");
        stmt.setObject(1, key);

        ResultSet rs = stmt.executeQuery();
        boolean hasOne = rs.next();
        if (!hasOne) {
            return null;
        }

        Integer varaustunnus = rs.getInt("varaustunnus");
        Timestamp alku = rs.getTimestamp("varaus_alkaa");
        Timestamp loppu = rs.getTimestamp("varaus_loppuu");

        Varaus v = new Varaus(varaustunnus, alku, loppu);

        Integer varaaja = rs.getInt("varaaja");
        String pyora = rs.getString("pyora");

        rs.close();
        stmt.close();
        connection.close();

        v.setPyora(this.pyoraDao.findOne(pyora));

        return v;
    }

    @Override
    public List&lt;Varaus&gt; findAll() throws SQLException {
	// ei toteutettu
	return null;
    }

    @Override
    public void delete(Integer key) throws SQLException {
        // ei toteutettu 
    }
}</pre>


		<p>Nyt yksittäisen varauksen hakemisen yhteydessä palautetaan sekä varaus, että siihen liittyvä pyörä. Rajapintaa käyttävän toteutuksen näkökulmasta tietokannan käyttäminen toimii seuraavasti:</p>

<pre class="sh_java">
Database database = new Database("org.sqlite.JDBC", "jdbc:sqlite:vuokraamo.db");
PyoraDao pyoraDao = new PyoraDao(database);
VarausDao varausDao = new VarausDao(database, pyoraDao);

Varaus varaus = varausDao.findOne(4);
System.out.println(varaus.getPyora().getRekisterinumero()
        + " " + varaus.getVarausAlkaa()
        + " - " + varaus.getVarausLoppuu());</pre>

<pre>
HAB-4 2015-07-17 16:00:00.0 - 2015-07-18 10:00:00.0</pre>



		<p><strong><em>Kokoelmien hakeminen</em></strong></p>

		<p>Voisimme nyt jo toteuttaa kaikkien varausten hakemisen siten, että kävisimme jokaisen varaus-taulussa olevan varaustunnuksen läpi yksitellen, ja lisäisimme siihen halutun pyörän. Tämä ei kuitenkaan ole haluttua. Kaikken varausten hakeminen kannattanee toteuttaa siten, että haemme ensin kaikki varaukset, jonka jälkeen haemme pyörät, jotka lisäämme varauksiin. Kaikkien pyörien hakeminen -- jos emme toteuta erikseen pyöriin liittyvien varausten listausta -- tapahtuu esimerkiksi seuraavasti.</p>

<pre class="sh_java">
@Override
public List&lt;Pyora&gt; findAll() throws SQLException {
    Connection connection = database.getConnection();
    PreparedStatement stmt = connection.prepareStatement("SELECT * FROM Pyora");

    ResultSet rs = stmt.executeQuery();
    List&lt;Pyora&gt; pyorat = new ArrayList&lt;&gt;();
    while (rs.next()) {
        String rekisterinumero = rs.getString("rekisterinumero");
        String merkki = rs.getString("merkki");

        pyorat.add(new Pyora(rekisterinumero, merkki));
    }
    
    rs.close();
    stmt.close();
    connection.close();

    return pyorat;
}</pre>

		<p>Nyt pyörien liittäminen varauksiin onnistuu kahdella tietokantakyselyllä (1) haetaan kaikki varaukset ja (2) haetaan kaikki pyörät -- yhdistäminen tapahtuu ohjelmakoodissa esimerkiksi seuraavasti.</p>

<pre class="sh_java">
@Override
public List&lt;Varaus&gt; findAll() throws SQLException {
    Connection connection = database.getConnection();
    PreparedStatement stmt = connection.prepareStatement("SELECT * FROM Varaus");
    ResultSet rs = stmt.executeQuery();

    Map&lt;String, List&lt;Varaus&gt;&gt; varaustenPyorat = new HashMap&lt;&gt;();

    List&lt;Varaus&gt; varaukset = new ArrayList&lt;&gt;();

    while (rs.next()) {

        Integer varaustunnus = rs.getInt("varaustunnus");
        Timestamp alku = rs.getTimestamp("varaus_alkaa");
        Timestamp loppu = rs.getTimestamp("varaus_loppuu");

        Varaus v = new Varaus(varaustunnus, alku, loppu);
        varaukset.add(v);
        
        String pyora = rs.getString("pyora");
        
        if(!varaustenPyorat.containsKey(pyora)) {
            varaustenPyorat.put(pyora, new ArrayList&lt;&gt;());
        }
        varaustenPyorat.get(pyora).add(v);
    }

    rs.close();
    stmt.close();
    connection.close();
    
    for (Pyora pyora : this.pyoraDao.findAll()) {
        if(!varaustenPyorat.containsKey(pyora.getRekisterinumero())) {
            continue;
        }
        
        for (Varaus varaus : varaustenPyorat.get(pyora.getRekisterinumero())) {
            varaus.setPyora(pyora);
        }
    }
    
    return varaukset;
}</pre>

		<p>Yllä haetaan ensin kaikki varaukset. Varausolioita luotaessa luodaan kirjanpito varauksiin liittyvien pyörien (viiteavain tauluun Pyörä) liittymisestä varausolioihin. Tämän jälkeen haetaan pyörät, ja lisätään ne varaukseen.</p>

		<p><strong><em>Osajoukon hakeminen</em></strong></p>


		<p>Edellisessä esimerkissä on kuitenkin hieman hölmöä se, että haemme <em>kaikki</em> viitatussa taulussa olevat rivit. Pyörien tapauksessa tämä voi olla hyväksyttävää, jos niitä on melko vähän, ja voimme olettaa, että lähes jokaista pyörää varataan. Toisaalta, jos vastaavaa toteutusta tehtäisiin varaajiin liittyen, ei jokaisen varaajan hakeminen olisi toivottua.</p>

		<p>Lisätään Dao-rajapintaan metodi <code>findAllIn(Collection&lt;K&gt; keys)</code>, joka hakee ne oliot, joiden avaimet ovat annetussa joukossa.</p>
		
<pre class="sh_java">
import java.sql.*;
import java.util.*;

public interface Dao&lt;T, K&gt; {

    T findOne(K key) throws SQLException;

    List&lt;T&gt; findAll() throws SQLException;

    List&lt;T&gt; findAllIn(Collection&lt;K&gt; keys) throws SQLException;

    void delete(K key) throws SQLException;
}</pre>

		<p>Nyt jokaista rajapinnan toteuttavaa luokkaa tulee muokata siten, että se toteuttaa uuden metodin. Lisätään metodin luokalle <code>PyoraDao</code> -- metodissa haetaan kaikki ne rivit, joiden alkiot ovat annetussa joukossa.</p>

<pre class="sh_java">
@Override
public List&lt;Pyora&gt; findAllIn(Collection&lt;String&gt; keys) throws SQLException {
    if (keys.isEmpty()) {
        return new ArrayList&lt;&gt;();
    }

    // Luodaan IN-kyselyä varten paikat, joihin arvot asetetaan -- 
    // toistaiseksi IN-parametrille ei voi antaa suoraan kokoelmaa
    StringBuilder muuttujat = new StringBuilder("?");
    for (int i = 1; i &lt; keys.size(); i++) {
        muuttujat.append(", ?");
    }

    Connection connection = database.getConnection();
    PreparedStatement stmt = connection.prepareStatement("SELECT * FROM Pyora WHERE rekisterinumero IN (" + muuttujat + ")");
    int laskuri = 1;
    for (String key : keys) {
        stmt.setObject(laskuri, key);
        laskuri++;
    }

    ResultSet rs = stmt.executeQuery();
    List&lt;Pyora&gt; pyorat = new ArrayList&lt;&gt;();
    while (rs.next()) {
        String rekisterinumero = rs.getString("rekisterinumero");
        String merkki = rs.getString("merkki");

        pyorat.add(new Pyora(rekisterinumero, merkki));
    }

    return pyorat;
}</pre>

		<p>Nyt VarausDaon metodia voidaan muuttaa sopivasti, jolloin taulusta Pyora haetaan vain ne rivit, jotka liittyvät varauksiin.</p>

<pre class="sh_java">
@Override
public List&lt;Varaus&gt; findAll() throws SQLException {
    Connection connection = database.getConnection();
    PreparedStatement stmt = connection.prepareStatement("SELECT * FROM Varaus");
    ResultSet rs = stmt.executeQuery();

    Map&lt;String, List&lt;Varaus&gt;&gt; varaustenPyorat = new HashMap&lt;&gt;();

    List&lt;Varaus&gt; varaukset = new ArrayList&lt;&gt;();

    while (rs.next()) {

        Integer varaustunnus = rs.getInt("varaustunnus");
        Timestamp alku = rs.getTimestamp("varaus_alkaa");
        Timestamp loppu = rs.getTimestamp("varaus_loppuu");

        Varaus v = new Varaus(varaustunnus, alku, loppu);
        varaukset.add(v);

        String pyora = rs.getString("pyora");

        if (!varaustenPyorat.containsKey(pyora)) {
            varaustenPyorat.put(pyora, new ArrayList&lt;&gt;());
        }
        varaustenPyorat.get(pyora).add(v);
    }

    rs.close();
    stmt.close();
    connection.close();

    for (Pyora pyora : this.pyoraDao.findAllIn(varaustenPyorat.keySet())) {
        for (Varaus varaus : varaustenPyorat.get(pyora.getRekisterinumero())) {
            varaus.setPyora(pyora);
        }
    }

    return varaukset;
}</pre>

		<aside class="info">
		  <br/>

		  <h1>Mitä noudetaan?</h1>

		  <p>Eikö edellisessä esimerkissä varaukseen liittyvää pyörää noudettaessa pitäisi noutaa myös pyörään liittyvät varaukset? Entä näihin varauksiin liittyvät pyörät ja varaajat?</p>

		  <p>Hyvä kysymys. Kun tietokantataulujen välisten yhteyksien perusteella tehdään uusia kyselyitä tietokantaan, olemassa on oleellisesti kaksi epätoivottua tilannetta: (1) haetaan liikaa tietoa, jolloin hakemisoperaatioon menee turhaan aikaa, tai (2) haetaan liian vähän tietoa, jolloin tieto tulee hakea myöhemmin.</p>

		  <p>Yksi tapa ratkaista ongelma on toimia siten, että tietoa haetaan vain silloin kun sitä tarvitaan. Tällöin esimerkiksi vasta Varaus-olioon mahdollisesti liittyvää <code>getPyora</code>-metodia kutsuttaessa pyörään liittyvät tiedot haettaisiin tietokannasta -- getPyora-metodi tekisi siis tietokantahaun. Tämäkään ei kuitenkaan ratkaise tilannetta, sillä jos tavoitteenamme olisi vaikkapa tulostaa kaikki varaukset ja niihin liittyvät pyörät -- edellisellä lähestymistavalla kaksi tietokantakyselyä -- saattaisi toteutus lopulta tehdä jokaisen varauksen kohdalla oman erillisen tietokantahaun.</p>

		  <p>Tähän ei ole suoraviivaista ratkaisua. Tyypillisesti Dao-rajapinnan määrittelemille metodeille kerrotaan, tuleeko haettaviin olioihin liittyvät viitteet hakea erikseen.</p>

		</aside>

		  
		<h2>Valmiit kirjastot</h2>

		<p>Nykyään markkinoilla löytyy huomattava määrä valmiita kirjastoja, jotka tarjoavat Dao-toiminnallisuuksia. Yksi tällainen kirjasto on <a href="http://ormlite.com/" target="_blank">ORMLite</a>, joka abstrahoi ja toteuttaa osan tietokantakyselyistä ohjelmoijan puolesta. ORMLite-kirjaston saa projektiin lisäämällä siihen liittyvän riippuvuuden Mavenin <code>pom.xml</code>-tiedostoon.</p>

<pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;com.j256.ormlite&lt;/groupId&gt;
    &lt;artifactId&gt;ormlite-jdbc&lt;/artifactId&gt;
    &lt;version&gt;4.48&lt;/version&gt;
&lt;/dependency&gt;
</pre>

		<p>ORMLiteä käytettäessä tietokantatauluja kuvaaville luokille lisätään annotaatiot <code>@DatabaseTable(tableName = "<em>taulun nimi</em>")</code>, jonka lisäksi oliomuuttujille lisätään <code>@DatabaseField</code>-annotaatiot, joissa määritellään sarakkeen nimi, johon oliomuuttuja liittyy. Jos oliomuuttuja on taulun pääavain, lisätään sille erillinen määrittely (id=true) annotaatioon @DatabaseField: <code>@DatabaseField(id = true, columnName = "<em>sarakkeen nimi</em>")</code>.</p>

		<p>Käytännössä ORMLite osaa luoda olioita tietokannasta haettavista riveistä annotaatioiden perusteella. Jokaisessa tietokantataulua kuvaavassa tulee olla myös tyhjä konstruktori. Luokka <code>Pyora</code> ORMLite-annotaatioilla olisi esimerkiksi seuraavanlainen (tässä pyörään liittyviä varauksia ei ole otettu huomioon):</p>

<pre class="sh_java">
import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.table.DatabaseTable;

@DatabaseTable(tableName = "Pyora")
public class Pyora {

    @DatabaseField(id = true, columnName = "rekisterinumero")
    private String rekisterinumero;
    @DatabaseField(columnName = "merkki")
    private String merkki;

    // jokaisella tallennettavalla oliolle tulee olla parametriton konstruktori
    public Pyora() {
    }

    public Pyora(String rekisterinumero, String merkki) {
        this.rekisterinumero = rekisterinumero;
        this.merkki = merkki;
    }

// getterit ja setterit
}</pre>

                <aside class="info">
		  <br/>
		  <h1>@DatabaseField</h1>
		  
		  <p>Jos tietokannassa olevan sarakkeen nimi on sama kuin oliomuuttujan nimi, voidaan annotaatiosta <code>@DatabaseField</code> jättää <code>columnName</code>-määrittely pois. Tietokantataulun sarakkeet, jotka ovat muotoa <code>sarakkeen_nimi</code> tulee olla määriteltynä <em>camelCase</em>-muodossa oliomuuttujina. Sarake <code>sarakkeen_nimi</code> olisi siis oliomuuttujana muotoa <code>sarakkeenNimi</code>.</p>

		</aside>



		<p>Nyt kaikkien pyörien hakeminen tietokannasta onnistuu seuraavasti. Huom! Käytössä on ORMLiten tarjoama Dao-rajapinta -- emme siis kirjoita erikseen ohjelmakoodia kyselyiden tulosten muuttamiseksi olioiksi.</p>

<pre class="sh_java">
Class.forName("org.sqlite.JDBC");
ConnectionSource connectionSource
        = new JdbcConnectionSource("jdbc:sqlite:vuokraamo.db");

Dao&lt;Pyora, String&gt; pyoraDao
        = DaoManager.createDao(connectionSource, Pyora.class);

List&lt;Pyora&gt; pyorat = pyoraDao.queryForAll();
for (Pyora pyora : pyorat) {
    System.out.println(pyora.getMerkki() + " " + pyora.getRekisterinumero());
}</pre>

		<p>Käytännössä ORMLite lukee luokkaan määritellyt annotaatiot, ja tekee niiden perusteella käytettävät tietokantakyselyt, joita ohjelmoija käyttää ORMLiten toteuttaman Dao-rajapinnan kautta.</p>

		<p><strong><em>Viitteiden käsittely</em></strong></p>

		<p>Osoitteessa <a href="http://ormlite.com/javadoc/ormlite-core/doc-files/ormlite_2.html" target="_blank">http://ormlite.com/javadoc/ormlite-core/doc-files/ormlite_2.html</a> oleva ORMLiten "How to Use"-dokumentaatio sisältää neuvoja ORMLiten käyttöön. Lisätään seuraavaksi toiminnallisuus pyörien hakemiseen Varaus-luokan kautta. Annotaatioiden määrittely tapahtuu kuten Pyora-luokalle, mutta viittausta pyörään määriteltäessä annotaatiolle <code>@DatabaseField</code> tulee kertoa, että sarake viittaa toiseen tauluun, ja että viitatusta taulusta tulee hakea oliolle arvo. Tämä tapahtuu lisäämällä annotaatioon parametrit <code>foreign = true</code> ja <code>foreignAutoRefresh = true</code>. Tämän lisäksi, myös viitattuun tauluun tulee lisätä annotaatiot.</p>

<pre class="sh_java">
@DatabaseTable(tableName = "Varaus")
public class Varaus {

    @DatabaseField(id = true)
    private Integer varaustunnus;
    @DatabaseField(columnName = "pyora", canBeNull = false, foreign = true, foreignAutoRefresh = true)
    private Pyora pyora;
    private Varaaja varaaja;
    @DatabaseField(columnName = "varaus_alkaa")
    private Timestamp varausAlkaa;
    @DatabaseField(columnName = "varaus_loppuu")
    private Timestamp varausLoppuu;

    public Varaus() {
    }

// konstruktorit, getterit, setterit
</pre>

		<p>Ylläolevassa esimerkissä Varaus-luokka on määritelty siten, että se liittyy tietokantatauluun Varaus. Sillä on lisäksi kenttä pyora, joka viittaa tauluun, johon Pyora-luokka liittyy. Luokalle Varaaja ei ole määritelty toiminnallisuutta.</p>

		<p>Varauksiin liittyvien pyörien tulostaminen onnistuu nyt seuraavasti:</p>

<pre class="sh_java">
Class.forName("org.sqlite.JDBC");
ConnectionSource connectionSource
        = new JdbcConnectionSource("jdbc:sqlite:vuokraamo.db");

Dao&lt;Varaus, String&gt; varausDao
        = DaoManager.createDao(connectionSource, Varaus.class);

List&lt;Varaus&gt; varaukset = varausDao.queryForAll();
for (Varaus varaus : varaukset) {
    System.out.println(varaus.getPyora().getRekisterinumero() + ", alkaa " + varaus.getVarausAlkaa());
}</pre>


		<aside class="info">
		  <br/>

		  <h1>Java Persistence API ja Hibernate</h1>
		  
		  <p>Vastaavia toimintoja tarjoavia kirjastoja on huomattava määrä, ja Javalle on määritelty myös standardi näille kirjastoille. Javalle määritellyn standardin nimi on <em>Java Persistence API</em>, ja se määrittelee notaation luokkien annotoinnille ja kyselyiden kirjoittamiselle.</p>

		  <p>Valitsemamme ORMLite-kirjasto tarjoaa pienen määrän toiminnallisuutta, mutta kuitenkin samalla oleelliset osat on toteutettu melko hyvin. Jos toiminnallisuutta kaipaa enemmän, voi käyttöön valita esimerkiksi <a href="http://hibernate.org/" target="_blank">Hibernaten</a>, joka on ehkäpä eniten käytetty vastaavaa toiminnallisuutta tarjoava Java-kirjasto.</p>
		</aside>
		  




		<header>
		  <h1 id="viikko5">Viikko 5</h1>
		</header>

		<h1>Tietokantataulujen luominen ja muokkaaminen</h1>

		<p>Tähän mennessä tietokantataulut ovat olleet valmiiksi annettuna, eikä meidän ole tarvinnut pohtia niiden luomista. Tehdään korjausliike, ja tutustutaan tietokantataulujen -- ja sitä kautta -- oman tietokannan rakenteen määrittelyyn ja luomiseen.</p>

		<h2>Tietokantataulun luominen</h2>

		<p>Tietokantataulu luodaan SQL-komennolla <code>CREATE TABLE</code>, jota seuraa luotavan taulun nimi, ja suluissa attribuuttien eli sarakkeiden nimet sekä niiden tyypit pilkulla eroteltuna. Tyyppien määrittely ei ole kaikissa tietokannanhallintajärjestelmissä pakollista, jolloin tietokannanhallintajärjestelmä käyttää mahdollista oletustyyppiä.</p>

		<p>Luodaan aiemmin tutuksi tullut Opiskelija-taulu.</p>
		
		<div class="data-table">
		  <h4>Opiskelija</h4>
		  <table class="table">
		    <thead>
		      <tr>
			<th>opiskelijanumero</th>
			<th>nimi</th>
			<th>syntymävuosi</th>
			<th>pääaine</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>9999999</td>
			<td>Pihla</td>
			<td>1997</td>
			<td>Tietojenkäsittelytiede</td>
		      </tr>
		      <tr>
 			<td>9999998</td>
			<td>Joni</td>
			<td>1993</td>
			<td>Tietojenkäsittelytiede</td>
		      </tr>
		    </tbody>
		  </table>
		</div>
		
		
                <p>Taulu opiskelija saadaan luotua SQL-komennolla <code>CREATE TABLE Opiskelija (opiskelijanumero, nimi, syntymävuosi, pääaine)</code> -- emme ota vielä kantaa sarakkeiden tietotyyppeihin, vaan määrittelemme vain nimet. Tällöin tietokannanhallintajärjestelmä ottaa vastuun sarakkeiden tyyppien asettamisesta -- jos se on mahdollista. </p>
		
		<div ng-controller="noTablesSqlController">
		  
		  <togglable content="taulut" db="db">
		    <table-info></table-info>
		  </togglable>
		  
		  <query
		     editable="false"
		     done="tableOpiskelijaWasCreated"
		     db="db"
		     rows="3"
		     query="CREATE TABLE Opiskelija (opiskelijanumero, nimi, syntymävuosi, pääaine)">
		  </query>
		  
		  
		  <div ng-show="tableOpiskelijaWasCreated">
		    
		    <p>Juuri luotuun tauluun saa lisättyä uusia rivejä komennolla <code>INSERT INTO</code>, jota seuraa taulun nimi, sarakkeet suluissa eroteltuna, sekä uudelle riville asetettavat arvot.</p>
		    
		    <query
		       db="db"
		       rows="3"
		       query="INSERT INTO Opiskelija (opiskelijanumero, nimi, syntymävuosi, pääaine) 
    VALUES ('01283581', 'Jack Bower', 1983, 'Tietojenkäsittelytiede')"
		       done="opiskelijaAddedToTableOpiskelija">
		    </query>
		  </div>
		  
		  <div ng-show="opiskelijaAddedToTableOpiskelija">
		    <p>Luodussa taulussa olevan tiedon hakeminen tapahtuu kuten ennenkin.</p>
		    
		    <query
		       db="db"
		       rows="3"
		       query="SELECT * FROM Opiskelija">
		    </query>
		  </div>
		  
		  
		  <p><strong><em>Kurssi-taulun luominen</em></strong></p>
		  
		  <p>Luo tietokantaan taulu <code>Kurssi</code>, jolla on sarakkeet <code>kurssitunnus</code>, <code>nimi</code> ja <code>kuvaus</code>.</p>
		  
		  
		  <togglable content="taulut" db="db">
		    <table-info></table-info>
		  </togglable>
		  
		  <query
		     db="db"
		     rows="3"
		     done="tableKurssiWasCreated">
		  </query>
		  
		  <div ng-show="tableKurssiWasCreated">
		    <p>Lisää nyt tauluun Kurssi kurssi nimeltä "SQL-kielen perusteet", jonka kurssitunnus on "12345" ja kuvaus "SELECT 'Hei maailma';".</p>
		    
		    <query
		       db="db"
		       rows="3"
		       done="newCourseWasInserted">
		    </query>
		    
		  </div>
		  
		  <div ng-show="newCourseWasInserted">
		    
		    <p>Tarkista vielä, että taulun luominen onnistui, ja että uusi kurssi löytyy tietokantataulusta.</p>
		    
		    <query
		       db="db"
		       rows="3">
		    </query>
		    
		  </div>
		  
		  
		  
		  <aside class="info">
		    <br/>
		    <h1>Olemassaolevien taulujen listaaminen ja poisto</h1>
		    
		    <p>Tietokannanhallintajärjestelmät tyypillisesti tarjoavat mahdollisuuden olemassaolevien tietokantataulujen listaamiseen. Tämä toiminnallisuus on kuitenkin järjestelmäkohtaista -- esimerkiksi tässä materiaalissa käyttämässämme SQLite-versiossa taulujen tiedot löytyvät piilotetusta tietokantataulusta <code>sqlite_master</code>.</p>
		    
		    <query
		       db="db"
		       rows="2"
		       query="SELECT * FROM sqlite_master">
		    </query>


		    <p>Olemassaolevan taulun poistaminen -- esimerkiksi silloin jos sen nimen on kirjoittanut väärin, onnistuu komennolla <code>DROP TABLE</code>, mitä seuraa taulun nimi. Voit kokeilla sitä seuraavassa -- näet poistuiko tietokantataulu kyselyn <code>SELECT * FROM sqlite_master</code> avulla.</p>

		    <query
		       db="db"
		       rows="2">
		    </query>
		    
		  </aside>
		</div>

		
		<h2>Attribuuttien datatyypit</h2>
		
                <p>Jokaisella attribuutilla tulee olla nimi sekä datatyyppi. Jos datatyyppiä ei määritellä, voi tietokannanhallintajärjestelmä määritellä sen itse -- esimerkiksi SQLite pyrkii päättelemään attribuutin tyypin dynaamisesti, mutta useimmat tietokannanhallintajärjestelmät eivät tällaista päättelyä tee.</p>

		<p>Tietokantaan säilöttävä tieto voi olla montaa eri muotoa, esimerkiksi merkkijonoja, numeroita, binäärimuodossa olevia tiedostoja, sekä päivämääriä. Tietokannan suunnittelijan tehtävänä on päättää, minkämuotoista dataa missäkin sarakkeessa on.</p>

                <p>Puhekielessä voidaan puhua sarakkeen tyypistä, sillä sarakkeen tyyppi määrää millaista tietoa sarakkeeseen tallennetaan. Käytännössä tietokantataulua luotaessa sarakkeen määrittelyssä annettavat tiedot kertovat tietokannanhallintajärjestelmälle siitä, että minkälaista tietoa sarakkeeseen voidaan lisätä, ja toisaalta samalla minkälaista tietoa sarakkeeseen ei voida lisätä. Sarakkeen tyyppi vaikuttaa myös toiminnallisuuksiin -- esimerkiksi keskiarvon laskeminen merkkijonotyyppisiä arvoja sisältävästä sarakkeesta ei todennäköisesti ole hyödyllistä.</p>

		<p>Tyypilliset datatyypit ovat seuraavat:</p>

		<ul>
		  <li><strong>varchar(n)</strong> korkeintaan <em>n</em> merkin pituinen merkkijono.</li>
		  <li><strong>integer</strong> kokonaisluku</li>
		  <li><strong>float</strong> liukuluku eli desimaaliluku</li>
		  <li><strong>date</strong> päivämäärä, tallentaa vuoden, kuukauden ja päivän</li>
		  <li><strong>timestamp</strong> aikaleima, tallentaa vuoden, kuukauden, päivän, tunnit, minuutit ja sekunnit -- mahdollisesti myös tarkempia arvoja</li>
		</ul>
		
                <p>Taulua luodessa sarakkeen tyyppi määritellään lisäämällä datatyypin nimi sarakkeen nimen perään. Esimerkiksi Opiskelija-taulua luodessa opiskelijanumero voitaisiin määritellä kokonaisluvuksi, nimi korkeintaan 200 merkkiä pitkäksi merkkijonoksi, syntymävuosi päivämääräksi ja pääaine korkeintaan 50 merkkiä pitkäksi merkkijonoksi seuraavasti:</p> 

<pre class="sh_sql">
CREATE TABLE Opiskelija 
(
    opiskelijanumero integer, 
    nimi varchar(200), 
    syntymävuosi date, 
    pääaine varchar(50)
)
</pre>

                <p>Nyt -- riippuen käytetystä tietokannanhallintajärjestelmästä -- sarakkeeseen opiskelijanumero ei voisi esimerkiksi lisätä merkkijonoa, sillä se on kokonaisluku. Tämä johtaa tilanteeseen, missä tietokannanhallintajärjestelmä itsessään varoittaa tiedon lisääjää yksinkertaisista virheistä.</p>


		<aside class="info">
		  <br/>
		  
		  <h1>Olemassaolevien attribuuttien datatyypin selvittäminen</h1>


		  <p>Attribuutin -- tai sarakkeen -- datatyypin kysymiseen tietokannalta <a href="http://stackoverflow.com/questions/13405572/sql-statement-to-get-column-type" target="_blank">ei ole yhtä tapaa</a>, vaan tapa liittyy käytettävään tietokannanhallintajärjestelmään. Käyttämässämme SQLite-versiossa sarakkeen tyypin saa selville kyselyllä <code>PRAGMA TABLE_INFO(<em>TaulunNimi</em>)</code>, missä <em>TaulunNimi</em> on tarkasteltavan taulun nimi.</p>

		  <div ng-controller="noTablesSqlController">
		    
		    <p>Luo ensin tarkasteltava tietokantataulu.</p>

		    <query
		       db="db"
		       rows="3"
		       done="tableCreated">
		    </query>

		    <div ng-show="tableCreated">


		      <togglable content="taulut" db="db">
			<table-info></table-info>
		      </togglable>
		      
		      <p>Kun tietokantataulu on luotu, saat tarkasteltua sen sisältöä <code>PRAGMA</code>-komennolla.</p>

		      <query
			 db="db"
			 rows="3"
			 query="PRAGMA TABLE_INFO(LuodunTaulunNimi)">
		      </query>
		    </div>
		    
		  </div>
		</aside>


                <p><strong><em>Kurssi-taulun luominen sarakkeiden tyypeillä</em></strong></p>
					    
		<p>Luo taulu <code>Kurssi</code>, jolla on sarakkeet <code>kurssitunnus</code>, <code>nimi</code> ja <code>kuvaus</code>. Kurssitunnuksen tulee olla kokonaisluku, nimen merkkijono, ja kuvauksen merkkijono.</p>


		<div ng-controller="noTablesSqlController">

		  <query
		     db="db"
		     rows="3"
		     done="tableCreated">
		  </query>

		  <div ng-show="tableCreated">
		    
		    
		    <togglable content="taulut" db="db">
		      <table-info></table-info>
		    </togglable>
		    
		    <p>Varmista vielä PRAGMA-komennolla, että sarakkeiden tyypit ovat halutut.</p>
		    
		    <query
		       db="db"
		       rows="3">
		    </query>
		  </div>
		</div>


		<aside class="info">
		  <br/>
		  <h1>Tietokannanhallintajärjestelmien datatyyppejä</h1>

		  <p>Eri tietokannanhallintajärjestelmät kuten <code>SQLite</code>, <code>MySQL</code> ja <code>PostgreSQL</code> tarjoavat hieman erilaisia datatyyppejä ohjelmoijan käyttöön. Tutustu seuraaviin dokumentteihin, missä näistä kerrotaan enemmän:</p>


		  <ul>
		    <li><a href="https://www.sqlite.org/datatype3.html" target="_blank">https://www.sqlite.org/datatype3.html</a></li>
		    <li><a href="http://www.w3schools.com/sql/sql_datatypes.asp" target="_blank">http://www.w3schools.com/sql/sql_datatypes.asp</a></li>
		  </ul>
		</aside>


		<h2>Rajoitteet ja avaimet</h2>

		<p>Kun olemme aiemmin luoneet tietokantakaavioita käsitekaavioista, olemme määritelleet tietokantatauluille yksilöivän <em>pääavaimen</em>. Pääavain on taulukohtainen tunniste, joka on uniikki jokaiselle taulun riville, jonka lisäksi sen arvo ei saa olla tyhjä (<em>null</em>) millään rivillä. Pääavaimeksi valitaan joko olemassaoleva taulun sarake, tai tauluun luodaan uusi sarake.</p>

		<p><strong><em>Pääavaimen määrittely</em></strong></p>

		<p>Pääavain määritellään tietokantataulun luonnin yhteydessä lisäämällä sarakkeen tyypin perään rajoite <code>PRIMARY KEY</code>. Tämä tarkoittaa, että sarakkeen arvo on uniikki, ja että se ei saa koskaan olla tyhjä. Täydennetään aiempaa opiskelijan määrittelyä siten, että opiskelijanumerosta tehdään Opiskelija-taulun pääavain</p>


<pre class="sh_sql">
CREATE TABLE Opiskelija 
(
    opiskelijanumero integer PRIMARY KEY, 
    nimi varchar(200), 
    syntymävuosi date, 
    pääaine varchar(50)
)
</pre>


		<div ng-controller="noTablesSqlController">
		  
		  <p>Kokeillaan edelläolevaa komentoa käytännössä.</p>

		  <query
		     db="db"
		     rows="7"
		     done="tableCreated"
		     editable="false"
		     query="CREATE TABLE Opiskelija 
(
    opiskelijanumero integer PRIMARY KEY, 
    nimi varchar(200), 
    syntymävuosi date, 
    pääaine varchar(50)
)">
		  </query>

		  <div ng-show="tableCreated">
		  		    
		    <togglable content="taulut" db="db">
		      <table-info></table-info>
		    </togglable>
		    
		    <p>Lisätään seuraavaksi tietokantatauluun uusi opiskelija nimeltä <code>Ada Lovelace</code>. Seuraavalla komennolla vain tietokantataulun kenttään <code>nimi</code> asetetaan arvo.</p>
		    
		    <query
		       db="db"
		       rows="3"
		       query="INSERT INTO Opiskelija (nimi) VALUES ('Ada Lovelace')"
		       done="studentInserted">
		    </query>
		  </div>

		  <div ng-show="studentInserted">
		    <p>Listaa nyt taulussa olevat opiskelijat. Mitä huomaat jos opiskelijoita lisätään tietokantatauluun enemmän?</p>

		    <query
		       db="db"
		       rows="3"
		       query="SELECT * FROM Opiskelija"
		       done="studentsListed">
		    </query>
		  </div>

		  <div ng-show="studentsListed">
		    <p>Koska tietokantatauluun on määritelty avain, joka on uniikki, ei taulun sarakkeessa <code>opiskelijanumero</code> voi olla kahta samaa arvoa. Kokeile tätä painamalla alla olevaa nappia ensin kerran -- jolloin opiskelija lisätään -- ja sitten vielä toisen kerran. Mitä virheviesti kertoo?</p> 

		    <query
		       db="db"
		       rows="3"
		       query="INSERT INTO Opiskelija (opiskelijanumero, nimi)
    VALUES (999, 'Beezow Doo-Doo Zopittybop-Bop-Bop')">
		    </query>

		  </div>

		</div>


		<aside class="info">

		  <br/>

		  <h1>Pääavaimen arvojen automaattinen luonti</h1>

		  <p>Tietyt tietokannanhallintajärjestelmät tarjoavat tuen automaattiselle pääavaimen arvojen luomiselle. Esimerkiksi SQLite luo automaattisesti kokonaislukutyyppiselle sarakkeelle arvoja, jos sarake on määritelty pääavaimeksi, ja ohjelmoija ei tauluun tietoa lisätessään arvoja erikseen määrittele. Vastaava toiminnallisuus löytyy myös useista muista tietokannanhallintajärjestelmistä -- tutustu esimerkiksi <a href="https://mariadb.com/kb/en/mariadb/auto_increment/" target="_blank">MariaDB:n dokumentaatioon asiasta</a>.</p>

		</aside>

                <p><strong><em>Kurssi-taulun luominen sarakkeiden tyypeillä ja pääavaimella</em></strong></p>
					    
		<p>Luo taulu <code>Kurssi</code>, jolla on sarakkeet <code>kurssitunnus</code>, <code>nimi</code> ja <code>kuvaus</code>. Kurssitunnuksen tulee olla kokonaisluku, nimen merkkijono, ja kuvauksen merkkijono. Tämän lisäksi, kurssitunnuksen tulee olla pääavain.</p>


		<div ng-controller="noTablesSqlController">

		  <query
		     db="db"
		     rows="6"
		     done="tableCreated">
		  </query>

		  <div ng-show="tableCreated">
		    
		    
		    <togglable content="taulut" db="db">
		      <table-info></table-info>
		    </togglable>
		    
		    <p>Seuraavan kyselyn useampaan otteeseen suorittamisen pitäisi epäonnistua, sillä tietokantataulun kurssitunnus-sarakkeen pitäisi olla olla pääavain, ja sen takia uniikki. </p>
		    
		    <query
		       db="db"
		       rows="3"
		       query="INSERT INTO Kurssi (kurssitunnus, nimi) VALUES (42, 'Meaning of Life')">
		    </query>
		  </div>
		</div>


                <p>Jokaisella taululla voi olla vain yksi määritelty pääavain. Joskus kuitenkin haluamme, että pääavain liittyy useampaan sarakkeeseen, jolloin sarakkeiden yhdistelmän tulee olla uniikki. Voimme esimerkiksi haluta rajoittaa opiskelijoiden kurssi-ilmoittautumisia siten, että jokainen opiskelija voi ilmoittautua vain kerran tietylle kurssille. Tämä onnistuisi kuvitteellisen <em>KurssiIlmoittautuminen</em>-taulun kautta siten, että taulun pääavaimena toimisi opiskelijanumeron ja kurssin yhdistelmä.</p>

<pre class="sh_sql">
CREATE TABLE KurssiIlmoittautuminen
(
    opiskelijanumero integer, 
    kurssi integer,
    PRIMARY KEY (opiskelija, kurssi)
)
</pre>

                <p>Nyt taulussa KurssiIlmoittautuminen voi olla vain yksi samanlainen <code>opiskelijanumero</code>-<code>kurssi</code> -arvopari, jolloin opiskelija voi ilmoittautua kurssille vain kerran.</p>



		<aside class="info">
		  <br/>
		  <h1>Pääavaimen valinta.</h1>

		  <p>Tietokantataulun pääavaimen valinta on herättänyt paljon keskustelua. Alla on muutamia linkkejä teemaan liittyen:</p>

		  <ul>
		    <li><a href="http://www.techrepublic.com/article/the-great-primary-key-debate/" target="_blank">The great primary key debate</a></li>
		    <li><a href="http://www.agiledata.org/essays/keys.html" target="_blank">Choosing a primary key: Natural or surrogate?</a></li>
		    <li><a href="http://dba.stackexchange.com/questions/10383/sql-server-primary-keys-advice-to-my-whitepaper-needed" target="_blank">Tips for explaining primary keys to junior developers?</a></li>
		  </ul>
		</aside>

		<p><strong><em>Uniikkius ja arvon pakollinen määrittely</em></strong></em>

                <p>Tietokantataulun sarakkeille voidaan määritellä myös muita rajoitteita, kuten se, että sarakkeen arvon tulee olla uniikki, tai että sarakkeessa on pakko olla arvo. Sarakkeen uniikkius määritellään komennolla <code>UNIQUE</code>, joka seuraa tyyppiä. Vastaavasti se, että sarakkeessa on pakko olla arvo määritellään komennolla <code>NOT NULL</code>.</p>

		<p>Jos haluamme esimerkiksi lisätä Opiskelija-tauluun rajoitteet, missä määritellään se, että nimeä ja syntymäaikaa ei saa jättää määrittelemättä, lisätään niihin <code>NOT NULL</code> määreet.</p>

<pre class="sh_sql">
CREATE TABLE Opiskelija 
(
    opiskelijanumero integer PRIMARY KEY, 
    nimi varchar(200) NOT NULL, 
    syntymävuosi date NOT NULL, 
    pääaine varchar(50)
)
</pre>

                <p>Toisaalta, jos määrittelisimme ylläolevan lisäksi säännöt, joiden mukaan nimen ja syntymävuoden tulisi olla uniikkeja, olisi määrittely seuraava.</p>

<pre class="sh_sql">
CREATE TABLE Opiskelija 
(
    opiskelijanumero integer PRIMARY KEY, 
    nimi varchar(200) NOT NULL UNIQUE, 
    syntymävuosi date NOT NULL UNIQUE, 
    pääaine varchar(50)
)
</pre>

                <p>Tämä ei kuitenkaan olisi kovin fiksua, sillä yllä määriteltävässä taulussa yhdelläkään opiskelijalla ei saisi olla samaa nimeä jonkun toisen kanssa. Vastaavasti, sama syntymävuosi (tai aika) johtaisi virhetilanteeseen.</p> 

 
		<aside class="info">
		  <br/>
		  <h1>CHECK</h1>

		  <p>Edellämainittujen rajoitteiden lisäksi käytössä on mm. rajoite <code>CHECK</code>, jonka avulla voidaan rajoittaa arvoja esimerkiksi tietylle arvovälille. Voimme esimerkiksi luoda Opiskelija-tauluun säännön, jonka mukaan jokaisen opiskelijanumeron tulee olla suurempi kuin 0.</p>

<pre class="sh_sql">
CREATE TABLE Opiskelija 
(
    opiskelijanumero integer PRIMARY KEY CHECK (opiskelijanumero &gt; 0), 
    nimi varchar(200) NOT NULL, 
    syntymävuosi date NOT NULL, 
    pääaine varchar(50)
)
</pre>

                  <p>Rajoitteet voidaan määritellä myös sarakemäärittelyiden jälkeen. Tämä on näppärää esimerkiksi silloin, jos rajoitteita on useampia. Tehdään erillinen tarkistus, joss varmistetaan, että jokainen nimi on yli 2 merkkiä pitkä, ja opiskelijanumero on aina suurempi kuin 0.</p>

<pre class="sh_sql">
CREATE TABLE Opiskelija 
(
    opiskelijanumero integer PRIMARY KEY, 
    nimi varchar(200) NOT NULL, 
    syntymävuosi date NOT NULL, 
    pääaine varchar(50),
    CONSTRAINT <em>saannonNimi</em> CHECK (opiskelijanumero &gt; 0 AND LENGTH(nimi) &gt; 2)
)
</pre>

		  <p><em>Funktion <code>LENGTH</code> kirjoitusasu riippuu järjestelmästä, esimerkiksi MySQL:ssä se kirjoitetaan muodossa <code>LEN</code>.</em></p>

		</aside>



		<p><strong><em>Viiteavainten määrittely</em></strong></p>

		<aside class="info">
		  <br/>
		  <h1>SQLite ja viiteavaimet</h1>

		  <p>Käytössämme olevan SQLiten kolmosversiossa viiteavaimiin liittyvät tarkistukset ovat oletuksena poissa päältä. Tarkastukset saadaan päälle seuraavalla komennolla:</p>

		  <pre class="sh_sql">PRAGMA foreign_keys = ON;</pre>

		  <p>Oletamme, että komento on suoritettu.</p>

		</aside>

                <p>Tietokantataulujen viiteavaimet ovat sarakkeita, joissa olevat arvot viittaavat toisissa tauluissa oleviin pääavaimiin. Tietokantataulua määriteltäessä viiteavaimet listataan sarakkeiden määrittelyn jälkeen. Jokaisen viiteavaimen yhteydessä kerrotaan sekä luotavan taulun sarake -- eli sarake, joka on viiteavain -- että taulu ja sarake, johon viiteavaimella viitataan. Viiteavaimen määrittely tapahtuu komennolla <code>FOREIGN KEY(<em>sarake</em>) REFERENCES <em>ViitattavaTaulu(viitattavaSarake)</em></code>.</p>

		<p>Jos tietokantataulut Opiskelija ja Kurssi ovat määritelty seuraavasti:</p>

<pre class="sh_sql">
CREATE TABLE Opiskelija 
(
    opiskelijanumero integer PRIMARY KEY, 
    nimi varchar(200) NOT NULL, 
    syntymävuosi date NOT NULL, 
    pääaine varchar(50)
);

CREATE TABLE Kurssi 
(
    kurssitunnus integer PRIMARY KEY, 
    nimi varchar(200) NOT NULL, 
    kuvaus varchar(3000)
);</pre>

                <p>Voidaan taulu kurssisuoritus, joka viittaa sekä opiskelijaan, että kurssiin, määritellä seuraavasti.</p>

<pre class="sh_sql">
CREATE TABLE Kurssisuoritus 
(
    opiskelija integer NOT NULL,
    kurssi integer NOT NULL,
    päivämäärä date NOT NULL,
    arvosana integer NOT NULL,
    opintopistemäärä integer NOT NULL,
    FOREIGN KEY(opiskelija) REFERENCES Opiskelija(opiskelijanumero),
    FOREIGN KEY(kurssi) REFERENCES Kurssi(kurssitunnus)
);
</pre>

 		<p>Viiteavaimet ovat siis sarakkeita siinä missä muutkin sarakkeet, mutta niille määritellään eriseen rajoitteet, jotka kertovat, että ne ovat viiteavaimia. Taulussa käytettävien viiteavainten määrä ei käytännössä ole rajattu -- voi olla, että niitä ei ole yhtäkään, tai niitä voi olla useita. Yllä viiteavainsarakkeille <code>opiskelija</code> ja <code>kurssi</code> on lisäksi määritelty <code>NOT NULL</code>-rajoitteet, joiden avulla määritellään että sarakkeiden arvot eivät saa jäädä tyhjiksi.</p>

		<div ng-controller="noTablesSqlController">

		  <p>Kokeillaan edellä nähtyä käytännössä. Luodaan ensin tietokantataulut Opiskelija ja Kurssi, sekä lisätään niihin muutama rivi.</p>

		  <query
		     db="db"
		     rows="20"
		     editable="false"
		     query="PRAGMA foreign_keys = ON;

CREATE TABLE Opiskelija (
    opiskelijanumero integer PRIMARY KEY, 
    nimi varchar(200) NOT NULL, 
    syntymävuosi date NOT NULL, 
    pääaine varchar(50)
);

CREATE TABLE Kurssi (
    kurssitunnus integer PRIMARY KEY, 
    nimi varchar(200) NOT NULL, 
    kuvaus varchar(3000)
);

INSERT INTO Opiskelija (nimi, syntymävuosi) VALUES ('Ada', '1997');
INSERT INTO Opiskelija (nimi, syntymävuosi) VALUES ('Pihla', '1998');
INSERT INTO Kurssi (nimi) VALUES ('Ohpe');
INSERT INTO Kurssi (nimi) VALUES ('Tikape');"
		     done="tablesCreated">
		  </query>

		  <div ng-show="tablesCreated">

		    <p>Nyt käytössämme on taulut Opiskelija ja Kurssi, jonka lisäksi niissä on kummassakin muutama rivi. Luodaan seuraavaksi taulu Kurssisuoritus, jossa on viiteavaimet kumpaankin edellä mainuttuun tauluun.</p>


		    <togglable content="taulut" db="db">
		      <table-info></table-info>
		    </togglable>
		    
		    <query
		       db="db"
		       rows="10"
		       editable="false"
		       query="CREATE TABLE Kurssisuoritus 
(
    opiskelija integer NOT NULL,
    kurssi integer NOT NULL,
    päivämäärä date NOT NULL,
    arvosana integer NOT NULL,
    opintopistemäärä integer NOT NULL,
    FOREIGN KEY(opiskelija) REFERENCES Opiskelija(opiskelijanumero),
    FOREIGN KEY(kurssi) REFERENCES Kurssi(kurssitunnus)
);"
		       
		       done="kurssisuoritusCreated">
		    </query>
		  </div>


		  <div ng-show="kurssisuoritusCreated">
		    
		    <p>Nyt käytössä on tietokantataulut Opiskelija, Kurssi, ja Kurssisuoritus. Kurssisuoritus-taulussa on kaksi viiteavainta -- toinen viittaa tauluun Opiskelija, ja toinen tauluun Kurssi. Tutki ensin taulujen Opiskelija ja Kurssi sisältöjä, ja lisää sen jälkeen tauluun Kurssisuoritus suoritusmerkintä kurssista Tikape opiskelijalle Ada. Voit kokeilla ensin mitä tapahtuu, jos et aseta viiteavaimia oikein.</p>
		    
		    <query
		       db="db"
		       rows="3">
		    </query>
		  </div>
		</div>

		<p><strong><em>Tehtävän ja Kurssitehtävän lisääminen.</em></strong></p>

                <p>Harjoitellaan edellä nähtyjä asioita vielä hieman. Käytämme pohjana viikolta 3 tuttua tietokantakaaviota.</p>

		<figure>
		  <img src="img/viikko3/tietokantakaavio-tehtavasuorituksella.png" alt="[Opiskelija|(pk) opiskelijanumero;nimi;syntymävuosi;pääaine]1-*[Kurssisuoritus|(fk) opiskelija: Opiskelija;(fk) kurssi: Kurssi;päivämäärä;arvosana;opintopistemäärä]
[Kurssisuoritus]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]
[Tehtävä|(pk) tunnus;nimi;kuvaus]1-*[Kurssitehtävä|(pk) tunnus; (fk) tehtävä: Tehtävä; (fk) kurssi: Kurssi]
[Kurssitehtävä]*-1[Kurssi|(pk) kurssitunnus;nimi;kuvaus]
[Tehtäväsuoritus|(fk) opiskelija: Opiskelija; (fk) tehtävä: Kurssitehtävä; suoritusaika]
[Tehtäväsuoritus]*-1[Opiskelija]
[Tehtäväsuoritus]*-1[Kurssitehtävä]"/>

		</figure>

                <p></p>

		<hr/>

                <p>Alla olevaan kyselylaatikkoon on määritelty kysely, minkä avulla luodaan tietokantataulu Kurssi sekä lisätään sinne kurssit Ohpe ja Tikape.</p>

		<div ng-controller="noTablesSqlController">
		  
		  <query
		     db="db"
		     rows="11"
		     editable="false"
		     query="PRAGMA foreign_keys = ON;

CREATE TABLE Kurssi (
    kurssitunnus integer PRIMARY KEY, 
    nimi varchar(200) NOT NULL, 
    kuvaus varchar(3000)
);

INSERT INTO Kurssi (nimi) VALUES ('Ohpe');
INSERT INTO Kurssi (nimi) VALUES ('Tikape');"
		     done="tablesCreated">
		  </query>
		  
		  <div ng-show="tablesCreated">

		    <p>Toteuta nyt taulut Kurssitehtävä ja Tehtävä siten, että niissä on määriteltynä sekä pääavaimet että viiteavaimet. Pohdi, missä järjestyksessä taulut tulee toteuttaa, jotta saat viiteavaimet määriteltyä oikein.</p>


		    <togglable content="taulut" db="db">
                      <table-info></table-info>
		    </togglable>
		    

		    <query
		       db="db"
		       rows="9"
		       query=""
		       done="kurssiTehtavaAndTehtavaCreated">
		    </query>
		  </div>

		  <div ng-show="kurssiTehtavaAndTehtavaCreated">

		    <p>Lisää nyt Tehtävä-tauluun muutama rivi, ja määrittele olemassaoleville kursseille muutamia tehtäviä.</p>

		    <query
		       db="db"
		       rows="4">
		    </query>
		  </div>
		</div>


		<h2>Hakuja nopeuttavat indeksirakenteet</h2>

		<p>Tietokantatauluun kohdistuvissa kyselyissä hakua rajataan ehdoilla. Esimerkiksi kysely <code>SELECT * FROM <em>Taulu</em> WHERE <em>sarake</em> = 'haluttu'</code>, hakee kaikki taulussa olevat rivit, joissa annetun sarakkeen arvo on 'haluttu'. Oletuksena kysely tietokantamoottori käy läpi kaikki rivit, ja valitsee niistä vain ne, joissa rivin arvo on haluttu. Jos rivejä on vaikkapa 100 miljoonaa, käydään niistä jokainen yksitellen läpi, mikä ei ole kovin tehokasta.</p>

		<p>Tietokantakyselyiden tehostamista on tutkittu paljon, ja tietokantamoottorit tarjoavat tyypillisesti erilaisia välineitä kyselyiden tehostamiseksi. Yksi väline on usein toistuvien hakujen tehostamiseen tarkoitettu <em>indeksi</em>, eli hakurakenne.</p>

		<p>Pohditaan tilannetta, missä edellisen 100 miljoonaa riviä sisältävän taulun lisäksi tietokannalla on erillinen hakurakenne usein käytetylle sarakkeelle. Hakurakenteessa sarakkeen arvot ovat järjestettynä. Tällöin, tiettyä arvoa haettaessa, voimme aloittaa keskimmäisestä arvosta -- jos haettava arvo on pienempi, tutkitaan "vasemmalla" olevaa puolikasta. Jos taas haettava arvo on suurempi, tutkitaan "oikealla" olevaa puolikasta. Alueen rajaaminen jatkuu niin pitkään, kunnes haettava arvo löytyy, tai rajaus päätyy tilanteesee, missä tutkittavia arvoja ei enää ole. Tämä menetelmä -- <em>puolitushaku</em> tai <em>binäärihaku</em> saattaa olla tuttu kurssilta Ohjelmoinnin perusteet.</p>

                <p>Jos rivejä on yhteensä 100 miljoonaa, voidaan ne jakaa kahteen osaan noin <em>log_2 100 000 000</em> kertaa, eli noin 27 kertaa. Jos oletamme, että arvoa ei löydy taulusta, tulee yhteensä tarkastella siis noin 27 riviä aiemman 100 miljoonan sijaan.</p>

		<aside class="info">
		  <br/>
		  <h1>Häh?</h1>

		  <p>Kurssilla <em>Tietorakenteet ja algoritmit</em> tutustutaan erilaisiin hakurakenteisiin tarkemmin. Tietokantakursseista esimerkiksi kurssilla <em>Tietovarastot</em> tutustutaan tähän myös syvemmin.</p>

		</aside>

		<p><strong><em>Indeksin määrittely</em></strong></p>

                <p>Indeksin määrittely tietokantataulun sarakkeelle tapahtuu tietokantataulun luomisen jälkeen komennolla <code>CREATE INDEX</code>, jota seuraa uuden indeksin nimi, avainsana <code>ON</code>, ja sarakkeet, joille indeksi luodaan. Tietokantataulun pääavaimelle ja viiteavaimelle luodaan indeksit automaattisesti.</p>

		<p>Oletetaan, että haluaisimme hakea opiskelijoita pääaineen perusteella melko usein, jolloin rajauksen tehokkuudella on hieman väliä. Tehdään siis tauluun Opiskelija erillinen indeksi pääaine-sarakkeelle.</p>

<pre class="sh_sql">
CREATE INDEX idx_paaaine ON Opiskelija (pääaine);
</pre>

                <p>Indeksien nimentä alkaa tyypillisesti sanalla <code>idx</code>, jatkuu alaviivalla sekä sarakkeita kuvaavalla sopivalla nimellä. Jos indeksin haluaa määritellä useammalle sarakkeelle samaan aikaan, voi indeksoitavat sarakkeet listata pilkuilla toisistaan erotettuna.</p>



		<h2>Tietokantataulun muokkaaminen</h2>

		<p>Valitettava totuus on se, että vaikka tekisimme kuinka hienon tietokantasuunnitelman, tulee se muuttumaan ajan myötä erilaisten asiakkailta ja muilta sidosryhmiltä tulevien toiveiden ja tarpeiden perusteella. Tietokantaa ei kannata luoda täysin uudestaan jokaisen muutoksen perusteella, vaan sitä voi muokata -- esimerkiksi uusien sarakkeiden lisääminen tauluun on melko suoraviivaista.</p>

		<p>Harjoitellaan tässä välissä hieman tiedon hakua muualta. Sivusto <em>W3Schools</em> sisältää hyviä oppaita -- lue nyt heidän <a href="http://www.w3schools.com/sql/sql_alter.asp" target="_blank">ALTER TABLE</a> -opas.</p>



		<h2>Väliaikaisten näkymien luominen</h2>

		<p>Ohjelmia suunniteltaessa ja rakentessa ohjelmoija pilkkoo ohjelman toiminnallisuutta pienempiin osiin muunmuassa metodien ja luokkien avulla. Tietokantakyselyitä toteuttaessa ohjelmoija vastaavasti voi pilkkoa tehtäväänsä osiin väliaikaisten näkymien avulla. Väliaikaiset näkymät ovat tallennettuja SQL-kyselyitä, joiden suorituksesta saatuja tulostauluja voidaan käyttää osana muita kyselyitä.</p>

		<p>Väliaikainen näkymä luodaan komennolla <code>CREATE VIEW <em>NäkymänNimi</em> AS <em>kysely</em></code>, missä <code>NäkymänNimi</code> on nimi, jonka perusteella väliaikaiseen näkymään pääsee käsiksi, ja <code>kysely</code> on <code>SELECT</code>-kysely, jonka suoritus tuottaa näkymän.</p>


		<div ng-controller="noTablesSqlController">

		  <p>Tutustutaan tähän pikaisesti. Luodaan ensin käyttöömme taulu <code>Kurssi</code>, jossa on kursseja.</p>
		  
		  <query
		     db="db"
		     rows="11"
		     editable="false"
		     query="CREATE TABLE Kurssi (
    kurssitunnus integer PRIMARY KEY, 
    nimi varchar(200) NOT NULL, 
    kuvaus varchar(3000)
);

INSERT INTO Kurssi (nimi) VALUES ('Ohpe');
INSERT INTO Kurssi (nimi) VALUES ('Tikape');
INSERT INTO Kurssi (nimi) VALUES ('Otm');
INSERT INTO Kurssi (nimi) VALUES ('Ohja');"
		     done="tablesCreated">
		  </query>
		  
		  <div ng-show="tablesCreated">

		    <p>Luodaan tämän jälkeen näkymä nimeltä <code>Ohjelmointikurssit</code>, missä on vain ohjelmoinnin perusteet ja ohjelmoinnin jatkokurssi.</p>


		    <togglable content="taulut" db="db">
                      <table-info></table-info>
		    </togglable>
		    

		    <query
		       db="db"
		       rows="3"
                       editable="false"
		       query="CREATE VIEW Ohjelmointikurssit AS
    SELECT * FROM Kurssi WHERE nimi LIKE 'Oh%'"
		       done="viewCreated">
		    </query>
		  </div>

		  <div ng-show="viewCreated">

		    <p>Valitse nyt kaikki kurssit näkymästä Ohjelmointikurssit -- haku tapahtuu samalla tavalla kuin taulusta haettaessa.</p>

		    <query
		       db="db"
		       rows="4" 
		       done="viewSelected">
		    </query>
		  </div>

		  <div ng-show="viewSelected">

		    <p>Poista näkymä lopuksi komennolla <code>DROP VIEW <em>NäkymänNimi</em></code>.</p>

		    <query
		       db="db"
		       rows="2">
		    </query>
		  </div>
		</div>



<!--

		<aside class="info">
		  <br/>
		  <h1>Näkymien luominen kyselyiden kautta</h1>
		  
		</aside>
-->

		
<!--
TODO: hyödynnä dellin DVD-kauppaa: http://linux.dell.com/dvdstore/

-->

		<h1>Tietokannan normalisointi</h1>
		
		<p><em>Omenan (data) herkullisuudella, kuljetusvälineellä (tietokantasovellus ja palvelin), tai kaupassa tehtävällä asettelulla (sovelluksen käyttöliittymä) ei ole merkitystä jos omenoiden säilöntään (tietokantakaavio) ei ole kiinnitetty huomiota.</em> -- <a href="https://news.ycombinator.com/item?id=8839017" target="_blank">Anonyymi</a></p>
		
		

		<p>Tutustuimme aiemmin tietokannan suunnitteluun käsiteanalyysin kautta. Tutustutaan nyt täydentävään lähestymistapaan nimeltä tietokannan normalisointi (<em>database normalization</em>).</p>

		<p>Tietokannan normalisointi on askeleittainen lähestymistapa tiedon jakamiseen loogisiksi tietokantatauluiksi ja niiden sarakkeiksi. Pääpiirteittäin idea on sama kuin käsiteanalyysissä -- jokaisen taulun pitäisi liittyä tiettyyn aiheeseen, ja tauluun määritellään vain sarakkeita jotka liittyvät samaan aiheeseen. Lähestymistapa on hieman toisenlainen -- tietokannan normalisoinnissa tutkimme tiedon välisiä riippuvuuksia ja suhteita, ja etsimme sieltä epäkohtia. Epäkohdat tyypillisesti jaetaan useampaan osaan, esimerkiksi tauluiksi.</p>

		<p>Lähtökohtana tietokannan normalisoinnille ovat seuraavat relaatiomalliin liittyvät oletukset:</p>

		<ul>

		  <li>Jokaisen tietokantataulun sarakkeen nimen tulee olla uniikki. Tietokantataulussa ei siis saa olla kahta saman nimistä saraketta.</li>

		  <li>Jokaisen tietokantataulun sarakkeen tulee olla sellainen, että se sisältää korkeintaan yhden arvon. Yksittäisessä sarakkeen rivissä ei siis esimerkiksi saa säilöä listaa asioita.</li>

		  <li>Jokaisen tietyssä tietokantataulun sarakkeessa olevan arvon tulee olla saman tyyppinen. Eri riveillä, mutta samassa sarakkeessa ei siis saa olla esimerkiksi kokonaislukutyyppisiä arvoja ja merkkijonotyyppisiä arvoja.</li>

		  <li>Tietokantataulun sarakkeiden järjestyksen ei tule vaikuttaa tietoon. Sarakkeiden paikkaa tulee siis voida vaihtaa tarvittaessa.</li>
		  <li>Tietokantataulussa ei tule olla kahta tai useampaa täsmälleen samat arvot sisältävää riviä. Jos rivi esiintyy kerran, ei sen toistamisesta ole hyötyä.</li>

		  <li>Tietokantataulussa olevien rivien järjestyksellä ei tule olla merkitystä.</li>

		</ul>


		<p>Tietokannan normalisointiin liittyy useampia tavoitteita; (1) tiedon kopioiden minimointi, (2) tiedon muuttamiseen liittyvien ongelmien vähentäminen, ja (3) tietokantaan tehtävien kyselyiden yksinkertaistaminen. Käytetään esimerkkinä seuraavaa yhden taulun avulla määriteltyä asiakastietokantaa, joka kertoo asiakkaan tiedot, laskutusosoitteen, ja kuljetusosoitteen.</p>


		<figure>

		  <img src="img/viikko5/normalisoitava.png" alt="[Asiakas|(pk) asiakastunnus;etunimi;sukunimi;kayttajatunnus;ika;sukupuoli;yritys;puhelin_koti;puhelin_tyo;laskutusosoite_1;laskutusosoite_2;laskutusosoite_3;laskutus_kaupunki;laskutus_postinumero;kuljetusosoite_1;kuljetusosoite_2;kuljetusosoite_3;kuljetus_kaupunki;kuljetus_postinumero]">

		</figure>

		<p></p>

		<p>Tietokannan normalisointiin liittyy useampia askeleita, joista tutustumme kolmeen.</p>


		<h2>Ensimmäinen normaalimuoto</h2>

		<p>Ensimmäisen normaalimuodon mukaan jokaisen sarakkeen arvojen tulee olla sellaisia, että niitä ei voi jakaa (järkeviin) osiin. Sarakkeen arvot eivät siis saa olla esimerkiksi listoja. Tämän lisäksi, tietokantataulun sarakkeista ei pitäisi olla mahdollista huomata toistuvia ryhmiä.</p>

		<p>Edelläolevassa tietokantataulussa on toistuvia ryhmiä. Sekä puhelinnumero (kotipuhelin, työpuhelin) että osoite toistuu (kotiosoite, laskutusosoite). Emme tiedä sarakkeiden sisällöstä, joten emme tässä kohtaa osaa sanoa siitä, että onko sarakkeiden arvoissa jotain omituista -- jos tietokantataulussa olisi esimerkiksi sarakkeessa <em>yritys</em> useamman yrityksen nimi, tulisi se ottaa myös käsittelyyn.</p>

		<p>Tietokannan saa ensimmäiseen normaalimuotoon eriyttämällä puhelinnumeron ja osoitteen omiksi tauluikseen, joista on viittaus Asiakas-tauluun. Uusissa tauluissa on myös sarake tyyppi, jonka avulla määritellään onko esimerkiksi puhelinnumero koti- vai työnumero.</p>


		<figure>

		  <img src="img/viikko5/1nf.png" alt="[Asiakas| (pk) asiakastunnus;etunimi;sukunimi;kayttajatunnus;ika;sukupuoli;yritys]
[Puhelin| (fk) asiakas:Asiakas; puhelin_tyyppi; numero]
[Osoite| (fk) asiakas:Asiakas; osoite_tyyppi; osoite_1; osoite_2; osoite_3; kaupunki; postinumero]
[Asiakas]1-*[Puhelin]
[Asiakas]1-*[Osoite]">

		</figure>

		<p></p>

		<p>Jos tietokantataulun sarakkeiden arvoissa olisi esimerkiksi listoja -- vaikkapa yksittäisen rivin yritys-sarakkeessa useampia yrityksiä, tulisi siitä myös tehdä erillinen taulu.</p>


		<h2>Toinen normaalimuoto</h2>

		<p>Tietokanta on toisessa normaalimuodossa jos (1) se on ensimmäisessä normaalimuodossa ja (2) tietokantataulun sarakkeet (poislukien avaimet) ovat <em>funktionaalisesti riippuvaisia</em> tietokantataulun pääavaimesta.</p>

		
		<aside class="info">
		  <br/>
		  
		  <h1>Funktionaalinen riippuvuus</h1>
		  
		  <p>Sarake B on funktionaalisesti riippuvainen sarakkeesta A, jos sarakkeen A arvon perusteella voidaan yksikäsitteisesti selvittää sarakkeen B arvo. Tällöin kirjoitetaan <code>A -&gt; B</code>, ja sanotaan, että "sarake B on funktionaalisesti riippuvainen sarakkeesta A". Huom! A voi olla myös kokoelma sarakkeita!</p>

		  <p>Selvittäminen voi tapahtua kyselyllä "SELECT DISTINCT b FROM Taulu WHERE a=tiedetty_arvo". Jos attribuutti <code>b</code> on funktionaalisesti riippuva <code>a</code>:sta, tuottaa ylläoleva kysely joko yhden tai ei yhtään tulosriviä, mutta ei koskaan enempää. Tämän ehdon on oltava voimassa aina, ei vain hetkellisesti.</p>

		  <p>Esimerkki: <code>Henkilo( (pk) id, nimi, henkilötunnus)</code> -- mitkä arvot ovat funktionaalisesti riippuvaisia toisistaan?</p>
		  <table class="table">
		    
		    <thead>
		      <tr>
			<th>Henkilo</th>
			<th>A: id</th>
			<th>A: nimi</th>
			<th>A: henkilötunnus</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>B: id</td>
			<td>?</td>
			<td>?</td>
			<td>?</td>
		      </tr>
		      <tr>
 			<td>B: nimi</td>
			<td>?</td>
			<td>?</td>
			<td>?</td>
		      </tr>
		      <tr>
			<td>B: henkilötunnus</td>
			<td>?</td>
			<td>?</td>
			<td>?</td>
		      </tr>
		    </tbody>
		  </table>

		  <p>Sarakkeen perusteella voi aina määritellä itsensä. Esimerkiksi <code>id -&gt; id</code> on aina totta.</p>

		  <table class="table">
		    
		    <thead>
		      <tr>
			<th>Henkilo</th>
			<th>A: id</th>
			<th>A: nimi</th>
			<th>A: henkilötunnus</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>B: id</td>
			<td>kyllä</td>
			<td>?</td>
			<td>?</td>
		      </tr>
		      <tr>
 			<td>B: nimi</td>
			<td>?</td>
			<td>kyllä</td>
			<td>?</td>
		      </tr>
		      <tr>
			<td>B: henkilötunnus</td>
			<td>?</td>
			<td>?</td>
			<td>kyllä</td>
		      </tr>
		    </tbody>
		  </table>

		  <p>Voimmeko tunnistaa nimen perusteella henkilön yksilöivän tunnisteen? Useammalla henkilöllä voi olla sama nimi, joten tämä ei pidä paikkansa. Voimmeko tunnistaa henkilötunnuksen perusteella henkilön yksilöivän tunnisteen? Henkilötunnus on uniikki, joten oletetaan että kyllä (tämä pätee tosin vain Suomessa..).</p>

		  <table class="table">
		    
		    <thead>
		      <tr>
			<th>Henkilo</th>
			<th>A: id</th>
			<th>A: nimi</th>
			<th>A: henkilötunnus</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>B: id</td>
			<td>kyllä</td>
			<td>ei</td>
			<td>kyllä</td>
		      </tr>
		      <tr>
 			<td>B: nimi</td>
			<td>?</td>
			<td>kyllä</td>
			<td>?</td>
		      </tr>
		      <tr>
			<td>B: henkilötunnus</td>
			<td>?</td>
			<td>?</td>
			<td>kyllä</td>
		      </tr>
		    </tbody>
		  </table>

		  <p>Voiko yksilöivän avaimen perusteella tunnistaa henkilön nimen? Kyllä. </p>

		  <table class="table">
		    
		    <thead>
		      <tr>
			<th>Henkilo</th>
			<th>A: id</th>
			<th>A: nimi</th>
			<th>A: henkilötunnus</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>B: id</td>
			<td>kyllä</td>
			<td>ei</td>
			<td>kyllä</td>
		      </tr>
		      <tr>
 			<td>B: nimi</td>
			<td>kyllä</td>
			<td>kyllä</td>
			<td>?</td>
		      </tr>
		      <tr>
			<td>B: henkilötunnus</td>
			<td>?</td>
			<td>?</td>
			<td>kyllä</td>
		      </tr>
		    </tbody>
		  </table>

		  <p>Loput jäävät harjoitustehtäväksi.</p>
		</aside>


		<p>Jos tietokantataulun pääavain on määritelty yhden sarakkeen avulla, ovat kaikki sen sen sarakkeet automaattisesti funktionaalisesti riippuvaisia pääavaimesta. Käytännössä siis, jos taulu on ensimmäisessä normaalimuodossa ja sillä on yhden sarakkeen kautta määritelty pääavain, on se automaattisesti toisessa normaalimuodossa.</p>


		<h2>Kolmas normaalimuoto</h2>

		<p>Tietokantataulu on kolmannessa normaalimuodossa jos (1) se on toisessa normaalimuodossa ja (2) siinä on vain sarakkeita, jotka eivät ole transitiivisesti riippuvaisia taulun pääavaimesta. </p>

		<aside class="info">
		  <br/>
		  
		  <h1>Transitiivinen riippuvuus</h1>

		  <p>Transitiivisella riippuvuudella tarkoitetaan sitä, että sarake A on riippuvainen sarakkeesta B jonkun toisen sarakkeen kautta. Käytännössä sarake A on transitiivisesti riippuvainen sarakkeesta B, jos sarake A on riippuvainen sarakkeesta C, joka on riippuvainen sarakkeesta B. </p>

		</aside>

		<p>Kaikkien tietokantataulun sarakkeiden tulee olla itsenäisiä ja riippumattomia muista pääavaimeen kuulumattomista kentistä. Jos tietokantataulusta tunnistetaan sarakkeita, jotka ovat transitiivisesti riippuvaisia pääavaimesta, eriytetään ne omaksi taulukseen.</p>

		<p>Esimerkiksi Osoite-taulussa oleva sarake kaupunki on transitiivisesti riippuvainen asiakkaasta postinumeron kautta. Voimme tällöin luoda uuden tietokantataulun <em>Postinumero</em>, joka sisältää jokaiseen postinumeroon liittyvät kaupungit.</p>


		<aside class="info">
		  <br/>
		  <h1>Normalisoida vaiko eikö normalisoida?</h1>
		  
		  <p>Lue CodingHorror.com-blogista kirjoitus <a href="http://blog.codinghorror.com/maybe-normalizing-isnt-normal/" target="_blank">Maybe Normalizing Isn't Normal</a>. Milloin tietokannan normalisointi kannattaa, ja milloin ei?</p>

		  <p>Tutki myös seuraavaa Asiakas-taulun rakennetta. Mitkä edellämainituista normaalimuodoista taulu täyttää?</p>

		  <table class="table">
		    <thead>
		      <tr>
			<th>asiakastunnus</th>
			<th>etunimi</th>
			<th>sukunimi</th>
			<th>kayttajatunnus</th>
			<th>ika</th>
			<th>sukupuoli</th>
			<th>yritys</th>
		      </tr>
		    </thead>
		    <tbody>
		      <tr>
			<td>1</td>
			<td>arto</td>
			<td>vainee</td>
			<td>avi</td>
			<td>30</td>
			<td>M</td>
			<td>yliopisto</td>
		      </tr>
		      <tr>
			<td>2</td>
			<td>arto</td>
			<td>vainee</td>
			<td>avi</td>
			<td>30</td>
			<td>M</td>
			<td>rage-research</td>
		      </tr>
		    </tbody>
		  </table>
		  
		</aside>





		<header>
		  <h1 id="viikko6">Viikko 6</h1>
		</header>


		<h1>Tietokannat osana muita sovelluksia</h1>

		<p>Viimeisen 20 vuoden aikana selaimen kautta käytettävät sovellukset ovat kiihtyvää tahtia syrjäyttäneet perinteisiä työpöytäsovelluksia. Tietokannan käyttöön toisen sovelluksen osana liittyvät perusajatukset eivät kuitenkaan ole juurikaan muuttuneet. Työpöytäsovellusten aikana työpöytäsovellus käytti joko paikallisella koneella olevaa tietokannanhallintajärjestelmää, tai otti etäyhteyden toisella koneella käynnissä olevaan tietokannanhallintajärjestelmään. Selaimessa toimivia sovelluksia käytettäessä tietokannanhallintajärjestelmä toimii palvelinohjelmiston -- eli sovelluksen, johon selain ottaa yhteyttä -- kanssa samalla koneella, tai erillisellä koneella, johon palvelinohjelmisto ottaa yhteyden tarvittaessa.</p>

		<p>Tutustutaan tässä kappaleessa tietokantaa käyttävän palvelinohjelmiston toimintaan, sekä toteutetaan sellainen itse.</p>

		<h2>Selaimen ja palvelimen välinen kommunikaatio</h2>

		<p>Selain kommunikoi palvelimen kanssa tekemällä pyyntöjä joihin palvelin vastaa. Selain tekee pyynnön esimerkiksi kun käyttäjä kirjoittaa osoitekenttään sivun osoitteen -- tietokantojen-perusteet.github.io -- ja painaa enter. Tällöin tehdään hakupyyntö (<code>GET</code>) osoitteessa <code>tietokantojen-perusteet.github.io</code> olevalle palvelimelle. Palvelin vastaanottaa pyynnön, käsittelee sen -- esimerkiksi hakee haluttavan dokumentin tiedostojärjestelmästä -- ja luo käyttäjälle näytettävän sivun. Sivu palautetaan vastauksena pyynnölle tekstimuodossa. Selain päättelee vastauksen sisällön perusteella miten sivu tulee näyttää käyttäjälle, luo sivun ulkoasun, ja näyttää sivun käyttäjälle.</p>

		<p>Sivun näyttämisen yhteydessä selain hakee myös sisältöä, joihin sivu viittaa. Esimerkiksi jokainen tällä sivulla oleva kuva haetaan erikseen, aivan kuten erilaiset dynaamista toiminnallisuutta lisäävät Javascript -tiedostot sekä sivun ulkoasun tyylittelyyn liittyvät tyylitiedostot.</p>

		<p>Käyttäjän näkökulmasta selain tekee käytännössä kahdenlaisia pyyntöjä. Hakupyynnöt (<code>GET</code>) liittyvät tietyssä osoitteessa olevan resurssin hakemiseen, kun taas lähestyspyynnöt (<code>POST</code>) liittyvät tiedon lähettämiseen tiettyyn osoitteeseen.</p>

		<p>Tutustutaan tähän käytännössä Javalla toteutetun <a href="http://sparkjava.com/" target="_blank">Spark</a>-nimisen web-sovelluskehyksen avulla.</p>

		<h2>Spark ja ensimmäinen web-sovellus</h2>

		<p><a href="http://sparkjava.com/" target="_blank">Spark</a>-sovelluskehyksen käyttöönotto toimii luvun 3.2 osassa "<em>Maven-projektin luominen NetBeansissa</em>" esitetyllä tavalla. Toisin kuin oppaassa, Maven-projektin riippuvuudeksi halutaan lisätä Spark. Tiedosto <code>pom.xml</code> näyttää lopuksi esimerkiksi seuraavalta:</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;tikape&lt;/groupId&gt;
    &lt;artifactId&gt;tikape-web-sample&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
    
    &lt;dependencies&gt;        
        &lt;dependency&gt;
            &lt;groupId&gt;com.sparkjava&lt;/groupId&gt;
            &lt;artifactId&gt;spark-core&lt;/artifactId&gt;
            &lt;version&gt;2.3&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</pre>


		<p>Oleellista edellä on se, että Javan versioksi on määritelty 1.8, ja sparkin versioksi 2.3.</p>

		<p>Nyt voimme luoda uuden pääohjelmaluokan (seuraa luvun 2.3 kohtaa "<em>Ensimmäinen tietokantaa käyttävä Maven-ohjelma</em>") pääohjelmaluokan luomiseksi. Lisätään <code>Main.java</code>-tiedostoon rivi <code>import static spark.Spark.*;</code>, jolloin käyttöömme tulee oleellisimmat Sparkin tarjoamat toiminnallisuudet. Kutsutaan tämän jälkeen Sparkin get-metodia, ja määritellään sen avulla osoite, jota palvelinohjelmistomme tulee kuuntelemaan, sekä teksti, joka palautetaan, kun selaimella tehdään pyyntö annettuun osoitteeseen.</p>

<pre class="sh_java">
package tikape;

import static spark.Spark.*;

public class Main {

    public static void main(String[] args) {

        get("/hei", (req, res) -&gt; {
            return "Hei maailma!";
        });

    }
}
</pre>

		<p>Yllä olevassa esimerkissä palvelimelle määritellään osoite <code>/hei</code>. Jos selaimella tehdään osoitteeseen pyyntö, pyyntöön vastataan tekstillä <code>Hei maailma!</code>.</p>

		<p>Jos ylläolevan sovelluksen käynnistää, Spark käynnistää web-palvelimen osoitteeseen <code>http://localhost:4567</code>, eli paikallisen koneen porttiin <code>4567</code>. Palvelin on tämän jälkeen käynnissä, ja odottaa siihen tehtäviä pyyntöjä. Kun haemme web-selaimella sivua osoitteesta <code>http://localhost:4567</code>, palauttaa palvelin selaimelle tekstimuotoista tietoa, ja selain näyttää käyttäjälle seuraavanlaisen sivun:</p>

                <figure>
		  <img src="img/viikko6/spark-localhost-not-found.png" alt="Kun osoitteeseen http://localhost:4567 tehdään pyyntö, sieltä palautuu sivu, jossa näkyy teksti '404 Not found'."/> 
		  <figcaption>Kun osoitteeseen http://localhost:4567 tehdään pyyntö, sieltä palautuu sivu, jossa näkyy teksti '404 Not found'.</figcaption>
		</figure>

		<p>Mutta! Kun teemme pyynnön osoitteeseen <code>http://localhost:4567/hei</code>, eli palvelinohjelmiston osoitteeseen <code>/hei</code>, saammekin vastaukseksi ohjelmakoodissa määrittelemämme <code>Hei maailma!</code>-tekstin.</p>

                <figure>
		  <img src="img/viikko6/spark-localhost-hei-maailma.png" alt="Kun osoitteeseen http://localhost:4567/hei tehdään pyyntö, sieltä palautuu teksti 'Hei maailma!'."/> 
		  <figcaption>Kun osoitteeseen http://localhost:4567/hei tehdään pyyntö, sieltä palautuu teksti 'Hei maailma!'.</figcaption>
		</figure>

		<p>Vapise, google.</p>

		<aside class="info">

		  <br/>

		  <h1>NetBeans ja palvelimen sammuttaminen</h1>

		  <p>Palvelimen sammuttaminen tapahtuu NetBeansissa punaista neliötä klikkaamalla. Joissakin käyttöjärjestelmissä tämä on kuitenkin bugista, jolloin palvelin tulee sammuttaa komentoriviltä.</p>

		  <p>Saat portissa <code>4567</code> käynnissä olevan prosessin tunnuksen tietoon terminaalissa komennolla <code>lsof -i :4567</code>. Etsi komennon palauttamasta tulosteesta prosessin tunnus, jonka jälkeen voit sammuttaa prosessin komennolla <code>kill -9 prosessin-tunnus</code>.</p>

		  <p>Esimerkiksi:</p>
<pre>
> lsof -i :4567
COMMAND  PID     USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
java    9916 kayttaja   51u  IPv6 0x65802ef6be5c6f29      0t0  TCP *:tram (LISTEN)
>
</pre>

		  <p>Yllä prosessin tunnus (PID) on 9916. Tämän jälkeen prosessi sammutetaan komennolla <code>kill -9 9916</code>.</p>

<pre>
> lsof -i :4567
COMMAND  PID     USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
java    9916 kayttaja   51u  IPv6 0x65802ef6be5c6f29      0t0  TCP *:tram (LISTEN)
> kill -9 9916
</pre>

		</aside>


		<h2>Useamman osoitteen kuunteleminen</h2>


		<p>Spark-palvelimelle määritellään <code>get</code>-metodin avulla palvelimen kuuntelemia osoitteita. Metodikutsun yhteydessä määritellään myös palvelimen palauttama data. Palautettava data on tekstiä, mutta selain päättelee palautetun tekstin sisällön perusteella, mitä tekstille tulee tehdä. Alla olevassa ohjelmakoodissa määritellään kaksi osoitetta, joista palautetaan dataa. Toinen palauttaa aiemmin nähdyn tekstin <code>Hei maailma!</code>, ja toinen palauttaa <a href="http://www.w3schools.com/html/" target="_blank">HTML</a>-elementin, jonka selain käsittelee ja näyttää. Koska elementin sisällä on linkki Youtube-videoon, aloittaa selain videon hakemisen Youtube-palvelusta.</p>

<pre class="sh_java">
package tikape;

import static spark.Spark.*;

public class Main {

    public static void main(String[] args) {

        get("/hei", (req, res) -&gt; {
            return "Hei maailma!";
        });
        
        
        get("/testi", (req, res) -&gt; {
            return "&lt;iframe width=\"640\" height=\"420\" src=\"https://www.youtube.com/embed/dQw4w9WgXcQ?rel=0&autoplay=1\"&gt;&lt;/iframe&gt;";
        });

    }
}
</pre>


		<h2>Tiedon lähettäminen palvelimelle</h2>

		<p>Tiedon lähettäminen (<code>POST</code>) palvelimelle tapahtuu HTML-sivuilla lomakkeen avulla.</p>

		<p><strong><em>Lomakkeen määrittely</em></strong></p>

                <p>Lomakkeelle (<code>form</code>) määritellään metodiksi (<code>method</code>) lähetys, eli POST, sekä osoite, johon lomakkeella oleva tieto tulee lähettää. Lomakkeen määrittely alkaa muodossa <code>&lt;form method="POST" action="/osoite"&gt;</code>, missä <code>/osoite</code> on palvelimelle määritelty osoite. Tätä seuraa erilaiset lomakkeen kentät, esimerkiksi tekstikenttä (<code>&lt;input type="text" name="nimi"/&gt;</code>), johon syötettävälle arvolle tulee <code>name</code>-kentässä määritelty nimi. Lomakkeeseen tulee lisätä myös nappi (<code>&lt;input type="submit" value="Lähetä!"/&gt;</code>), jota painamalla lomake lähetetään. Lomake voi olla kokonaisuudessaan esimerkiksi seuraava:</p>

<pre class="sh_html">
&lt;form method="POST" action="/opiskelijat"&gt;
Nimi:&lt;br/&gt;
&lt;input type="text" name="nimi"/&gt;&lt;br/&gt;
&lt;input type="submit" value="Lisää opiskelija"/&gt;
&lt;/form&gt;
</pre>

                
                <p>Yllä määritelty lomake näyttää selaimessa (esimerkiksi) seuraavalta:</p>

<pre>
<div>
<form method="POST" action="/opiskelijat">
Nimi:<br/>
<input type="text" name="nimi"/><br/>
<input type="submit" value="Lisää opiskelija"/>
</form>
</div>
</pre>

                <p>Nappia painamalla lomakkeeseen kirjoitettu tieto yritetään lähettää osoitteessa <code>http://tietokantojen-perusteet.github.io</code> olevan palvelimen osoitteeseen <code>/opiskelijat</code>. Ei taida onnistua :).</p>

		<p><strong><em>Tiedon lähetyksen vastaanotto</em></strong></p>

		<p>Palvelimelle määritellään tietoa vastaanottava osoite metodilla <code>post</code>, jolle annetaan parametrina kuunneltava osoite, sekä koodi, joka suoritetaan kun osoitteeseen lähetetään tietoa. Pyynnön mukana lähetettävään tietoon -- esimerkiksi ylläolevalla lomakkeella voidaan lähettää nimi-niminen arvo palvelimelle -- pääsee käsiksi <code>req</code>-nimisen parametrin metodilla <code>queryParams</code>.</p>

<pre class="sh_java">
        post("/opiskelijat", (req, res) -&gt; {
            String nimi = req.queryParams("nimi");
            System.out.println("Vastaanotettiin " + nimi);

            return "Kerrotaan siitä tiedon lähettäjälle: " + nimi;
        });
</pre>

		<p>Samaa osoitetta voi käsitellä sekä <code>get</code>, että <code>post</code>-metodilla. Palvelin voi siis palauttaa selaimen tekemiin hakupyyntöihin tiettyä dataa -- esimerkiksi vaikkapa lomakkeen -- ja käsitellä lähetetyn tiedon erikseen. Alla on määritelty kaksi <code>/opiskelijat</code>-osoitetta kuuntelevaa toiminnallisuutta. Toinen palauttaa lomakkeen, toinen taas palauttaa tekstin, jonka osana on lomakkeella lähetetty nimi.</p>

<pre class="sh_java">
package tikape;

import static spark.Spark.*;

public class Main {

    public static void main(String[] args) {

        get("/opiskelijat", (req, res) -&gt; {
            return "&lt;form method=\"POST\" action=\"/opiskelijat\"&gt;\n"
                    + "Nimi:&lt;br/&gt;\n"
                    + "&lt;input type=\"text\" name=\"nimi\"/&gt;&lt;br/&gt;\n"
                    + "&lt;input type=\"submit\" value=\"Lisää opiskelija\"/&gt;\n"
                    + "&lt;/form&gt;";
        });

        post("/opiskelijat", (req, res) -&gt; {
            String nimi = req.queryParams("nimi");
            return "Kerrotaan siitä tiedon lähettäjälle: " + nimi;
        });

    }
}
</pre>

		<p>Kun palvelin käynnistetään ylläolevalla ohjelmalla, löytyy osoitteesta <code>http://localhost:4567/opiskelijat</code> seuraavanlainen sivu:</p>

                <figure>
		  <img src="img/viikko6/spark-lomake.png" alt="Kun osoitteeseen http://localhost:4567/opiskelijat tehdään pyyntö, nähdään aiemmin määritelty."/> 
		  <figcaption>Kun osoitteeseen http://localhost:4567/opiskelijat tehdään pyyntö, nähdään aiemmin määritelty.</figcaption>
		</figure>

		<p>Täytetään lomake -- vaikkapa nimellä <a href="https://en.wikipedia.org/wiki/Edgar_F._Codd" target="_blank">Edgar F. Codd</a>.</p>

                <figure>
		  <img src="img/viikko6/spark-lomake-taytetty.png" alt="Lomakkeen nimi-kenttään asetettu arvo 'Edgar F. Codd'."/> 
		  <figcaption>Lomakkeen nimi-kenttään asetettu arvo 'Edgar F. Codd'.</figcaption>
		</figure>

		<p>Kun painamme nyt nappia <code>Lisää opiskelija</code>, tekstikentän sisältö lähetetään palvelimelle lomakkeen <code>action</code>-kentän määrittelemään osoitteeseen. Jos lomakkeessa määritelty metodiksi (<code>method</code>) post, tehdään lähetyspyyntö. Jos action kenttä on <code>/opiskelijat</code> ja metodi <code>POST</code>, lähetettävä tieto vastaanotetaan ja suoritetaan rivillä <code>post("/opiskelijat", (req, res) -&gt; {</code> alkavalla ohjelmakoodilla. Aiemmin määritellyllä ohjelmalla käyttäjälle näytetään seuraavanlainen sivu:</p>

                <figure>
		  <img src="img/viikko6/spark-lomake-lahetetty.png" alt="Lomake on lähetetty ja palvelin palauttaa tekstin 'Kerrotaan siitä tiedon lähettäjälle: Edgar F. Codd'."/> 
		  <figcaption>Lomake on lähetetty ja palvelin palauttaa tekstin 'Kerrotaan siitä tiedon lähettäjälle: Edgar F. Codd'.</figcaption>
		</figure>


		<p><strong><em>Tiedon säilöminen palvelimelle hetkellisesti</em></strong></p>

		<p>Voimme tallentaa vastaanotettu tieto palvelimelle palvelimen käynnissäoloajaksi säilömällä tieto esimerkiksi <code>ArrayList</code>-tyyppiseen listaan. Muokataan ylläolevaa aiempaa koodia siten, että hakupyyntö osoitteeseen <code>/opiskelijat</code> palauttaa sekä lomakkeen että tallennetut opiskelijat. Tämän lisäksi, lisätään osoitteeseen <code>/opiskelijat</code> tehtävän lähetyspyynnön käsittelyyn lomakkeelta saatavan nimi-kentän lisääminen ohjelmassa olevaan listaan.</p>

<pre class="sh_java">
package tikape;

import java.util.ArrayList;
import static spark.Spark.*;

public class Main {

    public static void main(String[] args) {
        ArrayList&lt;String&gt; nimet = new ArrayList&lt;&gt;();

        get("/opiskelijat", (req, res) -&gt; {
            String opiskelijat = "";
            for (String nimi : nimet) {
                opiskelijat += nimi + "&lt;br/&gt;";
            }

            return opiskelijat
                    + "&lt;form method=\"POST\" action=\"/opiskelijat\"&gt;\n"
                    + "Nimi:&lt;br/&gt;\n"
                    + "&lt;input type=\"text\" name=\"nimi\"/&gt;&lt;br/&gt;\n"
                    + "&lt;input type=\"submit\" value=\"Lisää opiskelija\"/&gt;\n"
                    + "&lt;/form&gt;";
        });

        post("/opiskelijat", (req, res) -&gt; {
            String nimi = req.queryParams("nimi");
            nimet.add(nimi);
            return "Kerrotaan siitä tiedon lähettäjälle: " + nimi;
        });

    }
}
</pre>

                <p>Nyt kun osoitteessa <code>/opiskelijat</code> olevalla lomakkeella tehdään useampia pyyntöjä, tulee lomakesivulle lisää näytettäviä opiskelijoita.</p>


                <figure>
		  <img src="img/viikko6/spark-lomake-lahetetty-monesti.png" alt="Lomakkeella lähetetty arvot 'Edgar F. Codd' ja 'Ada Lovelace' ja lomake-sivu avattu uudestaan."/> 
		  <figcaption>Lomakkeella lähetetty arvot 'Edgar F. Codd' ja 'Ada Lovelace' ja lomake-sivu avattu uudestaan.</figcaption>
		</figure>




		<aside class="info">
		  <br/>
		  <h1>Useamman kentän lähettäminen</h1>

		  <p>HTML-lomakkeelle voidaan määritellä useampia kenttiä. Jokaisella kentällä tulee olla eri nimi, jotta palvelimella voidaan ottaa lomakkeen tiedon vastaan. Esimerkiksi nimeä ja osoitetta voisi kerätä vaikkapa seuraavanlaisella lomakkeella.</p>

<pre class="sh_html">
&lt;form method="POST" action="/opiskelijat"&gt;
Nimi:&lt;br/&gt;
&lt;input type="text" name="nimi"/&gt;&lt;br/&gt;
Osoite:&lt;br/&gt;
&lt;input type="text" name="osoite"/&gt;&lt;br/&gt;
&lt;input type="submit" value="Lisää opiskelija"/&gt;
&lt;/form&gt;
</pre>

                
                <p>Lomake näyttää selaimessa (esimerkiksi) seuraavalta:</p>

<pre>
<div>
<form method="POST" action="/opiskelijat">
Nimi:<br/>
<input type="text" name="nimi"/><br/>
Osoite:<br/>
<input type="text" name="osoite"/><br/>
<input type="submit" value="Lisää opiskelija"/>
</form>
</div>
</pre>

		</aside>


		<h2>Tiedon esittäminen selaimessa</h2>


		<p>Selain näyttää käyttäjälle palvelimelta saamansa tekstimuotoisen vastauksen. Jos vastaus on HTML-muodossa, tulkitsee selain vastauksen, ja luo sen perusteella näkymän käyttäjälle. Toteutimme näkymän näyttämisen käyttäjälle aiemmin siten, että palautimme palvelimelta HTML-koodia.</p>

<pre class="sh_java">
return "&lt;form method=\"POST\" action=\"/opiskelijat\"&gt;\n"
        + "Nimi:&lt;br/&gt;\n"
        + "&lt;input type=\"text\" name=\"nimi\"/&gt;&lt;br/&gt;\n"
        + "&lt;input type=\"submit\" value=\"Lisää opiskelija\"/&gt;\n"
        + "&lt;/form&gt;";
</pre>

                <p>HTML-koodin palauttaminen suoraan palvelinohjelmistosta on kuitenkin hyvin epätyypillistä. Käytännössä html-sivut luodaan lähes aina ensin erilliseen tiedostoon, jonka palvelin palauttaa käyttäjälle. Voimme tehdä näin myös Sparkin kautta.</p>

		<p><strong><em>HTML-sivujen käyttöönotto projektissa</em></strong></p>

		<p>Lisätään projektiin riippuvuudeksi <code>spark-template-thymeleaf</code>-projekti, joka tuo käyttöön <a href="http://www.thymeleaf.org/" target="_blank">Thymeleaf</a>-kirjaston. Projektin konfiguraatio on nyt kokonaisuudessaan seuraavanlainen:</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;tikape&lt;/groupId&gt;
    &lt;artifactId&gt;tikape-web-sample&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
    
    &lt;dependencies&gt;        
        &lt;dependency&gt;
            &lt;groupId&gt;com.sparkjava&lt;/groupId&gt;
            &lt;artifactId&gt;spark-core&lt;/artifactId&gt;
            &lt;version&gt;2.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.sparkjava&lt;/groupId&gt;
            &lt;artifactId&gt;spark-template-thymeleaf&lt;/artifactId&gt;
            &lt;version&gt;2.3&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</pre>

                <p>Tehdään seuraavaksi resurssikansio (<code>resources</code>) projektin kansioon <code>src/main/</code>, jos sitä ei vielä ole. Uuden kansion saa luotua NetBeansin Files-välilehdellä klikkaamalla kansiota oikealla hiirennapilla, ja valitsemalla <code>New -> Folder</code>. Kun kansio on luotu, pitäisi käytössä olla kansio <code>src/main/resources</code>. Tämän jälkeen <code>resources</code>-kansioon tulee vielä luoda kansio <code>templates</code>, johon HTML-tiedostot tullaan laittamaan.</p>

                <figure>
		  <img src="img/viikko6/nb-src-main-resources-templates.png" alt="Kansio src/main/resources/templates on luotu."/> 
		  <figcaption>Projektiin liittyvän kansion <code>src</code> allaolevassa kansiossa <code>main</code> on nyt kansio <code>resources</code>, jossa on taas kansio <code>templates</code>.</figcaption>
		</figure>

		<p>Lisätään kansioon <code>templates</code> uusi html-dokumentti (<code>New -&gt; HTML File</code>), ja asetetaan tiedoston nimeksi <code>index.html</code>.</p>

                <figure>
		  <img src="img/viikko6/nb-src-main-resources-templates-index.png" alt="Kansioon src/main/resources/templates on luotu index.html-niminen tiedosto."/> 
		  <figcaption>Nyt kansiossa <code>src/main/resources/templates</code> on tiedosto <code>index.html</code>.</figcaption>
		</figure>

		<p>Käyttämämme Thymeleaf-kirjasto olettaa, että HTML-tiedostot ovat tietyn muotoisia -- palataan tähän myöhemmin. Tässä välissä riittää, että html-sivun sisällöksi kopioi seuraavan aloitussisällön.</p>

<pre class="sh_xml">
&lt;!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;

    &lt;head&gt;
        &lt;title&gt;Otsikko&lt;/title&gt;
        &lt;meta charset="utf-8" /&gt; 
    &lt;/head&gt;

    &lt;body&gt;
        &lt;h1&gt;Hei maailma!&lt;/h1&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>


                <p>Huom! Jos näet virheen <code>500 Internal Server Error!</code> sekä NetBeansin lokeihin tulee viestiä "Parse errorista", tarkista, että sivun sisältö on aluksi täsmälleen ylläoleva.</p>


		<p><strong><em>HTML-sivun palauttaminen käyttäjälle</em></strong></p>


		<p>Voimme palauttaa kansiossa <code>src/main/java/resources/templates</code> olevia <code>.html</code>-päätteisiä tiedostoja Sparkin avulla seuraavasti. Allaolevassa metodikutsussa määritellään kuunneltavaksi osoitteeksi <code>/sivu</code>, jonka jälkeen käyttäjälle palautetaan <code>index</code>-niminen sivu. Sivun nimen perusteella päätellään palautettava html-tiedosto -- nimi <code>index</code> muunnetaan muotoon <code>src/main/java/resources/templates/</code>index<code>.html</code>.</p>

<pre class="sh_java">
package tikape;

import java.util.HashMap;
import spark.ModelAndView;
import static spark.Spark.*;
import spark.template.thymeleaf.ThymeleafTemplateEngine;

public class Main {

    public static void main(String[] args) {
        get("/sivu", (req, res) -> {
            HashMap map = new HashMap<>();

            return new ModelAndView(map, "index");
        }, new ThymeleafTemplateEngine());
    }
}
</pre>

		<p>Kun yllä määritelty sovellus käynnistetään, ja kansiossa <code>src/main/java/resources/templates</code> on tiedosto <code>index.html</code>, näytetään tiedoston sisältö käyttäjälle. Huomaathan, että tiedoston sisällön tulee olla kuten edellisessä kappaleessa näytetty. Näkymä on käyttäjälle esimerkiksi seuraavanlainen:</p>

                <figure>
		  <img src="img/viikko6/spark-index.png" alt="Osoite http://localhost:4567/sivu avattuna."/> 
		  <figcaption>Osoite http://localhost:4567/sivu avattuna.</figcaption>
		</figure>

		<aside class="info">
		  <br/>
		  <h1>Sivun palauttaminen hieman tarkemmin</h1>

		  <p>Tutkitaan sivun palauttamista vielä tarkemmin.</p>

<pre class="sh_java">
get("/sivu", (req, res) -> {
    HashMap map = new HashMap&lt;&gt;();

    return new ModelAndView(map, "index");
}, new ThymeleafTemplateEngine());
</pre>

                  <p>Metodikutsun ensimmäinen rivi lienee tuttu. Kerromme, että ohjelman tulee kuunnella osoitteeseen <code>/sivu</code> tehtäviä hakupyyntöjä. Tämän jälkeen tulee pyynnön käsittelyyn liittyvä lohko, josta tällä kertaa palautetaan olio, joka sisältää <code>HashMap</code>-olion sekä tiedon näytettävästä html-sivusta. Tämän jälkeen pyynnön käsittelyyn lisätään vielä erillinen olio, <code>ThymeleafTemplateEngine</code>, joka käsittelee html-sivun ennen sen palautusta.</p> 
	
		</aside>


		<p><strong><em>Palvelimelta saadun tiedon näyttäminen käyttäjälle</em></strong></p>

		<p>Thymeleaf-komponentin avulla voimme lisätä html-sivulle tietoa. Tämä tapahtuu lisäämällä <code>HashMap</code>-olioon <code>put</code>-metodilla arvo, esimerkiksi <code>map.put("teksti", "Hei mualima!");</code>.</p>

<pre class="sh_java">
get("/sivu", (req, res) -> {
    HashMap map = new HashMap<>();
    map.put("teksti", "Hei mualima!");

    return new ModelAndView(map, "index");
}, new ThymeleafTemplateEngine());
</pre>
		<p>Tämän jälkeen html-sivua <code>index.html</code> muokataan siten, että sinne lisätään "paikka" tiedolle. Tiedon lisääminen tapahtuu lisäämällä sivulle html-elementti, jossa on <em>attribuutti</em> <code>th:text</code>, jolle annetaan HashMap-olioon lisätyn arvon nimi aaltosulkujen sisällä siten, että aaltosulkuja edeltää dollarimerkki -- eli <code>th:text="${teksti}"</code>. Elementti voi olla vaikka <code>h2</code>-elementti, jolloin kokonaisuus voisi olla vaikkapa seuraava <code>&lt;h2 th:text="${teksti}"&gt;testi&lt;/h2&gt;</code>.</p>

<pre class="sh_xml">
&lt;!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;

    &lt;head&gt;
        &lt;title&gt;Otsikko&lt;/title&gt;
        &lt;meta charset="utf-8" /&gt; 
    &lt;/head&gt;

    &lt;body&gt;
        &lt;h1&gt;Hei maailma!&lt;/h1&gt;
        
        &lt;h2 th:text="${teksti}"&gt;testi&lt;/h2&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

		<p>Kun käynnistämme palvelimen, ja avaamme osoitteen <code>http://localhost:4567/sivu</code>, näemme seuraavanlaisen näkymän.</p>




                <figure>
		  <img src="img/viikko6/spark-index-ja-thyme.png" alt="Osoite http://localhost:4567/sivu avattuna."/> 
		  <figcaption>Osoite http://localhost:4567/sivu avattuna.</figcaption>
		</figure>


		<aside class="info">
		  <br/>
		  <h1>HashMap ja Thymeleaf</h1>

		  <p>Tässä oikeastaan tulee kaksi uutta ja mielenkiintoista asiaa.</p>

		  <p><strong>HashMap</strong> on ohjelmoinnissa käytettävä lokerikko, missä jokaisella lokerolla on nimi, mihin arvon voi asettaa. Alla olevassa esimerkissä luomme ensin HashMap-olion, jonka jälkeen asetamme lokeroon nimeltä <code>teksti</code> arvon <code>"Hei mualima!"</code>.</p>
<pre class="sh_java">
    HashMap map = new HashMap&lt;&gt;();
    map.put("teksti", "Hei mualima!");
</pre>

		  <p>Kun HashMap-olio <em>palautetaan</em> pyynnön käsittelyn jälkeen -- <code>return new ModelAndView(map, "index");</code> -- annetaan lokerikko Thymeleafin käyttöön.</p>

		  <p><strong>Thymeleaf</strong> etsii annetusta HashMap-oliosta lokeroita <code>th:text</code>-attribuutille annetulla nimellä. Esimerkiksi kun Thymeleaf käsittelee edellä näkemämme <code>&lt;h2 th:text="${teksti}"&gt;testi&lt;/h2&gt;</code>-rivin, etsii se HashMap-oliosta lokeron nimeltä <code>teksti</code>, ja asettaa siinä olevan arvon <em>elementin tekstiarvoksi</em>. Tässä tapauksessa teksti <code>testi</code> korvataan HashMap-olion lokerosta teksti löytyvällä arvolla, eli tekstillä <code>Hei mualima!</code>.</p>

		</aside>

		<p><strong><em>Listojen lisääminen sivulle</em></strong></p>

		<p>Tutustutaan vielä olioiden ja listojen käsittelyyn Thymeleafin avulla. Oletetaan, että käytössämme on seuraava <em>Opiskelija</em>-luokka.</p>

<pre class="sh_java">
package tikape;

public class Opiskelija {

    private Integer id;
    private String nimi;

    public Opiskelija() {
    }

    public Opiskelija(Integer id, String nimi) {
        this.id = id;
        this.nimi = nimi;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getNimi() {
        return nimi;
    }

    public void setNimi(String nimi) {
        this.nimi = nimi;
    }

}
</pre>

		<p>Jokaisella opiskelijalla on siis tunnus sekä nimi. Tämän lisäksi, jokaiselle opiskelijalle kuuluu <code>get</code>- ja <code>set</code>-metodit, joiden avulla opiskelijaan liittyviä tietoja voidaan hakea ja muokata. Muokataan aiempaa ohjelmaamme siten, että käytössämme on listallinen opiskelijoita, jotka palautetaan sivun mukana thymeleafin käsiteltäväksi.</p>

<pre class="sh_java">
package tikape;

import java.util.ArrayList;
import java.util.HashMap;
import spark.ModelAndView;
import static spark.Spark.*;
import spark.template.thymeleaf.ThymeleafTemplateEngine;

public class Main {

    public static void main(String[] args) {
        ArrayList&lt;Opiskelija&gt; opiskelijat = new ArrayList&lt;&gt;();
        opiskelijat.add(new Opiskelija(1, "Ada Lovelace"));
        opiskelijat.add(new Opiskelija(2, "Charles Babbage"));

        get("/opiskelijat", (req, res) -> {
            HashMap map = new HashMap&lt;&gt;();
            map.put("teksti", "Hei mualima!");
            map.put("opiskelijat", opiskelijat);

            return new ModelAndView(map, "index");
        }, new ThymeleafTemplateEngine());
    }
}
</pre>

		<p>Lisätään vielä opiskelijat html-sivulle.</p>


<pre class="sh_xml">
&lt;!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;

    &lt;head&gt;
        &lt;title&gt;Otsikko&lt;/title&gt;
        &lt;meta charset="utf-8" /&gt; 
    &lt;/head&gt;

    &lt;body&gt;
        &lt;h1&gt;Hei maailma!&lt;/h1&gt;
        
        &lt;h2 th:text="${teksti}"&gt;testi&lt;/h2&gt;
        
        &lt;h2 th:text="${opiskelijat}"&gt;opiskelijatesti&lt;/h2&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

                <p>Kun nyt haemme sivua, saamme (esimerkiksi) seuraavanlaisen näkymän.</p>


                <figure>
		  <img src="img/viikko6/spark-index-opiskelijat.png" alt="Osoite http://localhost:4567/opiskelijat avattuna. Sivulla näkyy teksti Hei maailma!

Hei mualima!

[tikape.Opiskelija@4f4a43a5, tikape.Opiskelija@41ce9964]"/> 
		  <figcaption>Osoite http://localhost:4567/sivu avattuna. Opiskelijat näkyvät, mutta eivät toivotussa muodossa.</figcaption>
		</figure>

		<p><strong><em>Thymeleafin "for-each"-lause</em></strong></p>

		<p>Kurssilla ohjelmoinnin perusteet käytetään listan läpikäymiseen <code>for</code>-lausetta. Voisimme esimerkiksi tulostaa opiskelijoihin liittyvät tiedot seuraavasti Java-koodissa:</p>

<pre class="sh_java">
ArrayList&lt;Opiskelija&gt; opiskelijat = new ArrayList&lt;&gt;();
opiskelijat.add(new Opiskelija(1, "Ada Lovelace"));
opiskelijat.add(new Opiskelija(2, "Charles Babbage"));

for(Opiskelija opiskelija : opiskelijat) {
    System.out.println("id: " + opiskelija.getId());
    System.out.println("nimi: " + opiskelija.getNimi());
    System.out.println();
}
</pre>

<pre>
id: 1
nimi: Ada Lovelace

id: 2
nimi: Charles Babbage
</pre>

                <p>Vastaavanlainen toiminnallisuus löytyy myös Thymeleafista. Voimme käydä listan elementit läpi attribuutilla <code>th:each</code>, jolle annetaan sekä läpikäytävän listan nimi -- taas aaltosulkujen sisällä siten, että aaltosulkuja ennen on dollarimerkki -- sekä yksittäisen listaelementin nimi, jota käytetään listaa läpikäydessä. Alla olevassa esimerkissä aloitetaan lista <code>ul</code>-elementin avulla. Jokaiselle opiskelijalle luodaan oma <code>li</code>-elementti (<code>&lt;li th:each="opiskelija: ${opiskelijat}"&gt;...&lt;/li&gt;</code>), jonka sisälle haetaan käsiteltävään opiskelijaan liittyvät tiedot.</p>

<pre class="sh_xml">
&lt;!DOCTYPE html SYSTEM "http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;

    &lt;head&gt;
        &lt;title&gt;Otsikko&lt;/title&gt;
        &lt;meta charset="utf-8" /&gt; 
    &lt;/head&gt;

    &lt;body&gt;
        &lt;h1&gt;Hei maailma!&lt;/h1&gt;
        
        &lt;h2 th:text="${teksti}"&gt;testi&lt;/h2&gt;

        &lt;ul&gt;
            &lt;li th:each="opiskelija: ${opiskelijat}"&gt;
                &lt;span th:text="${opiskelija.id}"&gt;1&lt;/span&gt; &lt;span th:text="${opiskelija.nimi}"&gt;Essi esimerkki&lt;/span&gt;
            &lt;/li&gt;
        &lt;/ul&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

                <p>Kun sivua tarkastelee selaimesta, näyttää se seuraavalta:</p>

                <figure>
		  <img src="img/viikko6/spark-index-opiskelijat-listana.png" alt="Osoite http://localhost:4567/opiskelijat avattuna. Sivulla näkyy teksti 
Hei maailma!

Hei mualima!

1 Ada Lovelace
2 Charles Babbage"/> 
		  <figcaption>Osoite http://localhost:4567/sivu avattuna. Opiskelijat näkyvät listattuna.</figcaption>
		</figure>

                <p>Edelläolevassa esimerkissä käydään listalla olevat opiskelijat läpi, ja luodaan niiden perusteella sivulle dataa. Mielenkiintoista esimerkissä on se, että yksittäisen opiskelijan id-kenttään pääsee käsiksi sanomalla (esimerkiksi) <code>&lt;span th:text="${opiskelija.id}"&gt;1&lt;/span&gt;</code>. Tässä Thymeleaf päättelee <code>opiskelija.id</code>-kohdassa, että sen tulee etsiä opiskelija-oliolta <code>getId()</code>-metodia, kutsua sitä, ja asettaa tähän metodin palauttama arvo.</p>

		<h2>Tietokannan käyttöönotto</h2>

		<p>Tietokannan käyttöönotto onnistuu lukua 3 mukaillen. Tällä kertaa tosin -- sen sijaan, että käyttäisimme tietokantaa komentoriviltä -- hyödynnämme tietokantaa osana web-sovellusta. Opiskelijoiden noutaminen tietokannasta tapahtuisi esimerkiksi seuraavasti:</p>

<pre class="sh_java">
package tikape;

import java.util.HashMap;
import spark.ModelAndView;
import static spark.Spark.*;
import spark.template.thymeleaf.ThymeleafTemplateEngine;
import tikape.database.Database;
import tikape.database.OpiskelijaDao;

public class Main {

    public static void main(String[] args) throws Exception {
        Database database = new Database("org.sqlite.JDBC", "jdbc:sqlite:opiskelijat.db");
        database.setDebugMode(true);

        OpiskelijaDao opiskelijaDao = new OpiskelijaDao(database);

        get("/opiskelijat", (req, res) -> {
            HashMap map = new HashMap&lt;&gt;();
            map.put("opiskelijat", opiskelijaDao.findAll());

            return new ModelAndView(map, "index");
        }, new ThymeleafTemplateEngine());

    }
}
</pre>

                 <p>Harjoitellaan tätä lisää kotitehtävissä.</p>




<!--
		<aside class="info">
		  <br/>
		  <h1>Toisen tietokannan käyttö</h1>

		  <p>ei tartte käyttää SQLiteä -- voidaan periaatteessa vaihtaa vain ajuri, ja tietty osoite.</p>

		</aside>
-->

		<aside class="info">
		  <br/>
		  <h1>XML (EXtensible Markup Language)</h1>

		  <p>Näkemämme HTML-kieli on eräänlainen tapa kuvata rakenteellista tietoa, mutta muitakin tapoja löytyy.</p>

		  <p>XML on eräs kieli, jolla kuvataan rakenteellista tietoa. Se koostuu kahdesta osasta, otsakkeesta ja rungosta. Otsake on valinnainen, ja sisältää esimerkiksi dokumentin versionumeron, tiedon käsittelyohjeita, sekä mahdollisia tietoja tiedon rakenteesta. XML-dokumentin runko taas alkaa <em>juurielementistä</em>, joita on vain yksi, jonka alla on yksi tai useampia elementtejä, joilla voi olla arvoja.</p>

		  <p>Alla on esimerkki XML-dokumentista, jossa on kuvattu opiskelijoiden nimiä.</p>

<pre class="sh_xml">
&lt;?xml version="1.0"?&gt;
&lt;opiskelijat&gt;
  &lt;opiskelija&gt;
    &lt;nimi&gt;Ada Lovelace&lt;/nimi&gt;
  &lt;/opiskelija&gt;
  &lt;opiskelija&gt;
    &lt;nimi&gt;Edgar F. Codd&lt;/nimi&gt;
  &lt;/opiskelija&gt;
  &lt;opiskelija&gt;
    &lt;nimi&gt;Lixia Zhang&lt;/nimi&gt;
  &lt;/opiskelija&gt;
&lt;/opiskelijat&gt;
</pre>

		  <p>XML-dokumentin elementit voivat sisältää useita elementtejä. Alla on kuvaus kahdesta kurssista sekä niihin liittyvistä opettajista.</p>

<pre class="sh_xml">
&lt;?xml version="1.0"?&gt;
&lt;kurssit&gt;
  &lt;kurssi&gt;
    &lt;nimi&gt;Ohjelmoinnin perusteet&lt;/nimi&gt;
    &lt;luento&gt;Ma 10-12&lt;/nimi&gt;
    &lt;opettaja&gt;
      &lt;nimi&gt;Charles Babbage&lt;/nimi&gt;
    &lt;/opettaja&gt;
  &lt;/kurssi&gt;
  &lt;kurssi&gt;
    &lt;nimi&gt;Tietokantojen perusteet&lt;/nimi&gt;
    &lt;luento&gt;Ti 10-12&lt;/nimi&gt;
    &lt;opettaja&gt;
      &lt;nimi&gt;Edgar F. Codd&lt;/nimi&gt;
    &lt;/opettaja&gt;
  &lt;/kurssi&gt;
&lt;/kurssit&gt;
</pre>

		  <p>Tiedon välittämiseen löytyy toki myös useita muita muotoja, joista <a href="http://www.json.org/" target="_blank">JSON</a> on web-maailmassa ehkäpä tällä hetkellä eniten esillä.</p>

		</aside>


                <figure>
		  <img src="img/paivitysraja.jpg" alt="päivitysraja :: 
C
 (\.   \      ,/)
  \(   |\     )/
  //\  | \   /\\
 (/ /\_#oo#_/\ \)
  \/\  ####  /\/
       `##'
"/> 
		  <figcaption>Päivitysraja, tähän on hyvä lopettaa lukeminen.</figcaption>
		</figure>

<!--
		<h2>Case: Kurssi-ilmoittautuminen? Chat?</h2>
-->



<!--

		<aside class="info">
		  <br/>

		  <h1>Käsitekaaviot ja tietokantataulut</h1>



		</aside>
-->

<!--
		<h2>Avaimet ja viiteavaimet</h2>



		<h2>Relaatiomallin formaali määritelmä</h2>

		


		<h1>Tietokannat ja tietokannanhallintajärjestelmät</h1>

 
johdanto
 Mitä on tieto, strukturoimaton ja strukturoitu tieto
 näkökulmat
  “normaali ihminen”
  “ohjelmistokehittäjä”
  esimerkkejä strukturoimattomasta ja strukturoidusta tiedosta
  “miten haetaan esim. kaikki hlöt, joiden syntymävuosi on bla”
  mistä näistä dokumenteista on helpoin hakea tietoa?

-->

<!--
		<p>Eräs kännykän suhteellisesti vähenevissä määrin käytetty ominaisuus on puheluiden soittaminen. Saat soitettua tavoittelemallesi henkilölle kirjoittamalla ehkä muutaman kirjaimen hänen nimestä, tai sanomalla nimen ääneen kännykälle. Voit toisaalta lähettää myös tavoittelemallesi henkilölle viestin vaikkapa WhatsAppissa, tai, halutessasi muokata kännykän yhteystietoja vaikkapa tietokoneella netin välityksellä.</p>

-->
<!--


. Kirjoitat ehkä muutaman kirjaimen hänen nimestään, tai sanot nimen ääneen, ja kännykkäsi soittaa kaverillesi. Hetken kuluttua olettekin jo tekemässä kurssitehtäviä yhdessä. "Tuo yksi mainostaulu oli ihan hauska, etsin eilen kumiankkoja googlella, ja nyt tuo taulu näytti kumiankkoihin liittyvän mainoksen" toteaa kaverisi. Itse näit kurssikirjoihin liittyvän mainoksen, ja muistat etsineesi kurssimateriaalia netistä kännykälläsi. Päätätte kumpikin hakea tietoa avainsanalla "foliohattu" ja kävelette takaisin mainostaulun luo. Foliohattuja ei kuitenkaan näy, oliko arvauksenne mainosjärjestelmästä väärä? </p>

		<p>Strukturoitu tieto tarkoittaa tietoa, jonka muoto on määritelty etukäteen tarkasti. Tietoa tallennetaan ennalta määriteltyihin kenttiin.. 

		<p></p>

		<p>osa tästä tiedosta on strukturoitua, ...</p>

		<p>näissä monessa on taustalla tietokanta...</p>

		<p>ohjelmisto muodostaa tietynlaisen näkymän datan pohjalta.</p>

		<p>

		<p>

kenttä järjes  edellisenä päivänä 

Lehtiotsikot ovat ovat tyypillisesti 

seuraa kielioppia paikasta 

  strukturoimattomalta -

hyvin momonipuolista   -- jopa tunkevat --   aistit näet ja kuulet Helsingin keskustassa kävellessäsi Kävellessäsi kadulla kohtaa 

		<p>Tietoa kerääntyy katsot  Kävellessäsi kadulla, näet mainoksia, kuunnellessasi musiikkia  Ihminen ei pääse tietoa pakoon.</p>

		<p>Tietoa ..</p>
-->

	      <!--
johdanto
 Mitä on tieto, strukturoimaton ja strukturoitu tieto
 näkökulmat
  “normaali ihminen”
  “ohjelmistokehittäjä”
  esimerkkejä strukturoimattomasta ja strukturoidusta tiedosta
  “miten haetaan esim. kaikki hlöt, joiden syntymävuosi on bla”
  mistä näistä dokumenteista on helpoin hakea tietoa?

 Tietokannat osana jokapäiväistä elämää (bussiaikataulut, uutiset, mobiililaitteet, ym)
 Tietokanta sovelluksen komponenttina (sisällä)
 Sovelluskohtainen tietokanta
 Tietokannat erillisinä sovelluksina
 Useampi sovellus voi käyttää samaa tietokantaa
 Yksittäinen sovellus voi käyttää myös useampaa tietokantaa

 Tietokannat, tietokantamoottorit, tietokannanhallintajärjestelmät
 Tietokannanhallintajärjestelmä hallinnoi tietokantoja sekä tarjoaa kielen tietokannan käsittelyyn -- tähän olemassaolevia rajapintoja kuten SQL
 Yksittäinen tietokannanhallintajärjestelmä voi sisältää useamman tietokannan -- pitää huolta myös oikeuksista dataan (eri käyttäjillä pääsy erilaiseen dataan)
 Tietokannat ym Tietokantamoottorit hyviä, ei kande rakentaa omaa → käytetään olemassaolevia
 mitä tietokantamoottorit tekevät

 Tietokannan käyttö, kyselyt -- yhden taulun SELECT

 Konkreettinen esimerkki tietokantaa käyttävästä sovelluksesta

 Opiskelupäiväkirja 
 halutaan lisätä omia opiskelutapahtumia (SQL)
 halutaan listata omat opiskelutapahtumat (SQL)

 halutaan muokata olemassaolevia opiskelutapahtumia
 halutaan poistaa opiskelutapahtumia
 halutaan tulostaa viikoittaiset yhteenvedot omista opiskelutapahtumista

		-->



            </section>
            <!-- END WEEK1 -->

            <!-- BEGIN WEEK2 -->
            <section class="weeklimit hidden" data-week-id="2">
                <header>
                    <h1 id="viikko2">Viikko 2</h1>
                </header>

		<p><em>To be announced</em></p>
            </section>
            <!-- END WEEK2 -->

            <!-- BEGIN WEEK3 -->
            <section class="weeklimit hidden" data-week-id="3">
                <header>
                    <h1 id="viikko3">Viikko 3</h1>
                </header>

		<p><em>To be announced</em></p>
	    </section>
            <!-- END WEEK3 -->

            <!-- BEGIN WEEK4 -->
            <section class="weeklimit hidden" data-week-id="4">
                <header>
                    <h1 id="viikko4">Viikko 4</h1>
                </header>
		
		<p><em>To be announced</em></p>
	    </section>
            <!-- END WEEK4 -->

            <!-- BEGIN WEEK5 -->
            <section class="weeklimit hidden" data-week-id="5">
                <header>
                    <h1 id="viikko5">Viikko 5</h1>
                </header>

		<p><em>To be announced</em></p>
	    </section>
            <!-- END WEEK5 -->

            <!-- BEGIN WEEK6 -->
            <section class="weeklimit hidden" data-week-id="6">
                <header>
                    <h1 id="viikko6">Viikko 6</h1>
                </header>

		<p><em>To be announced</em></p>
	    </section>
            <!-- END WEEK6 -->

            <!-- BEGIN WEEK7 -->
            <section class="weeklimit hidden" data-week-id="7">
                <header>
                    <h1 id="viikko7">Viikko 7</h1>
                </header>

		<p><em>To be announced</em></p>


		<!-- helppereitä: -->


		<!--
                <aside class="extra">
                    <h1>Muutama sana sovelluksen logikonfiguraatiosta</h1>

                    <p>Sovelluksen sisäisen sielunelämän näkeminen vaatii sovelluksen logikonfiguraation muuttamista. Oma konfiguraatiotiedosto <code>application.properties</code> lisätään kansioon <code>src/main/resources</code>. Tällä tiedostolla voidaan ohjata muunmuassa minkälaisia viestejä sovelluksen logeissa näytetään, sekä rajata viestien saapumista.</p>

                    <p>Allaoleva konfiguraatio määrittelee käyttöömme DEBUG-tason pyyntöjä vastaanottavalle Spring-komponentille ja asettaa Hibernate-komponentin tekemät tietokantakyselyt näkyviksi. Komento <code>logging.file=</code> ohjaa viestit konsoliin.</p>

                    <pre>
logging.level.org.springframework.web.servlet.DispatcherServlet=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type=TRACE
logging.file=</pre>

                    <p>Jos haluat nähdä kaiken mitä sovelluksessa tapahtuu, aseta konfiguraatio seuraavanlaiseksi:</p>

                    <pre>
logging.level.=TRACE
logging.file=</pre>

                </aside>





                <aside class="extra">

                    <h1>Riippuvuuksien lataamisen manuaalinen käynnistäminen NetBeansissa</h1>

                    <p>Jos NetBeans-projektin kuvakkeessa on keltainen kolmio sekä lähdekoodikansioissa mahdollinen punainen pallo, saat lisätietoa ongelmasta viemällä hiiren projektin nimen päälle.</p>

                    <p>Jos ongelmana näkyy teksti "Some dependency artifacts are not in the local repository.", eli osaa riippuvuuksista ei ole ladattu paikalliselle koneelle, voit valita oikealla hiirennäppäimellä Dependencies ja "Download Declared Dependencies". Nyt NetBeans pyytää Mavenia lataamaan riippuvuudet.</p>

                    <p>Riippuvuudet ladataan käyttäjän kotihakemiston alla olevaan kansioon ".m2".</p>

                </aside>


                <h1>Webin peruskomponentit</h1>


                <aside class="pohdi">
                    <h1>Osoitteen osat</h1>

                    <p>Tutki osoitetta <a href="http://www.googlefight.com/index.php?lang=en_GB&word1=Batman&word2=Superman" target="_blank">http://www.googlefight.com/index.php?lang=en_GB&word1=Batman&word2=Superman</a>. Mitkä tai mikä ovat/on osoitteen:</p>

                    <ul>
                        <li>protokolla</li>
                        <li>isäntäkone</li>
                        <li>portti</li>
                        <li>polku</li>
                        <li>kohdedokumentti</li>
                        <li>kyselyparametrit</li>
                        <li>ankkuri</li>
                    </ul>

                    <p>Mitkä näistä puuttuvat?</p>
                </aside>


                <h2>HTTP</h2>

                <aside class="extra">
                    <p><strong>Google Dev Tools</strong></p>

                    <p>Google Chromen DevTools-apuvälineet löytää Tools-valikosta tai painamalla F12 (Linux). Apuvälineillä voi esimerkiksi tarkastella verkkoliikennettä ja lähetettyjä ja vastaanotettuja paketteja. Valitsemalla työvälineistä Network-välilehden, ja lataamalla sivun uudestaan, näet kaikki sivua varten ladattavat osat sekä kunkin osan lataamiseen kuluneen ajan.</p>

                </aside>
		
		<h2>Tehtavien nayttaminen</h2>

                <div class="tehtavat">

                    <p>Tästä eteenpäin materiaalissa on myös ohjelmointitehtäviä. Tehtävien tekeminen ja palautus tapahtuu NetBeans-ympäristössä Test My Code-liitännäisen avulla. Test My Code lataa tehtäväpohjat sinulle valmiiksi, eli et tarvitse <code>start.spring.io</code>-osoitteen projektipohjia tehtävien tekemiseen. Muistathan palauttaa jokaisen tehtävän (<em>submit solution</em>). Tehtävät avataan tehtävän otsikkoa klikkaamalla.</p>

                    <p>Huomaat, että tehtävien lisäksi TMC lataa käyttöösi myös projektin nimeltä Hiekkalaatikko. Voit käyttää sitä omiin kokeiluihin.</p>

                    <div class="tehtava" id="t-helloweb-ex">

                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-helloweb">
                                    Hello World!
                                </a>
                            </h1>
                        </header>

                        <div id="t-helloweb" class="collapse">

                            <p>Kuten huomattava osa ohjelmointikursseista, tämäkin kurssi alkaa tehtävällä, jossa toteutettava ohjelma kirjoittaa tekstin <code>Hello World!</code>.</p>

                            <p>Toteuta pakkauksessa <code>wad.controller</code> olevaan luokkaan <code>HelloWorldController</code> kontrollerimetodi, joka kuuntelee kaikkia osoitteita. Kun palvelin vastaanottaa pyynnön, tulee palvelimen palauttaa merkkijono "Hello World!".</p>

                            <p>Käynnistä palvelin painamalla NetBeansin play-nappia tai suorittamalla <code>Application</code>-luokan <code>main</code>-metodi. Avaa nettiselain, mene osoitteeseen <a href="http://localhost:8080/" target="_blank">http://localhost:8080/</a>, ja näet selaimessasi tekstin "Hello World!".</p>

                            <p><img class="browser-img" src="img/exercises/w1e01.png"/></p>

                            <p>Palvelin sammutetaan NetBeansissa punaista nappia painamalla -- vain yksi sovellus voi olla kerrallaan päällä samassa osoitteessa. Palauta tehtävä lopuksi Test My Code:n submit-napilla.</p>
                        </div>
                    </div>

                    <div class="tehtava" id="t-vieraslaskuri">

                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-vieraslaskuri">
                                    Vieraslaskuri
                                </a>
                            </h1>
                        </header>
                        <div id="t-vieraslaskuri" class="collapse">
                            <p>Vieraslaskuri kertoo kävijälle kuinka monta kävijää sivulla on käynyt tähän mennessä. Ensimmäinen kävijä näkee luvun 1, toinen kävijä luvun 2, jne.</p>

                            <p>Toteuta pakkauksessa <code>wad.controller</code> olevaan luokkaan <code>VisitCountController</code> polkua <code>/visits</code> kuunteleva metodi, joka toteuttaa toivotun toiminnallisuuden. Vinkki! Kontrolleriluokka luodaan vain kerran palvelimen käynnistyksen yhteydessä, joten voinet hyödyntää jotain sopivaa oliomuuttujaa.</p>

                            <p>Testaa sovellustasi. Ensimmäisellä pyynnöllä osoitteeseen <code>http://localhost:8080/visits</code> sinun pitäisi nähdä numero 1, toisella pyynnöllä numero 2 jne. Kun käynnistät palvelimen uudelleen, laskuri alkaa taas yhdestä.</p>
                        </div>
                    </div>
                </div>


		<p>Ja toinen tehtävä</h2>

                <div class="tehtavat">

                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-kaikupalvelu">
                                    Papukaija Bob
                                </a>
                            </h1>
                        </header>
                        <div id="t-kaikupalvelu" class="collapse">

                            <p>Papukaija <a href="https://www.youtube.com/watch?v=6NG37huf2dU" target="_blank">Bob</a> on netti-ilmiö, joka on oppinut sanoja, joita se toistaa. Tässä tehdään Bobille vastine, joka osaa toistaa sille sanottavia asioita.</p>

                            <p>Toteuta luokkaan <code>ParrotController</code> kontrollerimetodi, joka kuuntelee pyyntöjä <code>/bob</code>-osoitteessa. Jos pyynnön mukana ei ole <code>message</code>-nimistä parametria, on vastaus <code>"Krraaa"</code>. Muuten, vastaus on <code>"Krraaa"</code>, jota seuraa välilyönti ja <code>message</code>-parametrin arvo.</p>

                            <p>Kun testaat sovellusta, pyyntö osoitteeseen <code>http://localhost:8080/bob</code> näyttää sivun, jossa on merkkijono <code>"Krraaa"</code>, kun taas esimerkiksi pyyntö <code>http://localhost:8080/bob?message=keksii</code> palauttaa merkkijonon <code>"Krraaa keksii"</code>.</p>
                        </div>
                    </div>

                    <div class="tehtava">
                        <header>
                            <h1>
                                <a data-toggle="collapse" class="collapsed" href="#t-laskin">
                                    Laskin
                                </a>
                            </h1>
                        </header>
                        <div id="t-laskin" class="collapse">

                            <p>Toteuta luokkaan <code>CalculatorController</code> kontrollerimetodi, joka kuuntelee pyyntöjä <code>/calculate</code>-osoitteessa. Pyynnön mukana voi olla kolme parametria. Parametri <code>"op"</code> kertoo laskuoperaation, <code>"first"</code> kertoo ensimmäisen laskettavan luvun, ja <code>"second"</code> kertoo toisen laskettavan luvun.</p>

                            <p>Jos parametria <code>"op"</code> ei ole pyynnössä mukana, tulee sen saada oletusarvoksi <code>"plus"</code>. Jos parametri <code>"first"</code> puuttuu, saa se oletuksena arvon 0. Myös parametri <code>"second"</code> saa puuttuessaan arvon 0.</p>

                            <p>Laskimen tulee toteuttaa seuraavat operaatiot:</p>

                            <ul>
                                <li>Kun operaatio (op) on <code>"plus"</code> laskin palauttaa lukujen <code>"first"</code> ja <code>"second"</code> summan. Esim. pyyntö osoitteeseen <code>http://localhost:8080/calculate?op=plus&first=3&second=1</code> palauttaa arvon <code>4</code>.</li>
                                <li>Kun operaatio (op) on <code>"minus"</code> laskin palauttaa lukujen <code>"first"</code> ja <code>"second"</code> erotuksen. Esim. pyyntö osoitteeseen <code>http://localhost:8080/calculate?op=minus&first=7&second=2</code> palauttaa arvon <code>5</code>.</li>
                                <li>Kun operaatio (op) on <code>"multiply"</code> laskin palauttaa lukujen <code>"first"</code> ja <code>"second"</code> tulon. Esim. pyyntö osoitteeseen <code>http://localhost:8080/calculate?op=multiply&first=11&second=3</code> palauttaa arvon <code>33</code>.</li>
                            </ul>
                        </div>
                    </div>
                </div>


		<p>Moniosainen tehtävä</p>

                <div class="tehtava">
                    <header>
                        <h1>
                            <a data-toggle="collapse" class="collapsed" href="#t-tehtavalista">
                                Tehtävälista
                            </a>
                        </h1>
                    </header>
                    <div id="t-tehtavalista" class="collapse">
                        <p>Tässä tehtävässä toteutetaan tehtävälistatoiminnallisuutta. Tehtäväpohjassa on valmis tietokantakonfiguraatio, missä käytetään muistiin ladattavaa tietokantaa -- tietokanta tyhjenee palvelimen sammuessa.</p>

                        <h1>Tehtävien listaaminen</h1>

                        <p>Toteuta <code>TaskController</code>-luokkaan <code>/tasks</code>-osoitteeseen tulevia GET-tyyppisiä pyyntöjä kuunteleva kontrollerimetodi. Pyynnön tulee lisätä <code>model</code>-parametriin <code>tasks</code> kaikki tietokannasta löytyvät tehtävät. Tässä <code>taskRepository</code>-olion <code>findAll</code>-metodi on hyödyksi. Palauta käyttäjälle kansiossa <code>/WEB-INF/views</code> oleva <code>page.jsp</code>-sivu.</p>

                        <h1>Tehtävän lisääminen</h1>

                        <p>Toteuta <code>TaskController</code>-luokkaan <code>/tasks</code>-osoitteeseen tulevia POST-tyyppisiä pyyntöjä kuunteleva kontrollerimetodi. Pyynnön mukana tulee <code>name</code> ja <code>done</code>-parametrit, joiden pohjalta luodaan uusi tehtävä. Jos tehtävän nimi (<em>name</em>) ei ole tyhjä ja se ei ole null, tulee tehtävä tallentaa tietokantaan. Tässä <code>taskRepository</code>-olion <code>save</code>-metodi on hyödyksi.</p>

                        <p>Kun uusi tehtävä on lisätty, uudelleenohjaa pyyntö aiemmin toteuttamallesi tehtävät listaavalle kontrollerimetodille.</p>

                        <h1>Tehtävän poistaminen</h1>

                        <p>Toteuta <code>TaskController</code>-luokkaan <code>/tasks/{id}/delete</code>-osoitteeseen POST-tyyppisiä pyyntöjä kuunteleva kontrollerimetodi. Poistettavan tehtävän <code>id</code> on osana osoitetta. Tässä <code>taskRepository</code>-olion <code>delete</code>-metodi on hyödyksi.</p>

                        <p>Kun tehtävä on poistettu, uudelleenohjaa pyyntö aiemmin toteuttamallesi tehtävät listaavalle kontrollerimetodille.</p>

                        <h1>Tehtävän muuttaminen tehdyksi</h1>

                        <p>Toteuta <code>TaskController</code>-luokkaan <code>/tasks/{id}/done</code>-osoitteeseen POST-tyyppisiä pyyntöjä kuunteleva kontrollerimetodi. Tehtävän, joka tulee asettaa tehdyksi, <code>id</code> on osana osoitetta. Tässä <code>taskRepository</code>-olion <code>findOne</code>-metodi on hyödyksi.</p>

                        <p>Kun tehtävä on on asetettu tehdyksi, uudelleenohjaa pyyntö aiemmin toteuttamallesi tehtävät listaavalle kontrollerimetodille. Huom! Jotta tietokannasta hakemaasi olioon tehdyt muutokset päivittyvät, sinun tulee joko käyttää <code>@Transactional</code>-annotaatiota, tai tallentaa olio muutosten jälkeen.</p>
                    </div>
                </div>



-->


	    </section>
            <!-- END WEEK7 -->

        </article>

        <footer>
            <p>
                <a id="license" rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.0/"><img alt="Creative Commons License" style="border-width:0; float:left; padding:15px" src="http://i.creativecommons.org/l/by-nc-sa/2.0/88x31.png" /></a>
                <small>T&auml;m&auml; materiaali on lisensoitu Creative Commons BY-NC-SA-lisenssill&auml;, joten voit k&auml;ytt&auml;&auml; ja levitt&auml;&auml; sit&auml; vapaasti, kunhan alkuper&auml;isten tekij&ouml;iden nimi&auml; ei poisteta. Jos teet muutoksia materiaaliin ja haluat levitt&auml;&auml; muunneltua versiota, se t&auml;ytyy lisensoida samanlaisella vapaalla lisenssill&auml;. Materiaalien k&auml;ytt&ouml; kaupalliseen tarkoitukseen on ilman erillist&auml; lupaa kielletty. Tekij&auml;(t): <a href="http://www.cs.helsinki.fi/en/people/avihavai" target="_blank">Arto Vihavainen</a> ja <a href="http://www.cs.helsinki.fi/en/people/mluukkai" target="_blank">Matti Luukkainen</a> (<a href="http://www.cs.helsinki.fi/en/rage" target="_blank">Agile Education Research</a> -tutkimusryhm&auml;).
            </p>
        </footer>

        <div class="hidden">
            <p>the end.</p>
        </div>


        <script src="js/libs/jquery/jquery.js"></script>
        <script src="js/libs/jqueryui/jquery-ui.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
<!--
	<script src="js/libs/bootstrap.min.js"></script>
-->
        <script src="js/libs/syntaxhighlight/sh_main.min.js"></script>
        <script src="js/tikape.js"></script>



	<!-- angularjs -->
<!--	<script src="js/libs/angular.min.js"></script>
-->	<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.5/angular.min.js"></script>

	<!-- tikape sqljs -- https://github.com/mluukkai/tikape-sqljs -->
        <script src="js/libs/sql.js"></script>
        <script src="js/table.js"></script>
        <script src="js/app.js"></script>
        <script src="js/directives.js"></script>
    </body>
</html>
